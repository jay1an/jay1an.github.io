<!DOCTYPE html>
<html lang="en">
    
    <style>
        body
        {
            font-family: "Times New Roman", Helvetica, Tahoma, Arial,   LXGW WenKai   "notoserifsc-medium", "Microsoft YaHei", "Hiragino Sans GB", "WenQuanYi Micro Hei", sans-serif !important;

        }
    </style>

    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="刷题日记 - 12" />
    <meta name="hexo-theme-A4" content="v1.9.0" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title>Jay1an</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery.min.css">


<meta name="generator" content="Hexo 7.3.0"></head>
    
    <style>
        :root {
            --waline-theme-color: #323e74; 
            --waline-color: #323e74; 
            --waline-border-color: #323e74; 
            --waline-white: #323e74; 
            --waline-bgcolor-light: #f2fafc;  
        }
        body {
            color: #323e74;
            background: #eaeae8;
        }
        .post-md code {
            background: #e7f7f3;
            color: #7f688d; 
        }
        .post-md pre, .post-md .highlight {
            background: #e7f7f3;
            color: #7f688d; 
        }
        pre .string, pre .value, pre .inheritance, pre .header, pre .ruby .symbol, pre .xml .cdata {
            color: #323e74;
        }
        pre .number, pre .preprocessor, pre .built_in, pre .literal, pre .params, pre .constant {
            color: #323e74;
        }
        .year-font-color {
            color: #323e74 !important;
        }
        .wl-card span.wl-nick {
            color: #323e74; 
        }
        .wl-card .wl-badge {
            border: 1px solid #323e74;
            color: #323e74; 
        }
        .wl-btn {
            border: 1px solid #323e74; 
            color:  #323e74;  
        }
        .wl-btn.primary {
            color: #f2fafc; 
        }
        .wl-header label {
            color: #323e74;
        }
        a {
            color: #7f688d;
        }

        .post-md a {
            color: #7f688d;
        }

        .nav li a {
            color: #7f688d;
        }

        .archive-main a:link {
            color: #7f688d;
        }
        .archive-main a:visited {
            color: #767c7c; 
        }

        .archive li span {
            color: #323e74;
        }

        .post-main-title {
            color: #323e74;
        }

        .post-md h1,
        .post-md h2,
        .post-md h3,
        .post-md h4,
        .post-md h5,
        .post-md h6 {
            color: #323e74;
        }

        [data-waline] p {
            color: #323e74;
        }
        [data-waline] a {
            color: #323e74;
        } 
        .wl-sort li.active {
            color: #323e74;
        }

        .wl-card .wl-meta>span {
            background: #f2fafc;
        }

        .paper {
            background: #eaeae8;
        }

        .index-main {
            background: #f2fafc;
        }

        .paper-main {
            background: #f2fafc;
        }

        .wl-panel {
            background: #f2fafc;
        }

        .archive li:nth-child(odd) {
            background: #f2fafc;
            ;
        }

        .archive li:nth-child(even) {
            background: #f2fafc;
        }

        .post-md table tr:nth-child(odd) td {
            background: #f2fafc;
        }

        .post-md table tr:nth-child(even) td {
            background: #f2fafc;
        }

    
        .progress-wrap::after {
            color: #323e74; /* 箭头的颜色 */
        }
        .progress-wrap svg.progress-circle path {
	        stroke: #323e74; /* 边框的颜色 */
        }
        .progress-wrap::before {
	        background-image: linear-gradient(298deg, #7f688d, #7f688d); /* 鼠标滑过的箭头颜色 */
         }

        .return-to-last-progress-wrap::after {
            color: #323e74; /* 箭头的颜色 */
        }
        .return-to-last-progress-wrap svg.progress-circle path {
	        stroke: #323e74; /* 边框的颜色 */
        }
        .return-to-last-progress-wrap::before {
	        background-image: linear-gradient(298deg, #7f688d, #7f688d); /* 鼠标滑过的箭头颜色 */
         }

         .left-toc-container::-webkit-scrollbar-thumb {
            background-color: #323e74; /* 设置滚动条拖动块的颜色 */
        }

        .bs-docs-sidebar .nav>.active>a,
        .bs-docs-sidebar .nav>li>a:hover,
        .bs-docs-sidebar .nav>li>a:focus {
            color: #7f688d;
            border-left-color: #7f688d;
        }
        .bs-docs-sidebar .nav>li>a {
            color:  #323e74;
        }
    </style>

    
    
    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Jay1an</a> 
            <span class="description">I am who I am.</span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            刷题日记 - 12
        </div>
      
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0-12"><span class="post-toc-text">刷题日记 - 12</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#159-%E8%87%B3%E5%A4%9A%E5%8C%85%E5%90%AB%E4%B8%A4%E4%B8%AA%E4%B8%8D%E5%90%8C%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">159. 至多包含两个不同字符的最长子串 - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#934-%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">934. 最短的桥 - 力扣（LeetCode）</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#SCU%E6%9F%90%E5%AD%A6%E9%99%A2%E9%A2%84%E6%8E%A8%E5%85%8D%E6%9C%BA%E8%AF%95%E9%A2%98"><span class="post-toc-text">SCU某学院预推免机试题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%AC%AC%E4%B8%80%E9%A2%98%EF%BC%9A%E5%AF%BB%E6%89%BE%E5%8D%95%E8%BA%AB%E6%95%B0"><span class="post-toc-text">第一题：寻找单身数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%A2%98%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="post-toc-text">第二题：二叉树的层序遍历</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%AC%AC%E4%B8%89%E9%A2%98%EF%BC%9A%E6%88%90%E7%BB%A9%E6%8E%92%E5%BA%8F"><span class="post-toc-text">第三题：成绩排序</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%A2%98%EF%BC%9A%E6%89%93%E5%8D%B0%E5%86%85%E5%AD%98"><span class="post-toc-text">第四题：打印内存</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BE%93%E5%85%A5%EF%BC%9A"><span class="post-toc-text">输入：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BE%93%E5%87%BA%EF%BC%9A"><span class="post-toc-text">输出：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%A7%A3%EF%BC%9A"><span class="post-toc-text">解：</span></a></li></ol></li></ol></li></ol></li></ol>
            
        
        <link rel="stylesheet" type="text/css" href="/css/lightgallery.min.css" /><div class="article-gallery"><h1 id="刷题日记-12"><a href="#刷题日记-12" class="headerlink" title="刷题日记 - 12"></a>刷题日记 - 12</h1><h3 id="159-至多包含两个不同字符的最长子串-力扣（LeetCode）"><a href="#159-至多包含两个不同字符的最长子串-力扣（LeetCode）" class="headerlink" title="159. 至多包含两个不同字符的最长子串 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-with-at-most-two-distinct-characters/description/">159. 至多包含两个不同字符的最长子串 - 力扣（LeetCode）</a></h3><p>难度：中等</p>
<p><strong>滑动窗口</strong></p>
<p>会员题，CSDN地址：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zjwreal/article/details/102730082">【leetcode】159 至多包含两个不同字符的最长子串（滑动窗口，双指针）_leetcode 159. 至多包含两个不同字符的最长子串 c语言-CSDN博客</a></p>
<p>在牛课上看到说是华为的面试手撕题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstringTwoDistinct</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> chars.length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// [left,right)</span></span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(right&lt;len)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">rightChar</span> <span class="operator">=</span> chars[right++];</span><br><span class="line">            <span class="keyword">if</span>(cnt[rightChar-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[rightChar-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">while</span>(count&gt;<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">leftChar</span> <span class="operator">=</span> chars[left++];</span><br><span class="line">                cnt[leftChar-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                <span class="keyword">if</span>(cnt[leftChar-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>)count--;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res,right-left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>普通的滑动窗口，需要用count记录当前窗口中的字符种数，cnt数组维护具体字符的个数。</p>
<h3 id="934-最短的桥-力扣（LeetCode）"><a href="#934-最短的桥-力扣（LeetCode）" class="headerlink" title="934. 最短的桥 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-bridge/description/">934. 最短的桥 - 力扣（LeetCode）</a></h3><p>难度：中等</p>
<p><strong>图</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestBridge</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 找到其中一个岛屿的起始点</span></span><br><span class="line">        <span class="comment">// 初始化坐标 x 和 y，找到第一个值为 1 的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 用于跳出循环的标志</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123; <span class="comment">// 找到第一个岛屿的某个点</span></span><br><span class="line">                    x = i; <span class="comment">// 记录 x 坐标</span></span><br><span class="line">                    y = j; <span class="comment">// 记录 y 坐标</span></span><br><span class="line">                    flag = <span class="literal">false</span>; <span class="comment">// 找到后将 flag 置为 false</span></span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 结束内层循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) <span class="keyword">break</span>; <span class="comment">// 如果已经找到，结束外层循环</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 使用 DFS 扩展岛屿，计算最短桥梁</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 用于存储结果，初始值为 -1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfs(i, x, y, grid) == <span class="literal">true</span>) &#123; <span class="comment">// 如果找到另一座岛屿</span></span><br><span class="line">                res = i - <span class="number">1</span>; <span class="comment">// 返回需要的步数，即 round - 1</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 找到桥后，结束循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归函数 dfs，用于扩展岛屿并寻找另一座岛</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> round, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 边界检查：坐标越界时返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= grid.length || y &gt;= grid.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 超出矩阵边界</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 获取当前坐标的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curVal</span> <span class="operator">=</span> grid[x][y];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 如果当前点已经被扩展到 round，继续向周围扩展</span></span><br><span class="line">        <span class="keyword">if</span> (curVal == round) &#123;</span><br><span class="line">            grid[x][y] = round + <span class="number">1</span>; <span class="comment">// 将当前点的值更新为 round + 1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 递归向上下左右扩展</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">a</span> <span class="operator">=</span> dfs(round, x - <span class="number">1</span>, y, grid) || dfs(round, x + <span class="number">1</span>, y, grid);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> dfs(round, x, y - <span class="number">1</span>, grid) || dfs(round, x, y + <span class="number">1</span>, grid);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 返回结果，判断是否找到另一座岛</span></span><br><span class="line">            <span class="keyword">return</span> a || b;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 如果当前点是水（值为 0），则将其标记为 round + 1，表示扩展到了该位置</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curVal == <span class="number">0</span>) &#123;</span><br><span class="line">            grid[x][y] = round + <span class="number">1</span>;  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 如果当前点是另一个岛屿（值为 1），返回 true，表示找到另一座岛</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curVal == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 找到另一座岛屿</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果没有找到岛屿，返回 false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用dfs一次一次扩充岛屿，记录每一次扩充，当扩充到可以连接到另外一个岛屿时停止，但是这个方法会重复访问岛的中心部分，并且一个点会被多次访问（因为没有visited数组），时间复杂度偏高。</p>
<hr>
<p><strong>优化：</strong></p>
<ul>
<li><p>先找到某一个岛屿，利用<code>dfs</code>和<code>visited</code>数组与队列<code>queue</code>，将岛屿的所有点都加入队列<code>queue</code></p>
</li>
<li><p>然后根据队列<code>queue</code>和<code>visited</code>数组一步一步往外扩展</p>
<ul>
<li>扩展第一层：<code>for(int i=0;i&lt;size;i++)</code>，<code>size</code>为初始的岛屿数量，每一次从队列中取出一个点，将附近的水的坐标加入队列，等到<code>i==size-1</code>时候，就表明第一层扩展结束了。</li>
<li>扩展第二层，重新获取<code>size</code>的值，同上继续扩展….</li>
<li>直到某次从队列中取出点，点的附近是另一个岛屿，结束扩展，<code>res</code>与扩展的次数有关。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] directions = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestBridge</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();  <span class="comment">// 这个队列存放边界点（第一次是岛屿所有的点，后面几次才是边界点）</span></span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 找到并标记第一个岛屿，同时将岛屿所有的点加入队列</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (found) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    dfsMarkIsland(grid, visited, queue, i, j);</span><br><span class="line">                    found = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 使用 BFS 扩展边界，寻找另一座岛屿 </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">steps</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">int</span>[] point = queue.poll();</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> point[<span class="number">0</span>], y = point[<span class="number">1</span>];</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 扩展四个方向</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span>[] dir : directions) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">newX</span> <span class="operator">=</span> x + dir[<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">newY</span> <span class="operator">=</span> y + dir[<span class="number">1</span>];</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 检查边界</span></span><br><span class="line">                    <span class="keyword">if</span> (newX &gt;= <span class="number">0</span> &amp;&amp; newY &gt;= <span class="number">0</span> &amp;&amp; newX &lt; n &amp;&amp; newY &lt; n &amp;&amp; !visited[newX][newY]) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (grid[newX][newY] == <span class="number">1</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> steps; <span class="comment">// 找到另一个岛屿，返回步数</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (grid[newX][newY] == <span class="number">0</span>) &#123;</span><br><span class="line">                            queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;newX, newY&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        visited[newX][newY] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps++; <span class="comment">// 每扩展一层，步数加1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 理论上不会走到这里</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深度优先搜索标记第一个岛屿，并将所有点加入队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfsMarkIsland</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">boolean</span>[][] visited, Queue&lt;<span class="type">int</span>[]&gt; queue, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x, y&#125;); <span class="comment">// 将岛屿点加入队列</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] dir : directions) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newX</span> <span class="operator">=</span> x + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">newY</span> <span class="operator">=</span> y + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (newX &gt;= <span class="number">0</span> &amp;&amp; newY &gt;= <span class="number">0</span> &amp;&amp; newX &lt; n &amp;&amp; newY &lt; n &amp;&amp; !visited[newX][newY] &amp;&amp; grid[newX][newY] == <span class="number">1</span>) &#123;</span><br><span class="line">                dfsMarkIsland(grid, visited, queue, newX, newY);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SCU某学院预推免机试题"><a href="#SCU某学院预推免机试题" class="headerlink" title="SCU某学院预推免机试题"></a>SCU某学院预推免机试题</h2><blockquote>
<p>最终擦边获得推免资格。</p>
<p>先暂停秋招，暂停刷题。</p>
</blockquote>
<p>学院预推免机试系统仅支持C&#x2F;C++语言，难度中等偏易。</p>
<h3 id="第一题：寻找单身数"><a href="#第一题：寻找单身数" class="headerlink" title="第一题：寻找单身数"></a>第一题：寻找单身数</h3><p><a href="/../img/coding-practice-12/1.png" title="1" class="gallery-item" style="box-shadow: none;"> <img src="/../img/coding-practice-12/1.png" alt="1"></a></p>
<p>利用异或的特性：</p>
<ul>
<li><p>a^a &#x3D; 0</p>
</li>
<li><p>a^0 &#x3D; a</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> input;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">// 直接异或</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;input;</span><br><span class="line">		res = res^input; <span class="comment">// 出现过两次的数会被消除</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;res&lt;&lt;endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二题：二叉树的层序遍历"><a href="#第二题：二叉树的层序遍历" class="headerlink" title="第二题：二叉树的层序遍历"></a>第二题：二叉树的层序遍历</h3><p><a href="/../img/coding-practice-12/image-20241001155017882.png" title="image-20241001155017882" class="gallery-item" style="box-shadow: none;"> <img src="/../img/coding-practice-12/image-20241001155017882.png" alt="image-20241001155017882"></a></p>
<p>本题需要自己根据输入构造二叉树，然后利用队列完成层序遍历即可。（比leetcode上的简单，因为这里不用分层）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 定义树节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> left;</span><br><span class="line">		<span class="type">int</span> right;</span><br><span class="line">		<span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;   <span class="comment">// 节点个数</span></span><br><span class="line">    <span class="comment">// 先将所有Node初始化好 </span></span><br><span class="line">	Node con[<span class="number">101</span>];            </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;   </span><br><span class="line">		Node node;</span><br><span class="line">		node.val = i;</span><br><span class="line">		con[i] = node;       	</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">// 完善树的左右孩子</span></span><br><span class="line">	<span class="type">int</span> left,right;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;left&gt;&gt;right;</span><br><span class="line">		con[i].left = left;</span><br><span class="line">		con[i].right = right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 根节点 </span></span><br><span class="line">	Node root = con[<span class="number">1</span>];</span><br><span class="line">	<span class="comment">// 层序遍历逻辑</span></span><br><span class="line">	<span class="type">int</span> res[<span class="number">101</span>];  <span class="comment">// 记录结果</span></span><br><span class="line">	<span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">	deque&lt;Node&gt; q; <span class="comment">// 双向队列</span></span><br><span class="line">	q.<span class="built_in">push_back</span>(root);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		Node top = q.<span class="built_in">front</span>();  <span class="comment">// 获取队头节点</span></span><br><span class="line">		q.<span class="built_in">pop_front</span>();         <span class="comment">// 出队</span></span><br><span class="line">		res[idx++] = top.val;  <span class="comment">// 记录结果</span></span><br><span class="line">		<span class="keyword">if</span>(top.left!=<span class="number">-1</span>)q.<span class="built_in">push_back</span>(con[top.left]);  <span class="comment">// 将头节点的左右孩子入队</span></span><br><span class="line">		<span class="keyword">if</span>(top.right!=<span class="number">-1</span>)q.<span class="built_in">push_back</span>(con[top.right]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 输出</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;idx;i++)&#123;</span><br><span class="line">		cout&lt;&lt;res[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三题：成绩排序"><a href="#第三题：成绩排序" class="headerlink" title="第三题：成绩排序"></a>第三题：成绩排序</h3><p><a href="/../img/coding-practice-12/3.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="/../img/coding-practice-12/3.png" alt="img"></a></p>
<p>本题涉及两个排序：对成绩的排序，对相同成绩的同学的姓名进行排序。</p>
<ul>
<li><p>对成绩排序很简单，我直接采用桶排序，如果某个桶内有多名同学，那么该桶内需要姓名排序。</p>
</li>
<li><p>那么对于姓名排序，Java可以通过自定义排序规则达到，然而本系统要求提交C&#x2F;C++，最后通过自己实现字符排序函数和冒泡排序函数实现姓名的排序。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 定义学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		string name;</span><br><span class="line">		<span class="type">int</span> scores;  <span class="comment">// 直接记录总分即可。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_name</span><span class="params">(string name_1,string name_2)</span></span>; <span class="comment">// name比较函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(Student *students,<span class="type">int</span> n,<span class="type">int</span> *bucket)</span></span>; <span class="comment">// 针对name的冒牌排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	Student students[<span class="number">101</span>];</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="comment">// 初始化学生</span></span><br><span class="line">	string input_name;</span><br><span class="line">	<span class="type">int</span> a,b,c;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;input_name;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		Student student;</span><br><span class="line">		student.name = input_name;</span><br><span class="line">		student.scores = a+b+c;</span><br><span class="line">		students[i] = student;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 定义一个bucket二维数组，记录学生和分数的关系 </span></span><br><span class="line">	<span class="type">int</span> buckets[<span class="number">301</span>][<span class="number">102</span>];   <span class="comment">// bucket[i][101]记录当前桶内元素个数,即总分为i有多少个学生</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">300</span>;i++)&#123; </span><br><span class="line">		buckets[i][<span class="number">101</span>]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 遍历students </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		Student student = students[i];</span><br><span class="line">		<span class="type">int</span> scores = student.scores;</span><br><span class="line">		<span class="type">int</span> idx = buckets[scores][<span class="number">101</span>];</span><br><span class="line">		buckets[scores][idx] = i;   <span class="comment">// 桶内存放学生编号</span></span><br><span class="line">		buckets[scores][<span class="number">101</span>]++;     <span class="comment">// 当前桶内的人数+1</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 输出</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">300</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="type">int</span> amount = buckets[i][<span class="number">101</span>];</span><br><span class="line">		<span class="keyword">if</span>(amount&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="comment">// 处理字典序</span></span><br><span class="line">			<span class="keyword">if</span>(amount&gt;<span class="number">1</span>)&#123;  <span class="comment">// 如果桶内的元素不止1个，就需要字典序排序，这里调用自定义sort函数</span></span><br><span class="line">				<span class="built_in">sort</span>(students,n,buckets[i]); <span class="comment">// ⭐⭐⭐</span></span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;amount;j++)&#123;</span><br><span class="line">				<span class="type">int</span> student_idx = buckets[i][j];</span><br><span class="line">				cout&lt;&lt;students[student_idx].name&lt;&lt;endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于桶内排序 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(Student *students,<span class="type">int</span> n,<span class="type">int</span> *bucket)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> size = bucket[<span class="number">101</span>];</span><br><span class="line">	<span class="comment">// 冒泡排序</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=size<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">			Student cur = students[bucket[j]];</span><br><span class="line">			Student next = students[bucket[j+<span class="number">1</span>]];</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">compare_name</span>(cur.name,next.name)==<span class="number">0</span>)&#123;  <span class="comment">// 如果当前j和j+1的名字，j应该后移，就交换j和j+1 </span></span><br><span class="line">                <span class="comment">// swap</span></span><br><span class="line">				<span class="type">int</span> tmp = bucket[j];</span><br><span class="line">				bucket[j] = bucket[j+<span class="number">1</span>];</span><br><span class="line">				bucket[j+<span class="number">1</span>] = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义name比较函数</span></span><br><span class="line"><span class="comment">// 返回true，表明name_1应该排在name_2前面或相等</span></span><br><span class="line"><span class="comment">// 返回false，表明name_1应该排在name_2后面</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_name</span><span class="params">(string name_1,string name_2)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> len_1 = name_1.<span class="built_in">length</span>();</span><br><span class="line">	<span class="type">int</span> len_2 = name_2.<span class="built_in">length</span>();</span><br><span class="line">	<span class="keyword">if</span>(len_1&lt;=len_2)&#123;</span><br><span class="line">		string substring = name_2.<span class="built_in">substr</span>(<span class="number">0</span>,len_1);</span><br><span class="line">		<span class="type">int</span> tmp = name_1.<span class="built_in">compare</span>(substring);</span><br><span class="line">		<span class="keyword">if</span>(tmp&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		string substring = name_1.<span class="built_in">substr</span>(<span class="number">0</span>,len_2);</span><br><span class="line">		<span class="type">int</span> tmp = substring.<span class="built_in">compare</span>(name_2);</span><br><span class="line">		<span class="keyword">if</span>(tmp&lt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>a.compare(b)</code>返回的是一个整数</p>
<p>如果 <code>a</code> 小于 <code>b</code>，返回一个负数。（a在字典序中排在前）</p>
<p>如果 <code>a</code> 等于 <code>b</code>，返回 <code>0</code>。</p>
<p>如果 <code>a</code> 大于 <code>b</code>，返回一个正数。（b在字典序中排在后）</p>
</blockquote>
<p>所以，其实程序中可以不用单独写一个<code>compare_name</code>的函数，当时不太了解<code>string.compare()</code>函数，所以额外写了一些没必要的操作。。。Anyways，AC了。</p>
<h3 id="第四题：打印内存"><a href="#第四题：打印内存" class="headerlink" title="第四题：打印内存"></a>第四题：打印内存</h3><p><a href="/../img/coding-practice-12/4.png" title="img" class="gallery-item" style="box-shadow: none;"> <img src="/../img/coding-practice-12/4.png" alt="img"></a></p>
<h4 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h4><p>一个正整数N，表示有N个数</p>
<p>N个数</p>
<h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><p>依次输出这N个数每个数对应的内存</p>
<h4 id="解："><a href="#解：" class="headerlink" title="解："></a>解：</h4><p>无符号整数，4字节32位。</p>
<p>而内存使用16进制表示，一个16进制数用4位二进制表示。</p>
<p>那么一个无符号整数32位就需要8个16进制数来表示，所以我们直接4位一组将目标数分割提取出来（位运算），将其转换为8个16进制数即可，然后根据小端存储的规则将其打印。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> num)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//  位运算 </span></span><br><span class="line"><span class="comment">//	1    2    3    4    5    6    7    8</span></span><br><span class="line"><span class="comment">//	0000 1111 0000 0000 0000 0000 0000 0000</span></span><br><span class="line"><span class="comment">//  1245 1245 5451 1242 0000 0000 0000 0000</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> input;</span><br><span class="line">		cin&gt;&gt;input;</span><br><span class="line">		<span class="built_in">fun</span>(input);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// fun(2024);</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 32位  4*8</span></span><br><span class="line">	<span class="type">int</span> helper[<span class="number">9</span>];  <span class="comment">// 辅助位运算的数组</span></span><br><span class="line">	helper[<span class="number">1</span>] = <span class="number">0x0000000f</span>;</span><br><span class="line">	helper[<span class="number">2</span>] = <span class="number">0x000000f0</span>;</span><br><span class="line">	helper[<span class="number">3</span>] = <span class="number">0x00000f00</span>;</span><br><span class="line">	helper[<span class="number">4</span>] = <span class="number">0x0000f000</span>;</span><br><span class="line">	helper[<span class="number">5</span>] = <span class="number">0x000f0000</span>;</span><br><span class="line">	helper[<span class="number">6</span>] = <span class="number">0x00f00000</span>;</span><br><span class="line">	helper[<span class="number">7</span>] = <span class="number">0x0f000000</span>;</span><br><span class="line">	helper[<span class="number">8</span>] = <span class="number">0xf0000000</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> res[<span class="number">9</span>];  <span class="comment">// 将提取出的数存入res数组中</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> tmp = num&amp;helper[i];   <span class="comment">// 将其余位全部值0，保留目标位 ⭐</span></span><br><span class="line">		tmp = tmp &gt;&gt; (i<span class="number">-1</span>)*<span class="number">4</span>;      <span class="comment">// 根据情况右移 </span></span><br><span class="line">		<span class="comment">// cout&lt;&lt;i&lt;&lt;&quot;:&quot; &lt;&lt;tmp&lt;&lt;endl;</span></span><br><span class="line">		res[i] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 打印 （按照小端存储的规则） </span></span><br><span class="line">	<span class="comment">// 32 位分成 4 组 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> idx_1 = i*<span class="number">2</span>;</span><br><span class="line">		<span class="type">int</span> idx_2 = idx_1 - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(res[idx_1]&lt;<span class="number">10</span>)&#123;</span><br><span class="line">			cout&lt;&lt;res[idx_1];</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(res[idx_1]==<span class="number">10</span>)cout&lt;&lt;<span class="string">&quot;A&quot;</span>;</span><br><span class="line">			<span class="keyword">if</span>(res[idx_1]==<span class="number">11</span>)cout&lt;&lt;<span class="string">&quot;B&quot;</span>;</span><br><span class="line">			<span class="keyword">if</span>(res[idx_1]==<span class="number">12</span>)cout&lt;&lt;<span class="string">&quot;C&quot;</span>;</span><br><span class="line">			<span class="keyword">if</span>(res[idx_1]==<span class="number">13</span>)cout&lt;&lt;<span class="string">&quot;D&quot;</span>;</span><br><span class="line">			<span class="keyword">if</span>(res[idx_1]==<span class="number">14</span>)cout&lt;&lt;<span class="string">&quot;E&quot;</span>;</span><br><span class="line">			<span class="keyword">if</span>(res[idx_1]==<span class="number">15</span>)cout&lt;&lt;<span class="string">&quot;F&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(res[idx_2]&lt;<span class="number">10</span>)&#123;</span><br><span class="line">			cout&lt;&lt;res[idx_2];</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(res[idx_2]==<span class="number">10</span>)cout&lt;&lt;<span class="string">&quot;A&quot;</span>;</span><br><span class="line">			<span class="keyword">if</span>(res[idx_2]==<span class="number">11</span>)cout&lt;&lt;<span class="string">&quot;B&quot;</span>;</span><br><span class="line">			<span class="keyword">if</span>(res[idx_2]==<span class="number">12</span>)cout&lt;&lt;<span class="string">&quot;C&quot;</span>;</span><br><span class="line">			<span class="keyword">if</span>(res[idx_2]==<span class="number">13</span>)cout&lt;&lt;<span class="string">&quot;D&quot;</span>;</span><br><span class="line">			<span class="keyword">if</span>(res[idx_2]==<span class="number">14</span>)cout&lt;&lt;<span class="string">&quot;E&quot;</span>;</span><br><span class="line">			<span class="keyword">if</span>(res[idx_2]==<span class="number">15</span>)cout&lt;&lt;<span class="string">&quot;F&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">4</span>)&#123;</span><br><span class="line">			cout&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><script src="/js/lightgallery.min.js"></script><script>
        if("undefined"!=typeof lightGallery) {
        var options1 = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('article-gallery')[0], options1);
        }
        </script>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2024-09-10</span>
            
                <span>该篇文章被 jay1an</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/'>
                            滑动窗口
                        </a>
                    
                        <a href='/tags/%E5%9B%BE/'>
                            图
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/%E5%88%B7%E9%A2%98/'>
                            刷题
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    <br>
    
    <!-- <div class="post-footer-pre-next">
        <span>上一篇：<a href=""></a></span>
        <span class="post-footer-pre-next-last-span-right">上一篇：<a href=""></a></span>
    </div> -->

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 1949-2024 China 

            
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>从头努力也坎坷</span>
            
    
</div>


    
<script src="/js/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="/js/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
        <script src="/js/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript"></script>
        <script src="/js/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript"></script>
        
<script src="/js/toc.js"></script>

    
    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery.min.js"></script>



                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>
</html>