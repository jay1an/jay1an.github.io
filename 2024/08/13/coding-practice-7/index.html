<!DOCTYPE html>
<html lang="en">
    
    <style>
        body
        {
            font-family: "Times New Roman", Helvetica, Tahoma, Arial,   LXGW WenKai   "notoserifsc-medium", "Microsoft YaHei", "Hiragino Sans GB", "WenQuanYi Micro Hei", sans-serif !important;

        }
    </style>

    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="刷题日记 - 7" />
    <meta name="hexo-theme-A4" content="v1.9.0" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title>Jay1an</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery.min.css">


<meta name="generator" content="Hexo 7.3.0"></head>
    
    <style>
        :root {
            --waline-theme-color: #323e74; 
            --waline-color: #323e74; 
            --waline-border-color: #323e74; 
            --waline-white: #323e74; 
            --waline-bgcolor-light: #f2fafc;  
        }
        body {
            color: #323e74;
            background: #eaeae8;
        }
        .post-md code {
            background: #e7f7f3;
            color: #7f688d; 
        }
        .post-md pre, .post-md .highlight {
            background: #e7f7f3;
            color: #7f688d; 
        }
        pre .string, pre .value, pre .inheritance, pre .header, pre .ruby .symbol, pre .xml .cdata {
            color: #323e74;
        }
        pre .number, pre .preprocessor, pre .built_in, pre .literal, pre .params, pre .constant {
            color: #323e74;
        }
        .year-font-color {
            color: #323e74 !important;
        }
        .wl-card span.wl-nick {
            color: #323e74; 
        }
        .wl-card .wl-badge {
            border: 1px solid #323e74;
            color: #323e74; 
        }
        .wl-btn {
            border: 1px solid #323e74; 
            color:  #323e74;  
        }
        .wl-btn.primary {
            color: #f2fafc; 
        }
        .wl-header label {
            color: #323e74;
        }
        a {
            color: #7f688d;
        }

        .post-md a {
            color: #7f688d;
        }

        .nav li a {
            color: #7f688d;
        }

        .archive-main a:link {
            color: #7f688d;
        }
        .archive-main a:visited {
            color: #767c7c; 
        }

        .archive li span {
            color: #323e74;
        }

        .post-main-title {
            color: #323e74;
        }

        .post-md h1,
        .post-md h2,
        .post-md h3,
        .post-md h4,
        .post-md h5,
        .post-md h6 {
            color: #323e74;
        }

        [data-waline] p {
            color: #323e74;
        }
        [data-waline] a {
            color: #323e74;
        } 
        .wl-sort li.active {
            color: #323e74;
        }

        .wl-card .wl-meta>span {
            background: #f2fafc;
        }

        .paper {
            background: #eaeae8;
        }

        .index-main {
            background: #f2fafc;
        }

        .paper-main {
            background: #f2fafc;
        }

        .wl-panel {
            background: #f2fafc;
        }

        .archive li:nth-child(odd) {
            background: #f2fafc;
            ;
        }

        .archive li:nth-child(even) {
            background: #f2fafc;
        }

        .post-md table tr:nth-child(odd) td {
            background: #f2fafc;
        }

        .post-md table tr:nth-child(even) td {
            background: #f2fafc;
        }

    
        .progress-wrap::after {
            color: #323e74; /* 箭头的颜色 */
        }
        .progress-wrap svg.progress-circle path {
	        stroke: #323e74; /* 边框的颜色 */
        }
        .progress-wrap::before {
	        background-image: linear-gradient(298deg, #7f688d, #7f688d); /* 鼠标滑过的箭头颜色 */
         }

        .return-to-last-progress-wrap::after {
            color: #323e74; /* 箭头的颜色 */
        }
        .return-to-last-progress-wrap svg.progress-circle path {
	        stroke: #323e74; /* 边框的颜色 */
        }
        .return-to-last-progress-wrap::before {
	        background-image: linear-gradient(298deg, #7f688d, #7f688d); /* 鼠标滑过的箭头颜色 */
         }

         .left-toc-container::-webkit-scrollbar-thumb {
            background-color: #323e74; /* 设置滚动条拖动块的颜色 */
        }

        .bs-docs-sidebar .nav>.active>a,
        .bs-docs-sidebar .nav>li>a:hover,
        .bs-docs-sidebar .nav>li>a:focus {
            color: #7f688d;
            border-left-color: #7f688d;
        }
        .bs-docs-sidebar .nav>li>a {
            color:  #323e74;
        }
    </style>

    
    
    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Jay1an</a> 
            <span class="description">I am who I am.</span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            刷题日记 - 7
        </div>
      
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0-7"><span class="post-toc-text">刷题日记 - 7</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#452-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">452. 用最少数量的箭引爆气球 - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#71-%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">71. 简化路径 - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">150. 逆波兰表达式求值 - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#224-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">224. 基本计算器 - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">141. 环形链表 - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">2. 两数相加 - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">21. 合并两个有序链表 - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#23-%E5%90%88%E5%B9%B6-K-%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">23. 合并 K 个升序链表 - 力扣（LeetCode）</span></a></li></ol></li></ol></li></ol>
            
        
        <link rel="stylesheet" type="text/css" href="/css/lightgallery.min.css" /><div class="article-gallery"><h1 id="刷题日记-7"><a href="#刷题日记-7" class="headerlink" title="刷题日记 - 7"></a>刷题日记 - 7</h1><p>记录刷题。</p>
<h3 id="452-用最少数量的箭引爆气球-力扣（LeetCode）"><a href="#452-用最少数量的箭引爆气球-力扣（LeetCode）" class="headerlink" title="452. 用最少数量的箭引爆气球 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/?envType=study-plan-v2&envId=top-interview-150">452. 用最少数量的箭引爆气球 - 力扣（LeetCode）</a></h3><p>难度：中等</p>
<p><strong>区间题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="comment">// 对气球按起点进行排序，使用Integer.compare避免溢出</span></span><br><span class="line">        Arrays.sort(points, (<span class="type">int</span>[] a, <span class="type">int</span>[] b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 至少需要一支箭</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> points.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> points[<span class="number">0</span>][<span class="number">0</span>]; <span class="comment">// 当前区间的左边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> points[<span class="number">0</span>][<span class="number">1</span>]; <span class="comment">// 当前区间的右边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 指向下一个气球</span></span><br><span class="line">        <span class="keyword">while</span> (p &lt; len) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curLeft</span> <span class="operator">=</span> points[p][<span class="number">0</span>]; <span class="comment">// 当前气球的左边界</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">curRight</span> <span class="operator">=</span> points[p][<span class="number">1</span>]; <span class="comment">// 当前气球的右边界</span></span><br><span class="line">            <span class="comment">// 如果当前气球的左边界大于当前区间的右边界，说明需要一支新箭</span></span><br><span class="line">            <span class="keyword">if</span> (curLeft &gt; right) &#123;</span><br><span class="line">                res++; <span class="comment">// 新增一支箭</span></span><br><span class="line">                left = curLeft; <span class="comment">// 更新当前区间的左边界</span></span><br><span class="line">                right = curRight; <span class="comment">// 更新当前区间的右边界</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 更新当前区间的右边界为重叠部分的最小右边界⭐ </span></span><br><span class="line">                left = curLeft;</span><br><span class="line">                right = Math.min(curRight, right);</span><br><span class="line">            &#125;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 返回所需的箭数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>区间排序</strong>：便于后续处理。</p>
<p><strong>区间合并</strong>：需要判断各个区间的并集，更新<code>left right</code>为并集的范围。如果下一个区间与该并集没有重合，表明扎暴后面的气球至少还需要一根针，所以将<code>res++</code>。由于没有并集，所以更新<code>left right</code>为<code>curLeft curRight</code>，再重复上面的操作。</p>
<p>返回的所需要的最少的弓箭数，就是尽可能多地找到哪些涉及区间多的并集。</p>
<h3 id="71-简化路径-力扣（LeetCode）"><a href="#71-简化路径-力扣（LeetCode）" class="headerlink" title="71. 简化路径 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/simplify-path/description/?envType=study-plan-v2&envId=top-interview-150">71. 简化路径 - 力扣（LeetCode）</a></h3><p>难度：中等</p>
<p><strong>栈</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">simplifyPath</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        <span class="comment">// 将路径按照 &quot;/&quot; 分割成目录数组</span></span><br><span class="line">        String[] dirs = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用双端队列来处理目录的添加和删除</span></span><br><span class="line">        Deque&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从第二个元素开始遍历（第一个元素是空字符串，因为路径以 &quot;/&quot; 开头）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; dirs.length; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">dir</span> <span class="operator">=</span> dirs[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果遇到 &quot;..&quot; 说明要返回上一级目录</span></span><br><span class="line">            <span class="keyword">if</span> (dir.equals(<span class="string">&quot;..&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 如果队列不为空，则移除最后一个元素，表示返回上一级</span></span><br><span class="line">                <span class="keyword">if</span> (!list.isEmpty()) &#123;</span><br><span class="line">                    list.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// 如果遇到 &quot;.&quot; 或空字符串则忽略</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(dir.equals(<span class="string">&quot;.&quot;</span>) || dir.length() == <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="comment">// 否则将当前目录添加到队列的末尾</span></span><br><span class="line">                list.offerLast(dir);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建简化后的路径</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (!list.isEmpty()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">dir</span> <span class="operator">=</span> list.pollFirst(); <span class="comment">// 从队列的前端取出元素</span></span><br><span class="line">            sb.append(<span class="string">&quot;/&quot;</span>);                <span class="comment">// 添加路径分隔符 &quot;/&quot;</span></span><br><span class="line">            sb.append(dir);                <span class="comment">// 添加目录名</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果简化后的路径为空，则返回根路径 &quot;/&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (sb.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;/&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString(); <span class="comment">// 返回最终简化后的路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了双端队列<code>Deque</code>，便于最后将值依次取出。</p>
<h3 id="150-逆波兰表达式求值-力扣（LeetCode）"><a href="#150-逆波兰表达式求值-力扣（LeetCode）" class="headerlink" title="150. 逆波兰表达式求值 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/?envType=study-plan-v2&envId=top-interview-150">150. 逆波兰表达式求值 - 力扣（LeetCode）</a></h3><p>难度：中等</p>
<p><strong>栈</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用栈来保存操作数</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历输入的每一个令牌</span></span><br><span class="line">        <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">            <span class="comment">// 如果令牌是加法操作符</span></span><br><span class="line">            <span class="keyword">if</span> (token.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 弹出两个操作数，进行加法运算，并将结果压入栈中</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">opNum1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">opNum2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> opNum1 + opNum2;</span><br><span class="line">                stack.push(res);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果令牌是减法操作符</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (token.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 弹出两个操作数，进行减法运算，并将结果压入栈中</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">opNum1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">opNum2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> opNum2 - opNum1; <span class="comment">// 注意减法顺序</span></span><br><span class="line">                stack.push(res);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果令牌是乘法操作符</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (token.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 弹出两个操作数，进行乘法运算，并将结果压入栈中</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">opNum1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">opNum2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> opNum1 * opNum2;</span><br><span class="line">                stack.push(res);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果令牌是除法操作符</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (token.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 弹出两个操作数，进行除法运算，并将结果压入栈中</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">opNum1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">opNum2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> opNum2 / opNum1; <span class="comment">// 注意除法顺序</span></span><br><span class="line">                stack.push(res);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果令牌是数字</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将数字转换为整数并压入栈中</span></span><br><span class="line">                stack.push(Integer.parseInt(token));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回栈顶元素，即最终计算结果</span></span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>逆波兰表达式的理解</strong>，将操作符放在操作数之后，并通过栈来保存和处理操作数。</p>
<p>注意除法和减法的操作数顺序：<code>opNum2 - opNum1</code> 和 <code>opNum2 / opNum1</code> </p>
<h3 id="224-基本计算器-力扣（LeetCode）"><a href="#224-基本计算器-力扣（LeetCode）" class="headerlink" title="224. 基本计算器 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/basic-calculator/description/?envType=study-plan-v2&envId=top-interview-150">224. 基本计算器 - 力扣（LeetCode）</a></h3><p>难度：困难</p>
<p><strong>栈</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] sChars = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">INIT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">HAVE_ONE_NUM</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">HAVE_OP</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> INIT;</span><br><span class="line">        Stack&lt;Character&gt;  chStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; numStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p&lt;len)&#123;</span><br><span class="line">            <span class="comment">// 如果当前字符是空，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span>(sChars[p]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p&gt;=len)<span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 如果当前字符是数字，则进入数字逻辑</span></span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(sChars[p]))&#123;</span><br><span class="line">                <span class="type">int</span>[] tmp = findNextInt(sChars,p);  <span class="comment">// 根据自定义函数找出，从当前位置开始的整数</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">curNum</span> <span class="operator">=</span> tmp[<span class="number">0</span>];</span><br><span class="line">                p = tmp[<span class="number">1</span>];                         <span class="comment">// 更新p指针到当前整数的下一个位置</span></span><br><span class="line">                <span class="keyword">if</span>(state==INIT)&#123;                    <span class="comment">// 如果当前状态为 INIT，表示这是这次运算的第一个整数</span></span><br><span class="line">                    numStack.push(curNum);          <span class="comment">// 将其加入numStack</span></span><br><span class="line">                    state = HAVE_ONE_NUM;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(state==HAVE_OP)&#123;           <span class="comment">// 如果当前状态为 HAVE_OP，表示这次运算已经具备了第一个整数和符号</span></span><br><span class="line">                    <span class="type">char</span> <span class="variable">op</span> <span class="operator">=</span> chStack.pop();        <span class="comment">// 则取出运算符号，取出第一个整数，进行运算，然后将结果加入numStack</span></span><br><span class="line">                    <span class="keyword">if</span>(op==<span class="string">&#x27;+&#x27;</span>)&#123;                    <span class="comment">// 并且最后还将state置为 HAVE_ONE_NUM，表示已经有一个整数迎接下一次运算</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> numStack.pop()+curNum;</span><br><span class="line">                        numStack.push(res);</span><br><span class="line">                        state = HAVE_ONE_NUM;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> numStack.pop() - curNum;</span><br><span class="line">                        numStack.push(res);</span><br><span class="line">                        state = HAVE_ONE_NUM;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sChars[p]==<span class="string">&#x27;+&#x27;</span>||sChars[p]==<span class="string">&#x27;-&#x27;</span>)&#123;  <span class="comment">// 如果当前的位置是运算符，看当前的状态</span></span><br><span class="line">                <span class="keyword">if</span>(state==HAVE_ONE_NUM)&#123;               <span class="comment">// 如果当前状态为 HAVE_ONE_NUM</span></span><br><span class="line">                    chStack.push(sChars[p]);           <span class="comment">// 加上当前的运算符，则可以进化到下一个状态： HAVE_OP</span></span><br><span class="line">                    state = HAVE_OP;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(state == INIT)&#123;                 <span class="comment">// 如果当前状态为 INIT</span></span><br><span class="line">                                                         <span class="comment">// 由题意可知，这个运算符一定为&#x27;-&#x27;</span></span><br><span class="line">                    numStack.push(<span class="number">0</span>);               <span class="comment">// 而这个-号就是用作符号的用处</span></span><br><span class="line">                    chStack.push(<span class="string">&#x27;-&#x27;</span>);              <span class="comment">// 所以这里在这里手动营造出 （0 - 下一个数）的状态</span></span><br><span class="line">                    state = HAVE_OP;                     <span class="comment">// 所以往numStack中添加0，并且将状态改为 HAVE_OP</span></span><br><span class="line">                &#125;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sChars[p]==<span class="string">&#x27;(&#x27;</span>)&#123;                  <span class="comment">// 当前位置是 &#x27;(&#x27; 状态更新为INIT，表明寻找下一轮运算</span></span><br><span class="line">                state = INIT;</span><br><span class="line">                chStack.push(sChars[p]);</span><br><span class="line">                p++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sChars[p]==<span class="string">&#x27;)&#x27;</span>)&#123;                  <span class="comment">// &#x27;)&#x27;这一轮括号已经算完了，去掉&#x27;(&#x27;</span></span><br><span class="line">                <span class="keyword">while</span>(p&lt;len&amp;&amp;(sChars[p]==<span class="string">&#x27;)&#x27;</span>&amp;&amp;chStack.peek()==<span class="string">&#x27;(&#x27;</span>))&#123;</span><br><span class="line">                    chStack.pop();</span><br><span class="line">                    p++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(numStack.size()&gt;=<span class="number">2</span>)&#123;             <span class="comment">// 如果numStack中还有两个数或者以上的数</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">opNum1</span> <span class="operator">=</span> numStack.pop();    <span class="comment">// 表明此时需要运算</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">opNum2</span> <span class="operator">=</span> numStack.pop();    <span class="comment">// 这里进行运算</span></span><br><span class="line">                    <span class="type">char</span> <span class="variable">op</span> <span class="operator">=</span> chStack.pop();</span><br><span class="line">                    <span class="keyword">if</span>(op==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                        numStack.push(opNum1+opNum2);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                        numStack.push(opNum2-opNum1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                state = HAVE_ONE_NUM;              <span class="comment">// 状态置为 HAVE_ONE_NUM</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p所指当前是digit</span></span><br><span class="line">    <span class="comment">// 返回数组第一个值是该数字，第二个值是数字的下一个字符的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] findNextInt(<span class="type">char</span>[] sChars,<span class="type">int</span> p)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> sChars.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p&lt;len&amp;&amp;Character.isDigit(sChars[p]))&#123;</span><br><span class="line">            curNum = curNum*<span class="number">10</span> + (sChars[p] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        res[<span class="number">0</span>] = curNum;</span><br><span class="line">        res[<span class="number">1</span>] = p;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能用<strong>状态机</strong>做主要是因为只有<code>+</code>和<code>-</code>，根据当前的字符和当前的状态进行状态转移：</p>
<p>一个很草的图：</p>
<p><a href="/../img/coding-practice-7/image-20240809165158807.png" title="image-20240809165158807" class="gallery-item" style="box-shadow: none;"> <img src="/../img/coding-practice-7/image-20240809165158807.png" alt="image-20240809165158807"></a></p>
<h3 id="141-环形链表-力扣（LeetCode）"><a href="#141-环形链表-力扣（LeetCode）" class="headerlink" title="141. 环形链表 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/?envType=study-plan-v2&envId=top-interview-150">141. 环形链表 - 力扣（LeetCode）</a></h3><p>难度：简单</p>
<p><strong>链表 快慢指针</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单链表的节点定义。</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义两个指针，快指针和慢指针，初始都指向链表的头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 定义一个布尔值，初始为false，用来表示是否存在环</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始循环，直到快指针为null</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 快指针每次走两步</span></span><br><span class="line">            fast = fast.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">null</span>) <span class="keyword">break</span>; <span class="comment">// 如果快指针到达链表末尾，跳出循环</span></span><br><span class="line">            fast = fast.next;</span><br><span class="line">            <span class="comment">// 慢指针每次走一步</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="comment">// 如果快指针和慢指针相遇，说明链表中存在环</span></span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                res = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 找到环后跳出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回是否存在环</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以利用哈希表来做，用一个指针遍历所有节点，利用哈希表来判断当前节点是否已经访问过（是否有环）。</p>
<p>但是哈希表法空间复杂度太高，最坏情况下要将所有的节点都加入哈希表中。</p>
<p>所以更好还是采用快慢指针的做法，如果有环，则快慢指针必定会相遇。</p>
<h3 id="2-两数相加-力扣（LeetCode）"><a href="#2-两数相加-力扣（LeetCode）" class="headerlink" title="2. 两数相加 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-two-numbers/?envType=study-plan-v2&envId=top-interview-150">2. 两数相加 - 力扣（LeetCode）</a></h3><p>难度：中等</p>
<p><strong>链表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单链表的节点定义。</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义指针p指向链表l1，q指向链表l2</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> l1;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">q</span> <span class="operator">=</span> l2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个哑节点dummy，最后返回dummy.next作为结果链表的头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">t</span> <span class="operator">=</span> dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// carry表示进位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当p和q都不为null时，逐位相加</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">null</span> &amp;&amp; q != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> p.val + q.val + carry; <span class="comment">// 计算当前位的和</span></span><br><span class="line">            carry = (val &gt;= <span class="number">10</span>) ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 判断是否有进位</span></span><br><span class="line">            val = (val &gt;= <span class="number">10</span>) ? val % <span class="number">10</span> : val; <span class="comment">// 如果和大于等于10，取个位数</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val); <span class="comment">// 创建新节点存储计算结果</span></span><br><span class="line">            t.next = tmp; <span class="comment">// 将新节点链接到结果链表</span></span><br><span class="line">            t = t.next; <span class="comment">// 移动t指针</span></span><br><span class="line">            p = p.next; <span class="comment">// p指针后移</span></span><br><span class="line">            q = q.next; <span class="comment">// q指针后移</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断哪个链表还有剩余节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">remainNode</span> <span class="operator">=</span> (p == <span class="literal">null</span>) ? q : p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将剩余节点逐位相加</span></span><br><span class="line">        <span class="keyword">while</span>(remainNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> carry + remainNode.val; <span class="comment">// 加上可能的进位</span></span><br><span class="line">            carry = (val &gt;= <span class="number">10</span>) ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 判断是否有进位</span></span><br><span class="line">            val = (val &gt;= <span class="number">10</span>) ? val % <span class="number">10</span> : val; <span class="comment">// 取个位数</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val); <span class="comment">// 创建新节点存储计算结果</span></span><br><span class="line">            t.next = tmp; <span class="comment">// 将新节点链接到结果链表</span></span><br><span class="line">            t = t.next; <span class="comment">// 移动t指针</span></span><br><span class="line">            remainNode = remainNode.next; <span class="comment">// 移动剩余链表的指针</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果最后还有进位，增加一个新节点</span></span><br><span class="line">        <span class="keyword">if</span>(carry != <span class="number">0</span>)&#123;</span><br><span class="line">            t.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回结果链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要注意四个点：<strong>使用dummy节点简化处理 处理进位问题 处理不同长度的链表 处理最后的进位</strong></p>
<h3 id="21-合并两个有序链表-力扣（LeetCode）"><a href="#21-合并两个有序链表-力扣（LeetCode）" class="headerlink" title="21. 合并两个有序链表 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/description/?envType=study-plan-v2&envId=top-interview-150">21. 合并两个有序链表 - 力扣（LeetCode）</a></h3><p>难度：简单</p>
<p><strong>链表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义指针p指向list1，q指向list2</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> list1;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">q</span> <span class="operator">=</span> list2;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个哑节点dummy，最后返回dummy.next作为结果链表的头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">t</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当p和q都不为null时，比较它们的值，将较小的节点链接到结果链表</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">null</span> &amp;&amp; q != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.val &gt;= q.val)&#123;</span><br><span class="line">                t.next = q;  <span class="comment">// 将q节点链接到结果链表</span></span><br><span class="line">                t = t.next;  <span class="comment">// 移动t指针</span></span><br><span class="line">                q = q.next;  <span class="comment">// q指针后移</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t.next = p;  <span class="comment">// 将p节点链接到结果链表</span></span><br><span class="line">                t = t.next;  <span class="comment">// 移动t指针</span></span><br><span class="line">                p = p.next;  <span class="comment">// p指针后移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果p或q还有剩余节点，直接链接到结果链表的末尾</span></span><br><span class="line">        t.next = (p == <span class="literal">null</span>) ? q : p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回结果链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-合并-K-个升序链表-力扣（LeetCode）"><a href="#23-合并-K-个升序链表-力扣（LeetCode）" class="headerlink" title="23. 合并 K 个升序链表 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists/description/">23. 合并 K 个升序链表 - 力扣（LeetCode）</a></h3><p>难度：困难</p>
<p><strong>链表 最小堆</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个优先队列（最小堆），根据节点值进行排序</span></span><br><span class="line">        PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">            (ListNode a, ListNode b) -&gt; (a.val - b.val)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将每个链表的头节点加入优先队列</span></span><br><span class="line">        <span class="keyword">for</span>(ListNode head : lists)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">continue</span>; <span class="comment">// 跳过空链表</span></span><br><span class="line">            pq.offer(head);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个哑节点dummy，用来构建最终合并的链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">t</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理优先队列中的节点，直到队列为空</span></span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            t.next = pq.poll(); <span class="comment">// 取出队列中最小值的节点并链接到结果链表</span></span><br><span class="line">            t = t.next; <span class="comment">// 移动指针t到新加入的节点</span></span><br><span class="line">            <span class="keyword">if</span>(t.next == <span class="literal">null</span>) <span class="keyword">continue</span>; <span class="comment">// 如果当前节点没有后续节点，继续循环</span></span><br><span class="line">            pq.offer(t.next); <span class="comment">// 将当前节点的下一个节点加入优先队列</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回合并后的链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以利用第21题，可以将K个升序链表两两合并。</p>
<p><strong>但是最优解是利用最小堆数据结构，每次从堆中取出值最小的节点。</strong></p>
</div><script src="/js/lightgallery.min.js"></script><script>
        if("undefined"!=typeof lightGallery) {
        var options1 = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('article-gallery')[0], options1);
        }
        </script>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2024-08-13</span>
            
                <span>该篇文章被 jay1an</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/%E6%A0%88/'>
                            栈
                        </a>
                    
                        <a href='/tags/%E9%93%BE%E8%A1%A8/'>
                            链表
                        </a>
                    
                        <a href='/tags/%E5%8C%BA%E9%97%B4/'>
                            区间
                        </a>
                    
                        <a href='/tags/%E6%9C%80%E5%B0%8F%E5%A0%86/'>
                            最小堆
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/%E5%88%B7%E9%A2%98/'>
                            刷题
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    <br>
    
    <!-- <div class="post-footer-pre-next">
        <span>上一篇：<a href=""></a></span>
        <span class="post-footer-pre-next-last-span-right">上一篇：<a href=""></a></span>
    </div> -->

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 1949-2024 China 

            
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>从头努力也坎坷</span>
            
    
</div>


    
<script src="/js/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="/js/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
        <script src="/js/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript"></script>
        <script src="/js/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript"></script>
        
<script src="/js/toc.js"></script>

    
    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery.min.js"></script>



                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>
</html>