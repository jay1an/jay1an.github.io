<!DOCTYPE html>
<html lang="en">
    
    <style>
        body
        {
            font-family: "Times New Roman", Helvetica, Tahoma, Arial,   LXGW WenKai   "notoserifsc-medium", "Microsoft YaHei", "Hiragino Sans GB", "WenQuanYi Micro Hei", sans-serif !important;

        }
    </style>

    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="刷题日记 - 10" />
    <meta name="hexo-theme-A4" content="v1.9.0" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title>Jay1an</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery.min.css">


<meta name="generator" content="Hexo 7.3.0"></head>
    
    <style>
        :root {
            --waline-theme-color: #323e74; 
            --waline-color: #323e74; 
            --waline-border-color: #323e74; 
            --waline-white: #323e74; 
            --waline-bgcolor-light: #f2fafc;  
        }
        body {
            color: #323e74;
            background: #eaeae8;
        }
        .post-md code {
            background: #e7f7f3;
            color: #7f688d; 
        }
        .post-md pre, .post-md .highlight {
            background: #e7f7f3;
            color: #7f688d; 
        }
        pre .string, pre .value, pre .inheritance, pre .header, pre .ruby .symbol, pre .xml .cdata {
            color: #323e74;
        }
        pre .number, pre .preprocessor, pre .built_in, pre .literal, pre .params, pre .constant {
            color: #323e74;
        }
        .year-font-color {
            color: #323e74 !important;
        }
        .wl-card span.wl-nick {
            color: #323e74; 
        }
        .wl-card .wl-badge {
            border: 1px solid #323e74;
            color: #323e74; 
        }
        .wl-btn {
            border: 1px solid #323e74; 
            color:  #323e74;  
        }
        .wl-btn.primary {
            color: #f2fafc; 
        }
        .wl-header label {
            color: #323e74;
        }
        a {
            color: #7f688d;
        }

        .post-md a {
            color: #7f688d;
        }

        .nav li a {
            color: #7f688d;
        }

        .archive-main a:link {
            color: #7f688d;
        }
        .archive-main a:visited {
            color: #767c7c; 
        }

        .archive li span {
            color: #323e74;
        }

        .post-main-title {
            color: #323e74;
        }

        .post-md h1,
        .post-md h2,
        .post-md h3,
        .post-md h4,
        .post-md h5,
        .post-md h6 {
            color: #323e74;
        }

        [data-waline] p {
            color: #323e74;
        }
        [data-waline] a {
            color: #323e74;
        } 
        .wl-sort li.active {
            color: #323e74;
        }

        .wl-card .wl-meta>span {
            background: #f2fafc;
        }

        .paper {
            background: #eaeae8;
        }

        .index-main {
            background: #f2fafc;
        }

        .paper-main {
            background: #f2fafc;
        }

        .wl-panel {
            background: #f2fafc;
        }

        .archive li:nth-child(odd) {
            background: #f2fafc;
            ;
        }

        .archive li:nth-child(even) {
            background: #f2fafc;
        }

        .post-md table tr:nth-child(odd) td {
            background: #f2fafc;
        }

        .post-md table tr:nth-child(even) td {
            background: #f2fafc;
        }

    
        .progress-wrap::after {
            color: #323e74; /* 箭头的颜色 */
        }
        .progress-wrap svg.progress-circle path {
	        stroke: #323e74; /* 边框的颜色 */
        }
        .progress-wrap::before {
	        background-image: linear-gradient(298deg, #7f688d, #7f688d); /* 鼠标滑过的箭头颜色 */
         }

        .return-to-last-progress-wrap::after {
            color: #323e74; /* 箭头的颜色 */
        }
        .return-to-last-progress-wrap svg.progress-circle path {
	        stroke: #323e74; /* 边框的颜色 */
        }
        .return-to-last-progress-wrap::before {
	        background-image: linear-gradient(298deg, #7f688d, #7f688d); /* 鼠标滑过的箭头颜色 */
         }

         .left-toc-container::-webkit-scrollbar-thumb {
            background-color: #323e74; /* 设置滚动条拖动块的颜色 */
        }

        .bs-docs-sidebar .nav>.active>a,
        .bs-docs-sidebar .nav>li>a:hover,
        .bs-docs-sidebar .nav>li>a:focus {
            color: #7f688d;
            border-left-color: #7f688d;
        }
        .bs-docs-sidebar .nav>li>a {
            color:  #323e74;
        }
    </style>

    
    
    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Jay1an</a> 
            <span class="description">I am who I am.</span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            刷题日记 - 10
        </div>
      
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0-10"><span class="post-toc-text">刷题日记 - 10</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#146-LRU-%E7%BC%93%E5%AD%98-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">146. LRU 缓存 - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">148. 排序链表 - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">100. 相同的树 - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#117-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-II-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">117. 填充每个节点的下一个右侧节点指针 II - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">114. 二叉树展开为链表 - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">112. 路径总和 - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#129-%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">129. 求根节点到叶节点数字之和 - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">124. 二叉树中的最大路径和 - 力扣（LeetCode）</span></a></li></ol></li></ol></li></ol>
            
        
        <link rel="stylesheet" type="text/css" href="/css/lightgallery.min.css" /><div class="article-gallery"><h1 id="刷题日记-10"><a href="#刷题日记-10" class="headerlink" title="刷题日记 - 10"></a>刷题日记 - 10</h1><h3 id="146-LRU-缓存-力扣（LeetCode）"><a href="#146-LRU-缓存-力扣（LeetCode）" class="headerlink" title="146. LRU 缓存 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lru-cache/description/?envType=study-plan-v2&envId=top-interview-150">146. LRU 缓存 - 力扣（LeetCode）</a></h3><p>难度：中等</p>
<p><strong>链表 哈希表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个HashMap来存储键值对，键是Integer类型，值是双向链表节点BiNode</span></span><br><span class="line">    HashMap&lt;Integer, BiNode&gt; map;</span><br><span class="line">    <span class="comment">// 定义头节点head和尾节点tail，指向链表的头和尾</span></span><br><span class="line">    BiNode head, tail;</span><br><span class="line">    <span class="comment">// 当前缓存的节点数量</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">// 缓存的容量</span></span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，初始化缓存的容量和内部数据结构</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="comment">// 初始化头节点和尾节点，头节点和尾节点不存储实际数据</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">BiNode</span>(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">BiNode</span>(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 头尾相连，形成一个空的双向链表</span></span><br><span class="line">        head.right = tail;</span><br><span class="line">        tail.left = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// get方法，获取指定key对应的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果map中包含key</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            <span class="type">BiNode</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key); <span class="comment">// 获取该节点</span></span><br><span class="line">            res = node.val; <span class="comment">// 获取节点的值</span></span><br><span class="line">            moveToFront(node); <span class="comment">// 将该节点移动到链表的头部，表示最近使用</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// put方法，插入或更新一个key-value对</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">BiNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 如果map中已经包含该key</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            node = map.get(key); <span class="comment">// 获取节点</span></span><br><span class="line">            node.val = value; <span class="comment">// 更新节点的值</span></span><br><span class="line">            moveToFront(node); <span class="comment">// 将节点移动到链表的头部</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">// 如果当前缓存容量超过了设定容量</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; capacity) &#123;</span><br><span class="line">                removeLastNode(); <span class="comment">// 移除链表尾部节点，即最久未使用的节点</span></span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 新建一个节点</span></span><br><span class="line">            node = <span class="keyword">new</span> <span class="title class_">BiNode</span>(key, value);</span><br><span class="line">            map.put(key, node); <span class="comment">// 将节点添加到map中</span></span><br><span class="line">            <span class="comment">// 将节点插入到头部</span></span><br><span class="line">            node.left = head;</span><br><span class="line">            node.right = head.right;</span><br><span class="line">            head.right.left = node;</span><br><span class="line">            head.right = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将已有的节点移动到链表的头部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToFront</span><span class="params">(BiNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.left != head) &#123;</span><br><span class="line">            <span class="comment">// 从链表中取出节点</span></span><br><span class="line">            node.left.right = node.right;</span><br><span class="line">            node.right.left = node.left;</span><br><span class="line">            <span class="comment">// 将节点插入到链表头部</span></span><br><span class="line">            node.right = head.right;</span><br><span class="line">            head.right.left = node;</span><br><span class="line">            head.right = node;</span><br><span class="line">            node.left = head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除链表尾部节点，即最久未使用的节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeLastNode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> tail.left.key;</span><br><span class="line">        tail.left.left.right = tail;</span><br><span class="line">        tail.left = tail.left.left;</span><br><span class="line">        map.remove(key); <span class="comment">// 从map中删除该节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义双向链表节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BiNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    BiNode left;</span><br><span class="line">    BiNode right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，初始化节点的key和val</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BiNode</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度O(1)的get</strong>：采用<strong>哈希表</strong>。</li>
<li><strong>实现LRU</strong>：每次取出数据都要更新使用情况，用<strong>双向链表</strong>来模拟，每次使用都将对应节点取出并移动到头部。</li>
</ul>
<p>选择了合适的数据结构，然后根据LRU逻辑实现get和put的代码即可。</p>
<h3 id="148-排序链表-力扣（LeetCode）"><a href="#148-排序链表-力扣（LeetCode）" class="headerlink" title="148. 排序链表 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-list/description/">148. 排序链表 - 力扣（LeetCode）</a></h3><p>难度：中等</p>
<p><strong>链表 归并排序(递归)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主函数：排序链表</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果链表为空，直接返回null</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 调用归并排序函数，传入头节点和尾节点</span></span><br><span class="line">        <span class="keyword">return</span> merge(head, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归并排序函数</span></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode head, ListNode tail)</span> &#123;</span><br><span class="line">        <span class="comment">// 当头节点的下一个节点就是tail时，直接返回头节点，并将头节点的next置为null（这样不会丢失节点，因为递归的时候mid在左边做了一回tail节点，但是在右边不会作为tail节点）</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == tail) &#123;</span><br><span class="line">            head.next = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 快慢指针找到链表中点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != tail) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == tail) <span class="keyword">break</span>;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> slow; <span class="comment">// slow指针即为链表中点</span></span><br><span class="line">        <span class="comment">// 递归地对左右两部分进行排序</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> merge(head, mid);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> merge(mid, tail);</span><br><span class="line">        <span class="comment">// 合并已排序的两个子链表</span></span><br><span class="line">        <span class="keyword">return</span> mergeSortedList(node1, node2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个有序链表</span></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">mergeSortedList</span><span class="params">(ListNode head1, ListNode head2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>); </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">t</span> <span class="operator">=</span> dummy, p = head1, q = head2;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; q != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.val &lt;= q.val) &#123;</span><br><span class="line">                t.next = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                t = t.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t.next = q;</span><br><span class="line">                q = q.next;</span><br><span class="line">                t = t.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t.next = (p == <span class="literal">null</span>) ? q : p;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>难点：</p>
<ul>
<li><strong>链表的分割和递归处理</strong>：快慢指针寻找中点，分为两个部分。（<code>mid</code>节点既作为左边链表的尾部又作为右边部分的头部）</li>
<li><strong>递归的合并操作</strong>：通过递归地将链表分割直至每部分只剩下一个节点，然后逐层合并成有序链表。</li>
</ul>
<h3 id="100-相同的树-力扣（LeetCode）"><a href="#100-相同的树-力扣（LeetCode）" class="headerlink" title="100. 相同的树 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/same-tree/description/?envType=study-plan-v2&envId=top-interview-150">100. 相同的树 - 力扣（LeetCode）</a></h3><p>难度：简单</p>
<p><strong>二叉树</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(p,q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode p,TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">null</span>&amp;&amp;q==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>((q!=<span class="literal">null</span>&amp;&amp;p!=<span class="literal">null</span>)&amp;&amp;q.val==p.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span> &amp;&amp; dfs(p.left,q.left) &amp;&amp; dfs(p.right,q.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归判断子树是否相同。</p>
<h3 id="117-填充每个节点的下一个右侧节点指针-II-力扣（LeetCode）"><a href="#117-填充每个节点的下一个右侧节点指针-II-力扣（LeetCode）" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/?envType=study-plan-v2&envId=top-interview-150">117. 填充每个节点的下一个右侧节点指针 II - 力扣（LeetCode）</a></h3><p>难度：中等</p>
<p><strong>二叉树 层序遍历</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果树为空，直接返回null ⭐ 一定要处理这个特殊情况，不然会死循环。</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用队列进行层次遍历</span></span><br><span class="line">        LinkedList&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offerLast(root); <span class="comment">// 将根节点加入队列</span></span><br><span class="line">        queue.offerLast(<span class="literal">null</span>); <span class="comment">// 使用null作为每一层的结束标志</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 上一个处理的节点，用于连接next指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> queue.pollFirst(); <span class="comment">// 取出队首节点</span></span><br><span class="line">            <span class="keyword">if</span> (last != <span class="literal">null</span>) &#123;</span><br><span class="line">                last.next = cur; <span class="comment">// 将上一个节点的next指向当前节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            last = cur; <span class="comment">// 更新last为当前节点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果当前节点有左子节点，将其加入队列</span></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) queue.addLast(cur.left);</span><br><span class="line">                <span class="comment">// 如果当前节点有右子节点，将其加入队列</span></span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) queue.addLast(cur.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果当前节点为null，表示当前层结束</span></span><br><span class="line">                <span class="keyword">if</span> (queue.isEmpty()) <span class="keyword">break</span>; <span class="comment">// 如果队列空了，说明遍历完成</span></span><br><span class="line">                queue.addLast(<span class="literal">null</span>); <span class="comment">// 继续标记下一层的结束</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root; <span class="comment">// 返回根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题要求将二叉树节点的next指针指向同层右边的第一个节点。</p>
<p>其实就是利用二叉树的<strong>层序遍历</strong>，简单。</p>
<h3 id="114-二叉树展开为链表-力扣（LeetCode）"><a href="#114-二叉树展开为链表-力扣（LeetCode）" class="headerlink" title="114. 二叉树展开为链表 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/?envType=study-plan-v2&envId=top-interview-150">114. 二叉树展开为链表 - 力扣（LeetCode）</a></h3><p>难度：中等</p>
<p><strong>二叉树 链表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果根节点为空，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义指针p，指向当前节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">q</span> <span class="operator">=</span> <span class="literal">null</span>;  <span class="comment">// q用来找到左子树的最右节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历树(右孩子)，直到所有节点都处理完</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前节点有左子树</span></span><br><span class="line">            <span class="keyword">if</span> (p.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 找到左子树的最右节点</span></span><br><span class="line">                q = p.left;</span><br><span class="line">                <span class="keyword">while</span> (q.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q = q.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将当前节点的右子树接到左子树的最右节点的右孩子上</span></span><br><span class="line">                q.right = p.right;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将当前节点的左子树移到右子树位置</span></span><br><span class="line">                p.right = p.left;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将当前节点的左子树置空</span></span><br><span class="line">                p.left = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 继续处理右子树</span></span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要理解二叉树展平成链表的过程：</p>
<p>将左子树接到右孩子，原右孩子接原左子树的最右孩子。用代码实现这一逻辑即可。</p>
<h3 id="112-路径总和-力扣（LeetCode）"><a href="#112-路径总和-力扣（LeetCode）" class="headerlink" title="112. 路径总和 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/?envType=study-plan-v2&envId=top-interview-150">112. 路径总和 - 力扣（LeetCode）</a></h3><p>难度：简单</p>
<p><strong>二叉树 dfs</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果根节点为空，直接返回false，因为没有路径</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用深度优先搜索（DFS）来查找是否存在满足条件的路径</span></span><br><span class="line">        <span class="keyword">return</span> dfs(root, targetSum, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深度优先搜索方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode node, <span class="type">int</span> targetSum, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="comment">// 当前节点的值累加到sum中</span></span><br><span class="line">        sum += node.val;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前节点是叶子节点，并且累加和等于目标和，则返回true</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; sum == targetSum) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果有左子节点但没有右子节点，递归搜索左子树</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) <span class="keyword">return</span> dfs(node.left, targetSum, sum);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果有右子节点但没有左子节点，递归搜索右子树</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right != <span class="literal">null</span>) <span class="keyword">return</span> dfs(node.right, targetSum, sum);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果同时有左子节点和右子节点，递归搜索左子树和右子树，只要有一个满足条件即返回true</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span> &amp;&amp; node.right != <span class="literal">null</span>) <span class="keyword">return</span> dfs(node.left, targetSum, sum) || dfs(node.right, targetSum, sum);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果以上条件都不满足，返回false（通常不会执行到这里）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用dfs计算每一条可能的路径和。</p>
<h3 id="129-求根节点到叶节点数字之和-力扣（LeetCode）"><a href="#129-求根节点到叶节点数字之和-力扣（LeetCode）" class="headerlink" title="129. 求根节点到叶节点数字之和 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/?envType=study-plan-v2&envId=top-interview-150">129. 求根节点到叶节点数字之和 - 力扣（LeetCode）</a></h3><p>难度：中等</p>
<p><strong>二叉树 dfs</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 用于存储从根到叶子节点路径所代表的所有数字</span></span><br><span class="line">    List&lt;Integer&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用深度优先搜索遍历树，并计算路径代表的数字</span></span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将所有路径表示的数字相加，得到最终结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.size(); i++) &#123;</span><br><span class="line">            res += array.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深度优先搜索方法，用于计算路径代表的数字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode node, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="comment">// 当前节点的值加入到路径数字中</span></span><br><span class="line">        sum = sum * <span class="number">10</span> + node.val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前节点是叶子节点，将路径数字加入数组</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) array.add(sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有左子节点但没有右子节点，递归搜索左子树</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) dfs(node.left, sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有右子节点但没有左子节点，递归搜索右子树</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right != <span class="literal">null</span>) dfs(node.right, sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果同时有左子节点和右子节点，递归搜索左右子树</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span> &amp;&amp; node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            dfs(node.left, sum);</span><br><span class="line">            dfs(node.right, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同上题一样。</p>
<h3 id="124-二叉树中的最大路径和-力扣（LeetCode）"><a href="#124-二叉树中的最大路径和-力扣（LeetCode）" class="headerlink" title="124. 二叉树中的最大路径和 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/?envType=study-plan-v2&envId=top-interview-150">124. 二叉树中的最大路径和 - 力扣（LeetCode）</a></h3><p>难度：困难</p>
<p><strong>二叉树 动态规划 dfs</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于记录路径和的最大值，初始值为最小的整数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用深度优先搜索计算路径和</span></span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="comment">// 返回路径和的最大值</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该dfs方法返回能给父节点提供的最长路径（一条线不拐弯，从底向上）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="comment">// 如果当前节点为空，返回0</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归计算左子树所能提供的最长路径值</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) l = dfs(node.left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归计算右子树所能提供的最长路径值</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) r = dfs(node.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以当前节点拐弯的最长路径值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">takeCurNodeRootLPS</span> <span class="operator">=</span> l + r + node.val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新最终答案</span></span><br><span class="line">        res = Math.max(takeCurNodeRootLPS, res);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算单条路径最大值，这是要提供给当前节点的父节点的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oneLargestPath</span> <span class="operator">=</span> Math.max(l, r) + node.val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果能提供给父节点的最大路径是负数，那么直接返回0让父节点舍弃自己即可</span></span><br><span class="line">        <span class="keyword">return</span> oneLargestPath &gt; <span class="number">0</span> ? oneLargestPath : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>难点：</p>
<ul>
<li><p><strong>理解路径</strong>：在本题中，路径可以包含当前节点，当前节点左子树和右子树中的节点。也可以仅包含当前节点。</p>
</li>
<li><p><strong>考虑以当前节点为拐点的最大路径</strong>：需要知道<strong>左子树所能提供的最大值</strong>和<strong>右子树所能提供的最大值</strong>，把这两条路径和自己的值相加即可，然后更新全局变量<code>res</code>。</p>
</li>
<li><p><strong>当前节点所能给父节点提供的最大路径</strong>：这个值要提供给父节点做参考，就是考虑<strong>以父节点为拐点</strong>的情况，那么在当前节点的这个栈帧内，就应该选择<strong>当前节点的左子树所能提供的最大值和右子树所能提供的最大值之中较大的那一个</strong>加上当前节点的值。如果这个最终值为小于<code>0</code>，那么直接返回<code>0</code>让父节点不要选择自己。</p>
</li>
<li><p><strong>DFS 动态规划</strong>：DFS先触底然后再往上回溯，而上面节点的路径计算恰好需要下面节点的数据，从下之上，相当于递归的这个栈帧为我们传递了动态规划的数据。</p>
</li>
</ul>
</div><script src="/js/lightgallery.min.js"></script><script>
        if("undefined"!=typeof lightGallery) {
        var options1 = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('article-gallery')[0], options1);
        }
        </script>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2024-08-26</span>
            
                <span>该篇文章被 jay1an</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/%E9%93%BE%E8%A1%A8/'>
                            链表
                        </a>
                    
                        <a href='/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/'>
                            归并排序
                        </a>
                    
                        <a href='/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/'>
                            二叉树
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/%E5%88%B7%E9%A2%98/'>
                            刷题
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    <br>
    
    <!-- <div class="post-footer-pre-next">
        <span>上一篇：<a href=""></a></span>
        <span class="post-footer-pre-next-last-span-right">上一篇：<a href=""></a></span>
    </div> -->

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 1949-2024 China 

            
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>从头努力也坎坷</span>
            
    
</div>


    
<script src="/js/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="/js/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
        <script src="/js/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript"></script>
        <script src="/js/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript"></script>
        
<script src="/js/toc.js"></script>

    
    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery.min.js"></script>



                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>
</html>