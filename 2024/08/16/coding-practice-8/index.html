<!DOCTYPE html>
<html lang="en">
    
    <style>
        body
        {
            font-family: "Times New Roman", Helvetica, Tahoma, Arial,   LXGW WenKai   "notoserifsc-medium", "Microsoft YaHei", "Hiragino Sans GB", "WenQuanYi Micro Hei", sans-serif !important;

        }
    </style>

    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="刷题日记 - 8" />
    <meta name="hexo-theme-A4" content="v1.9.6" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title>Jay1an🎈</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery-bundle.min.css">


<meta name="generator" content="Hexo 7.3.0"></head>
    
    

    
    



    

    
    

    
    
    
    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        <script>
            const options = {
                bottom: '40px', // default: '32px'
                right: 'unset', // default: '32px'
                left: '42px', // default: 'unset'
                time: '0.3s', // default: '0.3s'
                mixColor: '#fff', // default: '#fff'
                backgroundColor: ' #e4e4e4 ',  // default: '#fff'
                buttonColorDark: '#100f2c',  // default: '#100f2c'
                buttonColorLight: '#fff', // default: '#fff'
                saveInCookies: true, // default: true,
                label: '🌓', // default: ''
                autoMatchOsTheme: true // default: true
            }
            const darkmode = new Darkmode(options);
            darkmode.showWidget();
        </script>
        
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Jay1an🎈</a> 
            <span class="description">I am who I am.</span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">⛩️首页</a></li>
            
        
            
                <li><a href="/list/">🗒️文章</a></li>
            
        
            
                <li><a href="/categories/">🏷️分类</a></li>
            
        
            
                <li><a href="/about/">🎨关于</a></li>
            
        
            
                <li><a href="/now/">🎡Now</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">
    

    
        
            
                <div class="post-main-title" style="text-align: center;">
                    刷题日记 - 8
                </div>
            
        
      
    

    

        
            <div class="post-head-meta-center">
        
                
                    <span>最近更新：2024-09-22</span> 
                
                
                    
                        &nbsp; | &nbsp;
                    
                     <span>字数总计：3.3k</span>
                
                
                    
                        &nbsp; | &nbsp;
                    
                    <span>阅读估时：14分钟</span>
                
                
                    
                        &nbsp; | &nbsp;
                    
                    <span id="busuanzi_container_page_pv">
                        阅读量：<span id="busuanzi_value_page_pv"></span>次
                    </span>
                
            </div>
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0-8"><span class="post-toc-text">刷题日记 - 8</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#138-%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">138. 随机链表的复制 - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">92. 反转链表 II - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#25-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">25. K 个一组翻转链表 - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-II-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">82. 删除排序链表中的重复元素 II - 力扣（LeetCode）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">83. 删除排序链表中的重复元素 - 力扣（LeetCode）</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">61. 旋转链表 - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）</span></a></li></ol></li></ol></li></ol>
            
        
        <div class=".article-gallery"><h1 id="刷题日记-8"><a href="#刷题日记-8" class="headerlink" title="刷题日记 - 8"></a>刷题日记 - 8</h1><p>记录刷题。</p>
<h3 id="138-随机链表的复制-力扣（LeetCode）"><a href="#138-随机链表的复制-力扣（LeetCode）" class="headerlink" title="138. 随机链表的复制 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/copy-list-with-random-pointer/description/?envType=study-plan-v2&envId=top-interview-150">138. 随机链表的复制 - 力扣（LeetCode）</a></h3><p>难度：中等</p>
<p><strong>链表 哈希表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Node类的定义，用于表示链表的节点</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;      // 节点的值</span></span><br><span class="line"><span class="comment">    Node next;    // 指向下一个节点的指针</span></span><br><span class="line"><span class="comment">    Node random;  // 指向随机节点的指针</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个HashMap用于存储原节点和对应复制节点之间的映射关系</span></span><br><span class="line">        HashMap&lt;Node, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个哑节点dummy，最终返回dummy.next作为新链表的头节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> dummy;  <span class="comment">// t用于构建新链表</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head;   <span class="comment">// p用于遍历原链表</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历原链表</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">randomNode</span> <span class="operator">=</span> p.random;  <span class="comment">// 获取当前节点的随机指针指向的节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">tmpRandom</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查map中是否已存在当前节点的复制节点</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(p)) &#123;</span><br><span class="line">                tmp = map.get(p);  <span class="comment">// 获取已存在的复制节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp = <span class="keyword">new</span> <span class="title class_">Node</span>(p.val);  <span class="comment">// 创建新的复制节点</span></span><br><span class="line">                map.put(p, tmp);        <span class="comment">// 存入map中</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理随机指针指向的节点</span></span><br><span class="line">            <span class="keyword">if</span> (randomNode != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(randomNode)) &#123;</span><br><span class="line">                    tmpRandom = map.get(randomNode);  <span class="comment">// 获取已存在的复制节点</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tmpRandom = <span class="keyword">new</span> <span class="title class_">Node</span>(randomNode.val);  <span class="comment">// 创建新的复制节点</span></span><br><span class="line">                    map.put(randomNode, tmpRandom);        <span class="comment">// 存入map中</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将复制节点连接到新链表上</span></span><br><span class="line">            t.next = tmp;</span><br><span class="line">            t = t.next;</span><br><span class="line">            t.random = tmpRandom;  <span class="comment">// 设置随机指针</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移动原链表指针</span></span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回新链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>难点：</p>
<ul>
<li><strong>复制链表中的随机指针</strong> 确保新链表中的随机指针指向新链表中的对应节点，而不是原链表中的节点，这就会导致后面的节点可能被提前创建，所以我们引入了哈希表。</li>
</ul>
<h3 id="92-反转链表-II-力扣（LeetCode）"><a href="#92-反转链表-II-力扣（LeetCode）" class="headerlink" title="92. 反转链表 II - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list-ii/?envType=study-plan-v2&envId=top-interview-150">92. 反转链表 II - 力扣（LeetCode）</a></h3><p>难度：中等</p>
<p><strong>链表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单链表节点的定义。</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val; // 节点的值</span></span><br><span class="line"><span class="comment"> *     ListNode next; // 指向下一个节点的指针</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果left和right相同，无需反转，直接返回head</span></span><br><span class="line">        <span class="keyword">if</span>(left == right) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化指针p指向head，dummy节点指向head以便处理头节点的变化</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head); <span class="comment">// dummy节点指向链表头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> dummy; <span class="comment">// leftNode指向反转部分前的节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// rightNode指向反转部分后的节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到leftNode和rightNode</span></span><br><span class="line">        <span class="keyword">while</span>(count &lt;= right + <span class="number">1</span> &amp;&amp; p != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(count + <span class="number">1</span> == left) leftNode = p; <span class="comment">// 找到left的前一个节点</span></span><br><span class="line">            <span class="keyword">if</span>(count == right + <span class="number">1</span>) rightNode = p; <span class="comment">// 找到right的下一个节点</span></span><br><span class="line">            count++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始反转left到right区间的链表</span></span><br><span class="line">        p = leftNode.next; <span class="comment">// p指向需要反转的第一个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">q</span> <span class="operator">=</span> p.next; <span class="comment">// q指向需要反转的第二个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">t</span> <span class="operator">=</span> q.next; <span class="comment">// t指向需要反转的第三个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反转链表的中间部分</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            q.next = p; <span class="comment">// 当前节点q的next指向前一个节点p</span></span><br><span class="line">            p = q; <span class="comment">// p向前移动一位</span></span><br><span class="line">            q = t; <span class="comment">// q向前移动一位</span></span><br><span class="line">            <span class="keyword">if</span>(q == rightNode) <span class="keyword">break</span>; <span class="comment">// 如果q到达rightNode（反转结束），跳出循环</span></span><br><span class="line">            t = q.next; <span class="comment">// t向前移动一位</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理反转后的节点连接</span></span><br><span class="line">        leftNode.next.next = rightNode; <span class="comment">// 反转部分的最后一个节点指向rightNode</span></span><br><span class="line">        leftNode.next = p; <span class="comment">// leftNode的下一个节点指向反转后的第一个节点p</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回新的链表头节点</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的点：</p>
<ul>
<li><p><strong>指针的正确初始化</strong>：需要正确初始化 <code>leftNode</code> 和 <code>rightNode</code>，分别指向需要反转部分的前一个结点和后一个节点。</p>
</li>
<li><p><strong>反转区间的正确处理</strong>：使用三个指针进行反转</p>
</li>
<li><p><strong>边界情况</strong>：当<code>left==1</code>时，<code>leftNode</code>无意义，所以需要创建dummy节点。</p>
</li>
</ul>
<h3 id="25-K-个一组翻转链表-力扣（LeetCode）"><a href="#25-K-个一组翻转链表-力扣（LeetCode）" class="headerlink" title="25. K 个一组翻转链表 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-nodes-in-k-group/description/?envType=study-plan-v2&envId=top-interview-150">25. K 个一组翻转链表 - 力扣（LeetCode）</a></h3><p>难度：困难</p>
<p><strong>链表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果k小于2，链表无需反转，直接返回原链表</span></span><br><span class="line">        <span class="keyword">if</span>(k &lt; <span class="number">2</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head); <span class="comment">// dummy节点指向链表头</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy; <span class="comment">// 指针p初始化为dummy</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 计数器，用于记录当前节点的位置</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 用于记录每组反转前的前一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">                pre = p; <span class="comment">// 当count为0时，pre指向当前p的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count == k + <span class="number">1</span>) &#123; <span class="comment">// 当count达到k+1时，说明当前组需要反转</span></span><br><span class="line">                p = reverseBetween(pre, p); <span class="comment">// 反转pre到p之间的节点</span></span><br><span class="line">                count = <span class="number">0</span>; <span class="comment">// 重置计数器</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count++; <span class="comment">// 计数器增加</span></span><br><span class="line">            <span class="keyword">if</span>(p == <span class="literal">null</span>) <span class="keyword">break</span>; <span class="comment">// 如果p为空，说明链表遍历结束</span></span><br><span class="line">            p = p.next; <span class="comment">// p指向下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next; <span class="comment">// 返回新的链表头</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转pre和tail之间的节点（至少有两个节点）</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode pre, ListNode tail)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> pre.next; <span class="comment">// p指向需要反转的第一个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">q</span> <span class="operator">=</span> p.next; <span class="comment">// q指向需要反转的第二个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">t</span> <span class="operator">=</span> q.next; <span class="comment">// t指向需要反转的第三个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> pre.next; <span class="comment">// res最终指向反转部分的最后一个节点（反转前的第一个节点）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            q.next = p; <span class="comment">// 当前节点q的next指向前一个节点p</span></span><br><span class="line">            p = q; <span class="comment">// p向前移动一位</span></span><br><span class="line">            q = t; <span class="comment">// q向前移动一位</span></span><br><span class="line">            <span class="keyword">if</span>(q == tail) <span class="keyword">break</span>; <span class="comment">// 如果q到达tail，跳出循环</span></span><br><span class="line">            t = q.next; <span class="comment">// t向前移动一位</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre.next.next = tail; <span class="comment">// 反转部分的最后一个节点连接到tail</span></span><br><span class="line">        pre.next = p; <span class="comment">// pre的next指向反转后的第一个节点p</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 返回反转前的第一个节点（现在是最后一个）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合上一个题。</p>
<ul>
<li><p><strong>分组处理</strong>：每K组做一次反转，注意寻找 <code>pre</code>节点和<code>tail</code>节点，即连接反转部分的头和尾。</p>
</li>
<li><p><strong>部分反转与下一次的连接</strong>：上一组反转完之后的最后一个节点，将作为下一组反转的<code>pre</code>节点</p>
</li>
<li><p><strong>注意边界</strong>：在这里不能用<code>while(p!=null)</code>结束，因为最后这个<code>p</code>还可能作为<code>tail</code>对最后一组进行反转。</p>
</li>
</ul>
<h3 id="19-删除链表的倒数第-N-个结点-力扣（LeetCode）"><a href="#19-删除链表的倒数第-N-个结点-力扣（LeetCode）" class="headerlink" title="19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/?envType=study-plan-v2&envId=top-interview-150">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）</a></h3><p>难度：中等</p>
<p><strong>链表 双指针</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个dummy节点，指向head</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">        <span class="comment">// p和q指针都指向dummy</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">q</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 计数器，用于记录p的移动次数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历链表，p指针先走，q指针延迟n步</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(count &gt; n) q = q.next; <span class="comment">// 当p走了n步后，q开始移动</span></span><br><span class="line">            p = p.next; <span class="comment">// p指针向前移动</span></span><br><span class="line">            count++; <span class="comment">// 计数器增加</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// q.next指向q.next.next，即跳过第n个节点</span></span><br><span class="line">        q.next = q.next.next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回新链表的头节点（dummy.next）</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>技巧就是利用双指针，指针步长一样，但是出发时机不同，让其中一个指针先跑<code>n+1</code>步，<strong>让先出发那个指针到达终点<code>null</code>的时候，后出发的指针刚好到要删除的节点的前一个节点。</strong></p>
<p>注意，还是要设置 dummy 节点，因为可能会出现要删除的节点就是第一个节点的情况。</p>
<h3 id="82-删除排序链表中的重复元素-II-力扣（LeetCode）"><a href="#82-删除排序链表中的重复元素-II-力扣（LeetCode）" class="headerlink" title="82. 删除排序链表中的重复元素 II - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/?envType=study-plan-v2&envId=top-interview-150">82. 删除排序链表中的重复元素 II - 力扣（LeetCode）</a></h3><p>难度：中等</p>
<p><strong>链表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果链表为空或只有一个元素，直接返回链表</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个虚拟头节点，便于处理链表的边界情况</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">t</span> <span class="operator">=</span> dummy; <span class="comment">// t用于构建去重后的新链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head; <span class="comment">// p用于遍历原始链表</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">q</span> <span class="operator">=</span> p.next; <span class="comment">// q用于指向p的下一个节点</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// flag标识当前元素是否为重复元素</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果当前元素与下一个元素相同，继续移动p直到找到不同的元素</span></span><br><span class="line">            <span class="keyword">while</span> (q != <span class="literal">null</span> &amp;&amp; q.val == p.val) &#123;</span><br><span class="line">                p = q;</span><br><span class="line">                q = p == <span class="literal">null</span> ? <span class="literal">null</span> : p.next;</span><br><span class="line">                flag = <span class="literal">true</span>; <span class="comment">// 标记当前元素为重复元素</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果当前元素是重复的，跳过这个元素</span></span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                p = q;  <span class="comment">//  ⭐后面不再做任何操作，因为不确定后面的元素是否是重复的</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则将当前元素加入到去重后的链表中</span></span><br><span class="line">                t.next = p;</span><br><span class="line">                t = t.next;</span><br><span class="line">                p = q;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        t.next = <span class="literal">null</span>; <span class="comment">// 确保去重后的链表尾部指向null</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next; <span class="comment">// 返回去重后的链表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>难点：</p>
<ul>
<li><strong>处理重复元素的逻辑</strong>：使用节点指针<code>t</code>指向哪些非重复元素，我使用了布尔值<code>flag</code>标记了当前元素是否是重复元素，后续根据<code>flag</code>值确定<code>t</code>指针的指向。</li>
<li><strong>边界条件处理</strong>：有可能出现链表中所有的元素都是重复元素的情况，所以需要一个<code>dummy</code>节点</li>
<li><strong>确保去重后的链表尾部指向null</strong></li>
</ul>
<h4 id="83-删除排序链表中的重复元素-力扣（LeetCode）"><a href="#83-删除排序链表中的重复元素-力扣（LeetCode）" class="headerlink" title="83. 删除排序链表中的重复元素 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素 - 力扣（LeetCode）</a></h4><p>难度：简单</p>
<p>字节客户端面试题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>||head.next==<span class="literal">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">t</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t==dummy||t.val!=p.val)&#123;</span><br><span class="line">                t.next = p;</span><br><span class="line">                t = t.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        t.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是面试的时候，给的题目描述是83题的描述，示例给的是82题的示例。</p>
<h3 id="61-旋转链表-力扣（LeetCode）"><a href="#61-旋转链表-力扣（LeetCode）" class="headerlink" title="61. 旋转链表 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-list/?envType=study-plan-v2&envId=top-interview-150">61. 旋转链表 - 力扣（LeetCode）</a></h3><p>难度：中等</p>
<p><strong>链表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">rotateRight</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个虚拟头节点，并将其指向head</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果k为0或者链表为空，直接返回链表</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || head == <span class="literal">null</span>) <span class="keyword">return</span> dummy.next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义一个长度为501的数组来存储链表中的节点</span></span><br><span class="line">        ListNode[] con = <span class="keyword">new</span> <span class="title class_">ListNode</span>[<span class="number">501</span>];</span><br><span class="line">        con[<span class="number">0</span>] = dummy; <span class="comment">// 将虚拟头节点放在数组的第一个位置</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 记录链表节点数量</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历链表并将节点存储到数组中</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            con[count++] = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> count - <span class="number">1</span>; <span class="comment">// 总节点数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算旋转后的实际移动步数</span></span><br><span class="line">        k %= total;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 第一次反转整个链表</span></span><br><span class="line">            reverseBetween(dummy, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 找到需要分割的位置</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> con[total - k];</span><br><span class="line">            <span class="comment">// 第二次反转前半部分链表</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp_1</span> <span class="operator">=</span> reverseBetween(dummy, tmp);</span><br><span class="line">            <span class="comment">// 第三次反转后半部分链表</span></span><br><span class="line">            reverseBetween(tmp_1, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next; <span class="comment">// 返回旋转后的链表头节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转链表从pre.next到tail的部分</span></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode pre, ListNode tail)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> pre.next; <span class="comment">// 保存反转部分的开始节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> pre.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">q</span> <span class="operator">=</span> p.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">t</span> <span class="operator">=</span> q == <span class="literal">null</span> ? <span class="literal">null</span> : q.next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 进行反转操作</span></span><br><span class="line">        <span class="keyword">while</span> (q != tail) &#123;</span><br><span class="line">            q.next = p;</span><br><span class="line">            p = q;</span><br><span class="line">            q = t;</span><br><span class="line">            t = q == <span class="literal">null</span> ? <span class="literal">null</span> : q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next.next = tail; <span class="comment">// 将反转部分的尾节点指向tail</span></span><br><span class="line">        pre.next = p; <span class="comment">// 将pre.next指向反转后的头节点</span></span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 返回反转部分的头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思想同<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-array/description/">189. 轮转数组 - 力扣（LeetCode）</a></p>
<h3 id="105-从前序与中序遍历序列构造二叉树-力扣（LeetCode）"><a href="#105-从前序与中序遍历序列构造二叉树-力扣（LeetCode）" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/?envType=study-plan-v2&envId=top-interview-150">105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）</a></h3><p>难度：中等</p>
<p><strong>二叉树 DFS</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 记录前序遍历数组中当前处理的节点位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过递归构建二叉树，初始时处理整个中序遍历数组</span></span><br><span class="line">        <span class="keyword">return</span> dfs(preorder, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>);   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前范围无效（左边界大于右边界），返回null，表示该子树为空</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 前序遍历的下一个节点是当前子树的根节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[++count]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在中序遍历中找到当前根节点的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.val == inorder[i]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归构建左子树</span></span><br><span class="line">        cur.left = dfs(preorder, inorder, left, i - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归构建右子树</span></span><br><span class="line">        cur.right = dfs(preorder, inorder, i + <span class="number">1</span>, right);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回构建好的当前根节点</span></span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>难点：</p>
<ul>
<li><strong>理解递归构建树的过程：</strong>从前序遍历中依次取出元素作为根节点，然后在中序遍历中找到该根节点的位置，从而将树分为左右两部分，再递归构建左右子树。</li>
</ul>
<h3 id="106-从中序与后序遍历序列构造二叉树-力扣（LeetCode）"><a href="#106-从中序与后序遍历序列构造二叉树-力扣（LeetCode）" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/?envType=study-plan-v2&envId=top-interview-150">106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）</a></h3><p><strong>难度：中等</strong></p>
<p><strong>二叉树 DFS</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        count = inorder.length;</span><br><span class="line">        <span class="keyword">return</span> dfs(inorder,postorder,<span class="number">0</span>,count-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] inorder,<span class="type">int</span>[] postorder,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curVal</span> <span class="operator">=</span> postorder[--count];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">curNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(curVal);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;=right;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i]==curVal)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curNode.right = dfs(inorder,postorder,i+<span class="number">1</span>,right);</span><br><span class="line">        curNode.left = dfs(inorder,postorder,left,i-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> curNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>道理同上，只是 <code>preorder</code>换成了<code>postorder</code>，所以现在从<code>postorder</code>中拿去子树的根节点，并且左右子树的递归顺序需要改变。</p>
<p><strong>上一个题目</strong>：</p>
<ol>
<li>从前序遍历数组中依次选择根节点。</li>
<li>在中序遍历数组中找到该根节点的位置，划分左右子树。</li>
<li>递归构建左子树，然后递归构建右子树。</li>
</ol>
<p><strong>这个题目</strong>：</p>
<ol>
<li>从后序遍历数组中依次选择根节点。</li>
<li>在中序遍历数组中找到该根节点的位置，划分左右子树。</li>
<li>递归构建右子树，然后递归构建左子树。</li>
</ol>
</div>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2024-08-16</span>
            
                <span>该篇文章被 jay1an</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/%E9%93%BE%E8%A1%A8/'>
                            链表
                        </a>
                    
                        <a href='/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/'>
                            二叉树
                        </a>
                    
                        <a href='/tags/DFS/'>
                            DFS
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/%E5%88%B7%E9%A2%98/'>
                            刷题
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    <br>
    
    
        
            
    
            <div class="post-footer-pre-next">
                
                    <span>上一篇：<a href='/2024/08/22/coding-practice-9/'>刷题日记 - 9</a></span>
                

                
                    <span class="post-footer-pre-next-last-span-right">下一篇：<a href="/2024/08/13/coding-practice-7/">刷题日记 - 7</a>
                    </span>
                
            </div>
    
        
    

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 1949-2024 Jay1an 

            
                

            
        </span>
       
    
</div>



<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>从头努力也坎坷</span>
            
                <span class="footer-last-span-right"><i>本站由<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/index.html">Hexo</a>驱动｜使用<a target="_blank" rel="noopener" href="https://github.com/HiNinoJay/hexo-theme-A4">Hexo-theme-A4</a>主题</i></span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery/lightgallery.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-thumbnail.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-fullscreen.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-autoplay.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-zoom.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-rotate.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-paper.umd.min.js"></script>




<script type="text/javascript">
     
    if (typeof lightGallery !== "undefined") {
        var options1 = {
            selector: '.gallery-item',
            plugins: [lgThumbnail, lgFullscreen, lgAutoplay, lgZoom, lgRotate, lgPager], // 启用插件
            thumbnail: true,          // 显示缩略图
            zoom: true,               // 启用缩放功
            rotate: true,             // 启用旋转功能能
            autoplay: true,        // 启用自动播放功能
            fullScreen: true,      // 启用全屏功能
            pager: false, //页码,
            zoomFromOrigin: true,   // 从原始位置缩放
            actualSize: true,       // 启用查看实际大小的功能
            enableZoomAfter: 300,    // 延迟缩放，确保图片加载完成后可缩放
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options1); // 修复选择器
    }
    
</script>


    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> 

                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>
</html>