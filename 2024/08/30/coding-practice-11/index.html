<!DOCTYPE html>
<html lang="en">
    
    <style>
        body
        {
            font-family: "Times New Roman", Helvetica, Tahoma, Arial,   LXGW WenKai   "notoserifsc-medium", "Microsoft YaHei", "Hiragino Sans GB", "WenQuanYi Micro Hei", sans-serif !important;

        }
    </style>

    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="刷题日记 - 11" />
    <meta name="hexo-theme-A4" content="v1.9.0" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title>Jay1an</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery.min.css">


<meta name="generator" content="Hexo 7.3.0"></head>
    
    <style>
        :root {
            --waline-theme-color: #323e74; 
            --waline-color: #323e74; 
            --waline-border-color: #323e74; 
            --waline-white: #323e74; 
            --waline-bgcolor-light: #f2fafc;  
        }
        body {
            color: #323e74;
            background: #eaeae8;
        }
        .post-md code {
            background: #e7f7f3;
            color: #7f688d; 
        }
        .post-md pre, .post-md .highlight {
            background: #e7f7f3;
            color: #7f688d; 
        }
        pre .string, pre .value, pre .inheritance, pre .header, pre .ruby .symbol, pre .xml .cdata {
            color: #323e74;
        }
        pre .number, pre .preprocessor, pre .built_in, pre .literal, pre .params, pre .constant {
            color: #323e74;
        }
        .year-font-color {
            color: #323e74 !important;
        }
        .wl-card span.wl-nick {
            color: #323e74; 
        }
        .wl-card .wl-badge {
            border: 1px solid #323e74;
            color: #323e74; 
        }
        .wl-btn {
            border: 1px solid #323e74; 
            color:  #323e74;  
        }
        .wl-btn.primary {
            color: #f2fafc; 
        }
        .wl-header label {
            color: #323e74;
        }
        a {
            color: #7f688d;
        }

        .post-md a {
            color: #7f688d;
        }

        .nav li a {
            color: #7f688d;
        }

        .archive-main a:link {
            color: #7f688d;
        }
        .archive-main a:visited {
            color: #767c7c; 
        }

        .archive li span {
            color: #323e74;
        }

        .post-main-title {
            color: #323e74;
        }

        .post-md h1,
        .post-md h2,
        .post-md h3,
        .post-md h4,
        .post-md h5,
        .post-md h6 {
            color: #323e74;
        }

        [data-waline] p {
            color: #323e74;
        }
        [data-waline] a {
            color: #323e74;
        } 
        .wl-sort li.active {
            color: #323e74;
        }

        .wl-card .wl-meta>span {
            background: #f2fafc;
        }

        .paper {
            background: #eaeae8;
        }

        .index-main {
            background: #f2fafc;
        }

        .paper-main {
            background: #f2fafc;
        }

        .wl-panel {
            background: #f2fafc;
        }

        .archive li:nth-child(odd) {
            background: #f2fafc;
            ;
        }

        .archive li:nth-child(even) {
            background: #f2fafc;
        }

        .post-md table tr:nth-child(odd) td {
            background: #f2fafc;
        }

        .post-md table tr:nth-child(even) td {
            background: #f2fafc;
        }

    
        .progress-wrap::after {
            color: #323e74; /* 箭头的颜色 */
        }
        .progress-wrap svg.progress-circle path {
	        stroke: #323e74; /* 边框的颜色 */
        }
        .progress-wrap::before {
	        background-image: linear-gradient(298deg, #7f688d, #7f688d); /* 鼠标滑过的箭头颜色 */
         }

        .return-to-last-progress-wrap::after {
            color: #323e74; /* 箭头的颜色 */
        }
        .return-to-last-progress-wrap svg.progress-circle path {
	        stroke: #323e74; /* 边框的颜色 */
        }
        .return-to-last-progress-wrap::before {
	        background-image: linear-gradient(298deg, #7f688d, #7f688d); /* 鼠标滑过的箭头颜色 */
         }

         .left-toc-container::-webkit-scrollbar-thumb {
            background-color: #323e74; /* 设置滚动条拖动块的颜色 */
        }

        .bs-docs-sidebar .nav>.active>a,
        .bs-docs-sidebar .nav>li>a:hover,
        .bs-docs-sidebar .nav>li>a:focus {
            color: #7f688d;
            border-left-color: #7f688d;
        }
        .bs-docs-sidebar .nav>li>a {
            color:  #323e74;
        }
    </style>

    
    
    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Jay1an</a> 
            <span class="description">I am who I am.</span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            刷题日记 - 11
        </div>
      
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0-11"><span class="post-toc-text">刷题日记 - 11</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#173-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">173. 二叉搜索树迭代器 - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">222. 完全二叉树的节点个数 - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">236. 二叉树的最近公共祖先 - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#637-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">637. 二叉树的层平均值 - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">103. 二叉树的锯齿形层序遍历 - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3144-%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E9%A2%91%E7%8E%87%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%91%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">3144. 分割字符频率相等的最少子字符串 - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%A5%BF%E4%BA%86%E4%B9%88-8-23-%E7%AC%94%E8%AF%95%E7%AC%AC%E4%BA%8C%E9%A2%98"><span class="post-toc-text">饿了么 8-23 笔试第二题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#93-%E5%A4%8D%E5%8E%9F-IP-%E5%9C%B0%E5%9D%80-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">93. 复原 IP 地址 - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%B0%86IP%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E4%B8%BAint%EF%BC%8C%E5%86%8D%E5%B0%86int%E8%BD%AC%E6%8D%A2%E4%B8%BAIP%E5%9C%B0%E5%9D%80"><span class="post-toc-text">将IP地址转换为int，再将int转换为IP地址</span></a></li></ol></li></ol></li></ol>
            
        
        <link rel="stylesheet" type="text/css" href="/css/lightgallery.min.css" /><div class="article-gallery"><h1 id="刷题日记-11"><a href="#刷题日记-11" class="headerlink" title="刷题日记 - 11"></a>刷题日记 - 11</h1><h3 id="173-二叉搜索树迭代器-力扣（LeetCode）"><a href="#173-二叉搜索树迭代器-力扣（LeetCode）" class="headerlink" title="173. 二叉搜索树迭代器 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search-tree-iterator/?envType=study-plan-v2&envId=top-interview-150">173. 二叉搜索树迭代器 - 力扣（LeetCode）</a></h3><p>难度：中等</p>
<p><strong>二叉树 中序遍历</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储二叉搜索树的中序遍历结果</span></span><br><span class="line">    List&lt;Integer&gt; array;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向当前遍历的元素索引</span></span><br><span class="line">    <span class="type">int</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储中序遍历结果的总大小</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，初始化迭代器并进行中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTIterator</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 对树进行中序遍历并存储结果</span></span><br><span class="line">        dfs(root);</span><br><span class="line">        size = array.size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回中序遍历的下一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> array.get(p++);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否还有下一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(p &lt; size) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对树进行中序遍历的递归函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(node.left);        <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        array.add(node.val);   <span class="comment">// 将当前节点值添加到列表</span></span><br><span class="line">        dfs(node.right);       <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现一个二叉树中序迭代器，我的思路是在<strong>初始化的时候就将先中序遍历的结果存入数组</strong>，然后根据指针来判断。</p>
<p>但是这个方法无论如何都会先中序遍历一边二叉树，这其实是没必要的，因为这个迭代器又不能回到上一个，把中序遍历的结果存入数组其实很没必要。</p>
<p>本题应该希望我们用栈来模拟中序遍历。</p>
<hr>
<p><strong>用栈模拟</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈用于保存遍历过程中节点</span></span><br><span class="line">    Stack&lt;TreeNode&gt; stack;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数，初始化栈，并将左子树节点按顺序压入栈中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTIterator</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) stack.push(root);</span><br><span class="line">        <span class="comment">// 将所有左子节点压入栈中，直到最左边的节点</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().left != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(stack.peek().left);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回中序遍历的下一个节点值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 弹出栈顶节点，即当前最小节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="comment">// 如果弹出的节点有右子树，处理右子树节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">            <span class="comment">// 将右子树的所有左子节点压入栈中</span></span><br><span class="line">            <span class="keyword">while</span> (stack.peek().left != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(stack.peek().left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回当前节点的值</span></span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否还有未遍历的节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以回顾一下用栈完成二叉树的中序遍历。</p>
<h3 id="222-完全二叉树的节点个数-力扣（LeetCode）"><a href="#222-完全二叉树的节点个数-力扣（LeetCode）" class="headerlink" title="222. 完全二叉树的节点个数 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/description/?envType=study-plan-v2&envId=top-interview-150">222. 完全二叉树的节点个数 - 力扣（LeetCode）</a></h3><p>难度：简单</p>
<p><strong>二叉树</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> countNodes(root.left) + countNodes(root.right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以直接遍历得到，时间复杂度O(n)。</p>
<p>但是没有利用到完全二叉树的特性。</p>
<hr>
<p>如果要利用到完全二叉树的性质。</p>
<p>可以<strong>判断根节点的左子树和右子树哪一个是满二叉树</strong>，对于是满二叉树的子树，这一部分的节点数计算可以不用通过遍历计数。</p>
<p>如何判断呢？</p>
<ul>
<li>左子树和右子树都是完全二叉树</li>
<li>完全二叉树的深度可以直接通过一直访问左节点得到</li>
<li>完全二叉树最后一层的节点是从左到右排列的</li>
<li>如果左子树和右子树深度相同，证明左子树是满二叉树 （有可能右子树也是满二叉树，这里也可以通过一直访问右节点来判断右子树是不是满二叉树）</li>
<li>如果深度不同，则右子树是满二叉树</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 包含根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> countLevel(root.left);  <span class="comment">// 左子树的深度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> countLevel(root.right); <span class="comment">// 右子树的深度</span></span><br><span class="line">        <span class="keyword">if</span>(leftDepth==rightDepth)&#123;</span><br><span class="line">            <span class="comment">// 证明左子树是完全二叉树</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">leftCount</span> <span class="operator">=</span> (<span class="type">int</span>)Math.pow(<span class="number">2</span>,leftDepth) - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rightCount</span> <span class="operator">=</span> dfsCount(root.right);</span><br><span class="line">            res = res + leftCount + rightCount;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 证明右子树是完全二叉树</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">leftCount</span> <span class="operator">=</span> dfsCount(root.left);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rightCount</span> <span class="operator">=</span> (<span class="type">int</span>)Math.pow(<span class="number">2</span>,rightDepth) - <span class="number">1</span>;</span><br><span class="line">            res = res + leftCount + rightCount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfsCount</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dfsCount(node.left)+dfsCount(node.right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countLevel</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="literal">null</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="236-二叉树的最近公共祖先-力扣（LeetCode）"><a href="#236-二叉树的最近公共祖先-力扣（LeetCode）" class="headerlink" title="236. 二叉树的最近公共祖先 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/?envType=study-plan-v2&envId=top-interview-150">236. 二叉树的最近公共祖先 - 力扣（LeetCode）</a></h3><p>难度：中等</p>
<p><strong>二叉树</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root, p, q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">dfs</span><span class="params">(TreeNode node, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归终止条件：当前节点是null，当前节点等于p或者q</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span> || node == q || node == p) <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在左子树中查找 p 和 q ，如果返回null则表示左子树中没有p q节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">l</span> <span class="operator">=</span> dfs(node.left, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在右子树中查找 p 和 q</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">r</span> <span class="operator">=</span> dfs(node.right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左子树中没找到，说明 p 和 q 都在右子树中，返回右子树的结果</span></span><br><span class="line">        <span class="keyword">if</span> (l == <span class="literal">null</span>) <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右子树中没找到，说明 p 和 q 都在左子树中，返回左子树的结果</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) <span class="keyword">return</span> l;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果左右子树中都找到了，则当前节点 node 是最近公共祖先</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dfs函数只会返回3个值：</p>
<ul>
<li>p、q的共同父节点</li>
<li>p节点</li>
<li>q节点</li>
</ul>
<p>dfs先序遍历遇到p或者q节点之后就会往回回溯。</p>
<p>如果对于某一个节点<code>l</code>和<code>r</code>都不为<code>null</code>表明它就是最近共公父节点。</p>
<p>如果对于某一个节点<code>l</code>的值为<code>null</code>，<code>r</code>不为<code>null</code>，那么证明两个节点一定在该节点的右节点。</p>
<p><code>l!=null, r==null</code>同理。</p>
<p>当<code>l</code>,<code>r</code>都为<code>null</code>，则表示目标节点都不在这颗节点之下。</p>
<h3 id="637-二叉树的层平均值-力扣（LeetCode）"><a href="#637-二叉树的层平均值-力扣（LeetCode）" class="headerlink" title="637. 二叉树的层平均值 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/?envType=study-plan-v2&envId=top-interview-150">637. 二叉树的层平均值 - 力扣（LeetCode）</a></h3><p>难度：简单</p>
<p><strong>二叉树</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Double&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offerLast(root);</span><br><span class="line">        queue.offerLast(<span class="literal">null</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.pollFirst();</span><br><span class="line">            <span class="keyword">if</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                sum += cur.val*<span class="number">1.0</span>;</span><br><span class="line">                <span class="keyword">if</span>(cur.left!=<span class="literal">null</span>)queue.offerLast(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right!=<span class="literal">null</span>)queue.offerLast(cur.right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.add(sum/count);</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(queue.isEmpty())<span class="keyword">break</span>;</span><br><span class="line">                queue.offerLast(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是二叉树<strong>层序遍历</strong>。</p>
<h3 id="103-二叉树的锯齿形层序遍历-力扣（LeetCode）"><a href="#103-二叉树的锯齿形层序遍历-力扣（LeetCode）" class="headerlink" title="103. 二叉树的锯齿形层序遍历 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/?envType=study-plan-v2&envId=top-interview-150">103. 二叉树的锯齿形层序遍历 - 力扣（LeetCode）</a></h3><p>难度：中等</p>
<p><strong>二叉树 链表头插</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">LEFT</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">RIGHT</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offerLast(root);</span><br><span class="line">        queue.offerLast(<span class="literal">null</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">STATE</span> <span class="operator">=</span> RIGHT;</span><br><span class="line">        List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.pollFirst();</span><br><span class="line">            <span class="keyword">if</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 其余部分都是层序遍历</span></span><br><span class="line">                <span class="comment">// 锯齿形层序遍历的特点，有一些层的数据是原始层序遍历Reverse的</span></span><br><span class="line">                <span class="comment">// 链表尾插法得到的是原始的，头插法就是Reverse的</span></span><br><span class="line">                <span class="keyword">if</span>(STATE==LEFT)&#123;</span><br><span class="line">                    tmp.add(<span class="number">0</span>,cur.val);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    tmp.add(cur.val);</span><br><span class="line">                &#125;                </span><br><span class="line">                <span class="keyword">if</span>(cur.left!=<span class="literal">null</span>)queue.offerLast(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right!=<span class="literal">null</span>)queue.offerLast(cur.right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.add(tmp);</span><br><span class="line">                tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                STATE = STATE==LEFT?RIGHT:LEFT;</span><br><span class="line">                <span class="keyword">if</span>(queue.isEmpty())<span class="keyword">break</span>;</span><br><span class="line">                queue.offerLast(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3144-分割字符频率相等的最少子字符串-力扣（LeetCode）"><a href="#3144-分割字符频率相等的最少子字符串-力扣（LeetCode）" class="headerlink" title="3144. 分割字符频率相等的最少子字符串 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-substring-partition-of-equal-character-frequency/?envType=daily-question&envId=2024-08-28">3144. 分割字符频率相等的最少子字符串 - 力扣（LeetCode）</a></h3><p>难度：中等</p>
<p><strong>分区动态规划 字符串</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumSubstringsInPartition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> chars.length;</span><br><span class="line">        <span class="type">boolean</span>[][] map = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];  <span class="comment">//map[i][j]表示字符串s中下标i-&gt;j的子字符串是不是平衡的</span></span><br><span class="line">        <span class="type">int</span>[] counter = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先处理字符串s，给map赋值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            Arrays.fill(map[i],<span class="literal">true</span>);</span><br><span class="line">            Arrays.fill(counter,<span class="number">0</span>);</span><br><span class="line">            counter[chars[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">                counter[chars[j]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> count:counter)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(tmp==-<span class="number">1</span>)tmp = count;</span><br><span class="line">                        <span class="keyword">if</span>(count!=tmp)&#123;</span><br><span class="line">                            map[i][j] = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态规划部分</span></span><br><span class="line">        <span class="comment">// dp[i]表示，从0-&gt;i，最少可以分为成多少个平衡字符串</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map[<span class="number">0</span>][i])dp[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 状态转移方程dp[i] = min_dp[j:0...i-1] + 1,map[j,i]==true</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(map[j][i])&#123;</span><br><span class="line">                        min = Math.min(min,dp[j-<span class="number">1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i] = min+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2^)</p>
<hr>
<p>给map赋值那一段可以进行优化，不必每次都遍历一次counter数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给map赋值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">    Arrays.fill(map[i],<span class="literal">true</span>);</span><br><span class="line">    Arrays.fill(counter,<span class="number">0</span>);</span><br><span class="line">    counter[chars[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(counter[chars[j]-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>)count++;</span><br><span class="line">        counter[chars[j]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        max = Math.max(counter[chars[j]-<span class="string">&#x27;a&#x27;</span>],max);</span><br><span class="line">        <span class="keyword">if</span>(j-i+<span class="number">1</span>!=count*max)map[i][j] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记录<code>i-&gt;j</code>中有多少种字符，以及字符出现的最大次数，如果总字符串不等于字符种类数*字符出现最大次数，那么直接判定该子串不是平衡子串。</p>
<h3 id="饿了么-8-23-笔试第二题"><a href="#饿了么-8-23-笔试第二题" class="headerlink" title="饿了么 8-23 笔试第二题"></a>饿了么 8-23 笔试第二题</h3><p><strong>动态规划</strong></p>
<p><a href="/../img/coding-practice-11/1724903218-FHDaPL-abd58ca6eb8097e0596f90cb3d24de3.jpg" title="abd58ca6eb8097e0596f90cb3d24de3.jpg" class="gallery-item" style="box-shadow: none;"> <img src="/../img/coding-practice-11/1724903218-FHDaPL-abd58ca6eb8097e0596f90cb3d24de3.jpg" alt="abd58ca6eb8097e0596f90cb3d24de3.jpg"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Helloworld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">long</span>[] dp = <span class="keyword">new</span> <span class="title class_">long</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">1_000_000_001</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>, min = MAX;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n; j++) &#123;</span><br><span class="line">                max = Math.max(arr[j], max);</span><br><span class="line">                min = Math.min(arr[j], min);</span><br><span class="line">                dp[j + <span class="number">1</span>] = Math.max(dp[j + <span class="number">1</span>], max - min + dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="93-复原-IP-地址-力扣（LeetCode）"><a href="#93-复原-IP-地址-力扣（LeetCode）" class="headerlink" title="93. 复原 IP 地址 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址 - 力扣（LeetCode）</a></h3><p>难度：中等</p>
<p><strong>字符串 dfs</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> chars.length;</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        dfs(chars,<span class="number">0</span>,len,list);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[] chars,<span class="type">int</span> cur,<span class="type">int</span> len,LinkedList&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        <span class="comment">// 结束dfs的条件</span></span><br><span class="line">        <span class="keyword">if</span>(list.size()==<span class="number">4</span>&amp;&amp;cur==len)&#123;</span><br><span class="line">            <span class="comment">// 符合的情况</span></span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            sb.append(list.get(<span class="number">0</span>));</span><br><span class="line">            sb.append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            sb.append(list.get(<span class="number">1</span>));</span><br><span class="line">            sb.append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            sb.append(list.get(<span class="number">2</span>));</span><br><span class="line">            sb.append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            sb.append(list.get(<span class="number">3</span>));</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(list.size()==<span class="number">4</span>&amp;&amp;cur&lt;len)<span class="keyword">return</span>; <span class="comment">// 不符合的情况直接返回</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> <span class="number">0</span>;                             <span class="comment">// 计算当前槽位的值（一共四个槽位），初始值为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=cur;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curElem</span> <span class="operator">=</span> chars[i] - <span class="string">&#x27;0&#x27;</span>;        <span class="comment">// cur位置的值</span></span><br><span class="line">            val = val*<span class="number">10</span> + curElem;              <span class="comment">// 加上cur位置的数字，等于目前槽位的值</span></span><br><span class="line">            <span class="keyword">if</span>(val&lt;=<span class="number">255</span>)&#123;                        <span class="comment">// 槽位上数字满足0&lt;=val&lt;=255才进行下一轮</span></span><br><span class="line">                list.offerLast(val);</span><br><span class="line">                dfs(chars,i+<span class="number">1</span>,len,list);</span><br><span class="line">                list.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(val==<span class="number">0</span>||val&gt;<span class="number">255</span>)<span class="keyword">break</span>;          <span class="comment">// 当val==0，表明cur位置为0，由于不能出现前置0，所以要在这里break</span></span><br><span class="line">        &#125;									   <span class="comment">// 当val&gt;255，不满足，当前槽位所有可能的值都遍历完了</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将IP地址转换为int，再将int转换为IP地址"><a href="#将IP地址转换为int，再将int转换为IP地址" class="headerlink" title="将IP地址转换为int，再将int转换为IP地址"></a>将IP地址转换为int，再将int转换为IP地址</h3><p>int占4个字节，IP地址是String，占用的空间7-15个字节。</p>
<p>这样做可以节省空间，IP地址正好是四个八位二进制数，所以正好可以用int表示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> <span class="string">&quot;192.168.0.1&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> IP2Int(ip);</span><br><span class="line">        System.out.println(res);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> Int2IP(res);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">IP2Int</span><span class="params">(String ip)</span>&#123;</span><br><span class="line">        String[] strs = ip.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; strs.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">8</span>*(<span class="number">3</span>-i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> Integer.parseInt(strs[i]) &lt;&lt; pos;</span><br><span class="line">            res = res|val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">Int2IP</span><span class="params">(<span class="type">int</span> IPint)</span>&#123;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> (<span class="number">3</span>-i)*<span class="number">8</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> IPint &amp; (<span class="number">255</span> &lt;&lt; pos);</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> tmp &gt;&gt;&gt; pos;</span><br><span class="line">            strs[i] = String.valueOf(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.join(<span class="string">&quot;.&quot;</span>,strs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用位运算，将IP的四个部分分布在32位中的四个8位，然后组合成一个整数。</p>
<p>注意，最后往右移的时候，是无符号右移。</p>
<blockquote>
<p><code>&gt;&gt;</code> 算术右移，如果是正数左边用0填充，如果左边是负数用1填充</p>
<p><code>&gt;&gt;&gt;</code>逻辑右移，全用0填充</p>
</blockquote>
</div><script src="/js/lightgallery.min.js"></script><script>
        if("undefined"!=typeof lightGallery) {
        var options1 = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('article-gallery')[0], options1);
        }
        </script>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2024-08-30</span>
            
                <span>该篇文章被 jay1an</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/'>
                            二叉树
                        </a>
                    
                        <a href='/tags/DP/'>
                            DP
                        </a>
                    
                        <a href='/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/'>
                            位运算
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/%E5%88%B7%E9%A2%98/'>
                            刷题
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    <br>
    
    <!-- <div class="post-footer-pre-next">
        <span>上一篇：<a href=""></a></span>
        <span class="post-footer-pre-next-last-span-right">上一篇：<a href=""></a></span>
    </div> -->

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 1949-2024 China 

            
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>从头努力也坎坷</span>
            
    
</div>


    
<script src="/js/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="/js/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
        <script src="/js/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript"></script>
        <script src="/js/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript"></script>
        
<script src="/js/toc.js"></script>

    
    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery.min.js"></script>



                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>
</html>