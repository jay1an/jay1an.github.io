<!DOCTYPE html>
<html lang="en">
    
    <style>
        body
        {
            font-family: "Times New Roman", Helvetica, Tahoma, Arial,   LXGW WenKai   "notoserifsc-medium", "Microsoft YaHei", "Hiragino Sans GB", "WenQuanYi Micro Hei", sans-serif !important;

        }
    </style>

    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="贪心算法 - Greedy Algorithm" />
    <meta name="hexo-theme-A4" content="v1.9.0" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title>Jay1an</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery.min.css">


<meta name="generator" content="Hexo 7.3.0"></head>
    
    <style>
        :root {
            --waline-theme-color: #323e74; 
            --waline-color: #323e74; 
            --waline-border-color: #323e74; 
            --waline-white: #323e74; 
            --waline-bgcolor-light: #f2fafc;  
        }
        body {
            color: #323e74;
            background: #eaeae8;
        }
        .post-md code {
            background: #e7f7f3;
            color: #7f688d; 
        }
        .post-md pre, .post-md .highlight {
            background: #e7f7f3;
            color: #7f688d; 
        }
        pre .string, pre .value, pre .inheritance, pre .header, pre .ruby .symbol, pre .xml .cdata {
            color: #323e74;
        }
        pre .number, pre .preprocessor, pre .built_in, pre .literal, pre .params, pre .constant {
            color: #323e74;
        }
        .year-font-color {
            color: #323e74 !important;
        }
        .wl-card span.wl-nick {
            color: #323e74; 
        }
        .wl-card .wl-badge {
            border: 1px solid #323e74;
            color: #323e74; 
        }
        .wl-btn {
            border: 1px solid #323e74; 
            color:  #323e74;  
        }
        .wl-btn.primary {
            color: #f2fafc; 
        }
        .wl-header label {
            color: #323e74;
        }
        a {
            color: #7f688d;
        }

        .post-md a {
            color: #7f688d;
        }

        .nav li a {
            color: #7f688d;
        }

        .archive-main a:link {
            color: #7f688d;
        }
        .archive-main a:visited {
            color: #767c7c; 
        }

        .archive li span {
            color: #323e74;
        }

        .post-main-title {
            color: #323e74;
        }

        .post-md h1,
        .post-md h2,
        .post-md h3,
        .post-md h4,
        .post-md h5,
        .post-md h6 {
            color: #323e74;
        }

        [data-waline] p {
            color: #323e74;
        }
        [data-waline] a {
            color: #323e74;
        } 
        .wl-sort li.active {
            color: #323e74;
        }

        .wl-card .wl-meta>span {
            background: #f2fafc;
        }

        .paper {
            background: #eaeae8;
        }

        .index-main {
            background: #f2fafc;
        }

        .paper-main {
            background: #f2fafc;
        }

        .wl-panel {
            background: #f2fafc;
        }

        .archive li:nth-child(odd) {
            background: #f2fafc;
            ;
        }

        .archive li:nth-child(even) {
            background: #f2fafc;
        }

        .post-md table tr:nth-child(odd) td {
            background: #f2fafc;
        }

        .post-md table tr:nth-child(even) td {
            background: #f2fafc;
        }

    
        .progress-wrap::after {
            color: #323e74; /* 箭头的颜色 */
        }
        .progress-wrap svg.progress-circle path {
	        stroke: #323e74; /* 边框的颜色 */
        }
        .progress-wrap::before {
	        background-image: linear-gradient(298deg, #7f688d, #7f688d); /* 鼠标滑过的箭头颜色 */
         }

        .return-to-last-progress-wrap::after {
            color: #323e74; /* 箭头的颜色 */
        }
        .return-to-last-progress-wrap svg.progress-circle path {
	        stroke: #323e74; /* 边框的颜色 */
        }
        .return-to-last-progress-wrap::before {
	        background-image: linear-gradient(298deg, #7f688d, #7f688d); /* 鼠标滑过的箭头颜色 */
         }

         .left-toc-container::-webkit-scrollbar-thumb {
            background-color: #323e74; /* 设置滚动条拖动块的颜色 */
        }

        .bs-docs-sidebar .nav>.active>a,
        .bs-docs-sidebar .nav>li>a:hover,
        .bs-docs-sidebar .nav>li>a:focus {
            color: #7f688d;
            border-left-color: #7f688d;
        }
        .bs-docs-sidebar .nav>li>a {
            color:  #323e74;
        }
    </style>

    
    
    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Jay1an</a> 
            <span class="description">I am who I am.</span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/tags/">标签</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            贪心算法 - Greedy Algorithm
        </div>
      
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="post-toc-text">基础算法 - 贪心算法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8"><span class="post-toc-text">贪心算法的应用</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#LeetCode-%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE"><span class="post-toc-text">LeetCode 相关题目</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">121. 买卖股票的最佳时机 - 力扣（LeetCode）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="post-toc-text">动态规划</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%B4%AA%E5%BF%83"><span class="post-toc-text">贪心</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">55. 跳跃游戏 - 力扣（LeetCode）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#DFS"><span class="post-toc-text">DFS</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%B4%AA%E5%BF%83-1"><span class="post-toc-text">贪心</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-II-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">45. 跳跃游戏 II - 力扣（LeetCode）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#DFS-1"><span class="post-toc-text">DFS</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1"><span class="post-toc-text">动态规划</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%B4%AA%E5%BF%83-2"><span class="post-toc-text">贪心</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">763. 划分字母区间 - 力扣（LeetCode）</span></a></li></ol></li></ol></li></ol>
            
        
        <link rel="stylesheet" type="text/css" href="/css/lightgallery.min.css" /><div class="article-gallery"><h1 id="基础算法-贪心算法"><a href="#基础算法-贪心算法" class="headerlink" title="基础算法 - 贪心算法"></a>基础算法 - 贪心算法</h1><p>贪心算法（Greedy Algorithm）是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致全局最优解的算法。贪心算法在某些问题中能够产生全局最优解，而在另一些问题中只能产生近似解。</p>
<p>贪心算法的主要特点包括：</p>
<ul>
<li><strong>局部最优选择</strong>：每一步都选择当前状态下的局部最优解。</li>
<li><strong>简单高效</strong>：相对于其他复杂算法，贪心算法通常更为简单且计算效率高。</li>
<li><strong>不保证全局最优</strong>：贪心算法并不总能保证找到全局最优解，适用于某些特定类型的问题。</li>
</ul>
<h2 id="贪心算法的应用"><a href="#贪心算法的应用" class="headerlink" title="贪心算法的应用"></a>贪心算法的应用</h2><p>贪心算法通常应用于以下类型的问题：</p>
<ul>
<li><strong>最小生成树</strong>：如 Kruskal 算法和 Prim 算法。</li>
<li><strong>单源最短路径</strong>：如 Dijkstra 算法。</li>
<li><strong>活动选择问题</strong>：选择最大数量的互不相交活动。</li>
<li><strong>背包问题</strong>：在一定容量限制下选择物品使总价值最大（贪心算法仅适用于分数背包问题）。</li>
</ul>
<h2 id="LeetCode-相关题目"><a href="#LeetCode-相关题目" class="headerlink" title="LeetCode 相关题目"></a>LeetCode 相关题目</h2><h3 id="121-买卖股票的最佳时机-力扣（LeetCode）"><a href="#121-买卖股票的最佳时机-力扣（LeetCode）" class="headerlink" title="121. 买卖股票的最佳时机 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/?envType=study-plan-v2&envId=top-100-liked">121. 买卖股票的最佳时机 - 力扣（LeetCode）</a></h3><p>难度：简单</p>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>想要获得最大收益，可以计算在第<code>i</code>天买入股票可以获得的最大收益的每一种可能，然后进行比较得出最小值。</p>
<p>在第<code>i</code>天买入股票可以获得的最大收益值 &#x3D; 第<code>i</code>天之后的最高股价 - 第<code>i</code>天的股价。</p>
<p>可以用暴力的解法，两个for循环，时间复杂度为O(n^2^)。</p>
<p>将买入的钱固定下来，去寻找未知的卖出的钱，而卖出的钱就一直往后遍历就可以，这样其实每一次遍历都会有多余的操作，因为只要遍历一次j就可以知道某一个范围内最大的是多少了，而这样按照这种暴力的思想，会导致其重复计算。</p>
<p>那么，如何避免这个多余的遍历呢，我们可以用记忆化搜索的方式，或者说是动态规划的方法来记录。</p>
<p>核心思想就在：<strong>如果今日买入股票，获得的最高收益 &#x3D; 之后股价最大值 - 今日股票值</strong>，而这个“<strong>之后股价最大值</strong>“由我们先遍历一次得出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="comment">// dp[i]代表，第i天后股价最高值，i的取值为0....len-1</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        dp[len-<span class="number">1</span>] = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;   <span class="comment">// 从尾部开始向头部遍历</span></span><br><span class="line">            dp[i] = Math.max(dp[i+<span class="number">1</span>],prices[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(Arrays.toString(dp));</span></span><br><span class="line">        <span class="comment">// 不在最后一天买股票</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            ans = Math.max(dp[i] - prices[i],ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h4><p>并不关心其他日子买入股票所获得的最大收益，只关注最大收益。</p>
<p>最大收益就是 股票最高价  -  曾经的股票最低价 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">         <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> n : prices)&#123;</span><br><span class="line">             min = Math.min(min,n);</span><br><span class="line">             res = Math.max(res,n - min);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="55-跳跃游戏-力扣（LeetCode）"><a href="#55-跳跃游戏-力扣（LeetCode）" class="headerlink" title="55. 跳跃游戏 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/description/?envType=study-plan-v2&envId=top-100-liked">55. 跳跃游戏 - 力扣（LeetCode）</a></h3><p>难度：中等</p>
<h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><p>可以利用DFS 确保探索所有可能的路径，当找到成功成功路劲之后直接返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        dfs(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag||cur&gt;=nums.length)&#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> nums[cur];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=val;i&gt;=<span class="number">1</span>;i--)&#123;  <span class="comment">// 运行超时的关键</span></span><br><span class="line">            dfs(nums,cur+i);</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="literal">true</span>)<span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这种方法在数据特别大的情况下很容易运行超时，而且还容易栈溢出。</p>
<p><strong>效率低下</strong>：DFS 在每个节点尝试所有可能的跳跃，导致时间复杂度较高，特别是在数组较大或跳跃次数较多的情况下，容易导致运行超时。</p>
<p><strong>冗余计算</strong>：很多路径会被重复计算，导致性能问题。</p>
<h4 id="贪心-1"><a href="#贪心-1" class="headerlink" title="贪心"></a>贪心</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// max记录能到的最大位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历每一个元素，根据这个元素的值确定可到达的最大位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="comment">// 如果当前大于了 目前能到达的最大位置，表明已经寄了</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;max)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 更新max</span></span><br><span class="line">            max = Math.max(max,nums[i]+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体来说，它体现了以下贪心策略：</p>
<ol>
<li><strong>局部最优选择</strong>：在每一步，选择当前能跳到的最远位置。这意味着每次都在尽可能扩展能到达的范围。</li>
<li><strong>全局最优结果</strong>：通过每次选择当前能到达的最远位置，最终判断是否能够到达数组的末尾。</li>
</ol>
<p>在代码中，<code>max</code>变量记录了当前能到达的最远位置。遍历数组时，<code>max</code>会不断更新为<code>nums[i] + i</code>和<code>max</code>中的最大值，这意味着在每一步，算法都选择能跳到的最远位置。</p>
<p>确保在每一步都选择当前最优的跳跃，从而判断是否能够跳到最后一个位置。</p>
<h3 id="45-跳跃游戏-II-力扣（LeetCode）"><a href="#45-跳跃游戏-II-力扣（LeetCode）" class="headerlink" title="45. 跳跃游戏 II - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game-ii/?envType=study-plan-v2&envId=top-100-liked">45. 跳跃游戏 II - 力扣（LeetCode）</a></h3><p>难度：中等</p>
<p>与跳跃游戏比，这里给出的样例都可以满足抵达最后一个位置，但这个题求的是最小的跳跃次数。</p>
<h4 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 dfs 时传递初始位置 0 和初始跳跃次数 0</span></span><br><span class="line">        dfs(nums, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> cur, <span class="type">int</span> jumps)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前下标超过或到达数组末尾，更新最小跳跃次数</span></span><br><span class="line">        <span class="keyword">if</span> (cur &gt;= nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">            res = Math.min(res, jumps);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> nums[cur];</span><br><span class="line">        <span class="comment">// 尝试从当前位置跳跃到所有可能的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= val; i++) &#123;</span><br><span class="line">            dfs(nums, cur + i, jumps + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历每一个成功路径，同时记录跳跃数，将最小跳跃数留下。</p>
<p><strong>超时</strong></p>
<h4 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h4><p><code>dp[i]</code>代表跳到位置<code>i</code>需要的最少跳跃数。</p>
<p>对于位置 <code>i</code>，你可以跳 <code>nums[i]</code> 步。那么对于所有可以从 <code>i</code> 跳到的位置 <code>i + j</code>，更新 <code>dp</code> 数组的逻辑如下：</p>
<ol>
<li><strong>当前的位置</strong>：<code>i</code></li>
<li><strong>可以跳的步数</strong>：<code>nums[i]</code></li>
<li><strong>从当前位置 <code>i</code> 跳到所有可能的位置 <code>i + j</code></strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= nums[i] &amp;&amp; i + j &lt; len; j++) &#123;</span><br><span class="line">    dp[i + j] = Math.min(dp[i + j], dp[i] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// dp[i]代表抵达第i个位置所需要的最小的跳跃数</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        Arrays.fill(dp,Integer.MAX_VALUE);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            tmp = dp[i];</span><br><span class="line">            <span class="comment">// 更新dp数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=nums[i]&amp;&amp;i+j&lt;len;j++)&#123;</span><br><span class="line">                dp[i+j] = Math.min(dp[i+j],dp[i]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法是可以通过的，不过时间复杂度略高<code>O(n*m)</code>， <code>m=Max(nums[i])</code>,而本题中<code>0&lt;nums[i]&lt;1000</code>，所以最大也就<code>1000</code>而已，所以还是可以通过的，如果数字更大一点，这个方法就会超时了。</p>
<h4 id="贪心-2"><a href="#贪心-2" class="headerlink" title="贪心"></a>贪心</h4><p>关注起跳的时机</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 规定[left,right)为某一轮的起跳区间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 初始时候只能从0位置起跳</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxPos</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 表示每一轮起跳所能抵达的最大位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 表示用了多少轮（起跳次数）</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 继续跳跃直到能够到达数组的最后一个位置</span></span><br><span class="line">        <span class="keyword">while</span>(maxPos &lt; nums.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 在当前起跳区间[left, right)内寻找最远能到达的位置</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right; i++)&#123;</span><br><span class="line">                <span class="comment">// 更新每个位置能跳到的最远位置</span></span><br><span class="line">                maxPos = Math.max(maxPos, i + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            count++; <span class="comment">// 增加跳跃次数</span></span><br><span class="line">            <span class="comment">// 更新起跳区间</span></span><br><span class="line">            left = right;</span><br><span class="line">            right = maxPos + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count; <span class="comment">// 返回跳跃次数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>贪心策略的体现</strong>：</p>
<ul>
<li>每次从当前起跳区间内，选择能跳到的最远位置进行更新。</li>
<li>通过这种方式，每次跳跃都是在当前能够选择的最优位置，从而保证跳跃次数最少。</li>
</ul>
<p><strong>只关注最少起跳次数，并不关心最少起跳次数的路径。</strong></p>
<h3 id="763-划分字母区间-力扣（LeetCode）"><a href="#763-划分字母区间-力扣（LeetCode）" class="headerlink" title="763. 划分字母区间 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-labels/description/?envType=study-plan-v2&envId=top-100-liked">763. 划分字母区间 - 力扣（LeetCode）</a></h3><p>难度：中等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// 记录每一个字符出现的最后的一个位置</span></span><br><span class="line">        <span class="type">int</span>[] last = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">char</span> tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            tmp = s.charAt(i);</span><br><span class="line">            last[tmp-<span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 划分区间 [start,end]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur&lt;len)&#123;</span><br><span class="line">            tmp = s.charAt(cur);</span><br><span class="line">            <span class="comment">// end代表，在[start,cur]这个区间中的某一个字符，出现的最远的位置</span></span><br><span class="line">            <span class="comment">// 即[start,end]才是一个合格的区间</span></span><br><span class="line">            end = Math.max(end,last[tmp-<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            <span class="comment">// 当cur==end之后，证明[start,end]是一个合格的区间了</span></span><br><span class="line">            <span class="keyword">if</span>(cur==end)&#123;</span><br><span class="line">                res.add(end-start+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 需要重新定start了</span></span><br><span class="line">                start = end+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过这种方式，每次都选择一个尽可能大的区间，使得区间内的字符在该区间之外不再出现。</strong></p>
<p>当遍历到的位置 <code>cur</code> 等于当前区间的终点 <code>end</code> 时，说明当前区间 <code>[start, end]</code> 已经确定，即<code>[start,end]</code>中所有的字串不会出现在其他区间中。并且这样还做到了将字符串划分为尽可能多的片段。</p>
</div><script src="/js/lightgallery.min.js"></script><script>
        if("undefined"!=typeof lightGallery) {
        var options1 = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('article-gallery')[0], options1);
        }
        </script>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2024-06-15</span>
            
                <span>该篇文章被 jay1an</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/'>
                            基础算法
                        </a>
                    
                        <a href='/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/'>
                            贪心算法
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/'>
                            基础算法
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    <br>
    
    <!-- <div class="post-footer-pre-next">
        <span>上一篇：<a href=""></a></span>
        <span class="post-footer-pre-next-last-span-right">上一篇：<a href=""></a></span>
    </div> -->

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 1949-2024 China 

            
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>从头努力也坎坷</span>
            
    
</div>


    
<script src="/js/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="/js/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
        <script src="/js/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript"></script>
        <script src="/js/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript"></script>
        
<script src="/js/toc.js"></script>

    
    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery.min.js"></script>



                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>
</html>