<!DOCTYPE html>
<html lang="en">
    
    <style>
        body
        {
            font-family: "Times New Roman", Helvetica, Tahoma, Arial,   LXGW WenKai   "notoserifsc-medium", "Microsoft YaHei", "Hiragino Sans GB", "WenQuanYi Micro Hei", sans-serif !important;

        }
    </style>

    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="动态规划 - Dynamic Programming - 2" />
    <meta name="hexo-theme-A4" content="v1.9.6" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title>Jay1an🎈</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery-bundle.min.css">


<meta name="generator" content="Hexo 7.3.0"></head>
    
    

    
    



    

    
    

    
    
    
    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        <script>
            const options = {
                bottom: '40px', // default: '32px'
                right: 'unset', // default: '32px'
                left: '42px', // default: 'unset'
                time: '0.3s', // default: '0.3s'
                mixColor: '#fff', // default: '#fff'
                backgroundColor: ' #e4e4e4 ',  // default: '#fff'
                buttonColorDark: '#100f2c',  // default: '#100f2c'
                buttonColorLight: '#fff', // default: '#fff'
                saveInCookies: true, // default: true,
                label: '🌓', // default: ''
                autoMatchOsTheme: true // default: true
            }
            const darkmode = new Darkmode(options);
            darkmode.showWidget();
        </script>
        
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Jay1an🎈</a> 
            <span class="description">I am who I am.</span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">⛩️首页</a></li>
            
        
            
                <li><a href="/list/">🗒️文章</a></li>
            
        
            
                <li><a href="/categories/">🏷️分类</a></li>
            
        
            
                <li><a href="/about/">🎨关于</a></li>
            
        
            
                <li><a href="/now/">🎡Now</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">
    

    
        
            
                <div class="post-main-title" style="text-align: center;">
                    动态规划 - Dynamic Programming - 2
                </div>
            
        
      
    

    

        
            <div class="post-head-meta-center">
        
                
                    <span>最近更新：2024-07-22</span> 
                
                
                    
                        &nbsp; | &nbsp;
                    
                     <span>字数总计：2.2k</span>
                
                
                    
                        &nbsp; | &nbsp;
                    
                    <span>阅读估时：10分钟</span>
                
                
                    
                        &nbsp; | &nbsp;
                    
                    <span id="busuanzi_container_page_pv">
                        阅读量：<span id="busuanzi_value_page_pv"></span>次
                    </span>
                
            </div>
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2"><span class="post-toc-text">基础算法 - 动态规划 - 2</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE"><span class="post-toc-text">相关题目</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">62. 不同路径 - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">64. 最小路径和 - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">5. 最长回文子串 - 力扣（LeetCode）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="post-toc-text">动态规划</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%B8%AD%E5%BF%83%E5%BC%80%E8%8A%B1%E6%B3%95"><span class="post-toc-text">中心开花法</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">1143. 最长公共子序列 - 力扣（LeetCode）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="post-toc-text">72. 编辑距离 - 力扣（LeetCode）</span></a></li></ol></li></ol></li></ol>
            
        
        <div class=".article-gallery"><h1 id="基础算法-动态规划-2"><a href="#基础算法-动态规划-2" class="headerlink" title="基础算法 - 动态规划 - 2"></a>基础算法 - 动态规划 - 2</h1><p>多维动态规划。</p>
<h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><h3 id="62-不同路径-力扣（LeetCode）"><a href="#62-不同路径-力扣（LeetCode）" class="headerlink" title="62. 不同路径 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/?envType=study-plan-v2&envId=top-100-liked">62. 不同路径 - 力扣（LeetCode）</a></h3><p>难度：中等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>]; <span class="comment">// 创建大小为 (m+1)x(n+1) 的二维数组</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 初始化起点前一个位置为 1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历每个单元格，填充路径数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]; <span class="comment">// 状态转移方程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m][n]; <span class="comment">// 返回到达终点 (m, n) 的路径数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>爬楼梯二维版。</p>
<p><strong>状态定义</strong></p>
<p><code>dp[i][j]</code> 表示从起点 <code>(1, 1)</code> 到位置 <code>(i, j)</code> 的路径数量。</p>
<p><strong>状态转移方程</strong></p>
<p>对于位置 <code>(i, j)</code>，它的路径数量等于它上方位置 <code>(i-1, j)</code> 和左侧位置 <code>(i, j-1)</code> 的路径数量之和： <code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</code></p>
<h3 id="64-最小路径和-力扣（LeetCode）"><a href="#64-最小路径和-力扣（LeetCode）" class="headerlink" title="64. 最小路径和 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-path-sum/description/?envType=study-plan-v2&envId=top-100-liked">64. 最小路径和 - 力扣（LeetCode）</a></h3><p>难度：中等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="comment">// 第一排 和第一列特殊处理</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>状态定义</strong></p>
<p><code>dp[i][j]</code> 表示从起点 <code>(1, 1)</code> 到位置 <code>(i, j)</code> 的最小路径和。</p>
<p><strong>状态转移</strong></p>
<p>对于位置 <code>(i, j)</code>，它的最小路径和等于它上方位置 <code>(i-1, j)</code> 和左侧位置 <code>(i, j-1)</code> 的最小路径和加上当前位置的值。</p>
<h3 id="5-最长回文子串-力扣（LeetCode）"><a href="#5-最长回文子串-力扣（LeetCode）" class="headerlink" title="5. 最长回文子串 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/description/?envType=study-plan-v2&envId=top-100-liked">5. 最长回文子串 - 力扣（LeetCode）</a></h3><p>难度：中等</p>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();  <span class="comment">// 获取字符串的长度</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len + <span class="number">2</span>][len + <span class="number">2</span>];  <span class="comment">// 定义二维布尔数组，用于存储动态规划的状态</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化dp数组，全部设为true（这是多余的，实际使用中可以直接省略这一步）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= len + <span class="number">1</span>; i++)</span><br><span class="line">            Arrays.fill(dp[i], <span class="literal">true</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> -<span class="number">1</span>;  <span class="comment">// 最长回文子串的起始索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> -<span class="number">1</span>;    <span class="comment">// 最长回文子串的结束索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 最长回文子串的长度</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 倒序遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt;= len; j++) &#123;</span><br><span class="line">                <span class="comment">// 判断子串s[i-1...j-1]是否为回文串</span></span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (s.charAt(i - <span class="number">1</span>) == s.charAt(j - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j]) &#123;</span><br><span class="line">                    <span class="comment">// 如果是回文串，且长度大于当前最长回文子串长度，更新start, end, 和 maxLen</span></span><br><span class="line">                    <span class="keyword">if</span> (j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                        maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                        start = i - <span class="number">1</span>;</span><br><span class="line">                        end = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s.substring(start, end);  <span class="comment">// 返回最长回文子串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>状态定义：</strong></p>
<ul>
<li>用一个二维布尔数组 <code>dp[i][j]</code> 来表示从第 <code>i</code> 个字符到第 <code>j</code> 个字符是否是回文子串。</li>
<li><code>dp[i][j]</code> 为 <code>true</code> 表示 <code>s[i-1...j-1]</code> 是回文子串，<code>false</code> 则表示不是。</li>
</ul>
<p><strong>初始化：</strong></p>
<ul>
<li>所有 <code>dp[i][i]</code> 都是 <code>true</code>，因为单个字符是回文。</li>
<li>所有 <code>dp[i][i-n]</code> 也是被设置为<code>true</code>，这是根据状态转移方程需要而设置的。</li>
</ul>
<p><strong>状态转移方程：</strong></p>
<ul>
<li><p><code>dp[i][j] = dp[i+1][j-1] &amp;&amp; (s.charAt(i-1) == s.charAt(j-1))</code></p>
</li>
<li><p>这意味着如果 <code>s[i-1]</code> 等于 <code>s[j-1]</code>，且 <code>s[i...j]</code> 的内部子串 <code>s[i+1...j-1]</code> 是回文，那么 <code>s[i...j]</code> 也是回文。</p>
<p>注：</p>
<ul>
<li>这里<code>s[i][...]</code>的的计算是依赖于<code>s[i+1][...]</code>的，所以<code>i</code>倒着遍历；</li>
<li><code>dp[i][i+1] = dp[i+1][i] &amp;&amp; (s.charAt(i-1) == s.charAt(j-1))</code> ，需要用到<code>dp[i+1][i]</code>这种无意义的状态，为了不影响合理的状态转移，所以将这种无意义状态设置为<code>true</code></li>
<li>初始化<code>dp[len+2][len+2]</code>，多余的空间也是为了不对特殊情况做判断，维持代码的美观。</li>
</ul>
</li>
</ul>
<h4 id="中心开花法"><a href="#中心开花法" class="headerlink" title="中心开花法"></a>中心开花法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//定义两个边界为全局变量</span></span><br><span class="line">    <span class="type">int</span> left;</span><br><span class="line">    <span class="type">int</span> right;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//在遍历字符时将字符串转换为字符数组操作效率更高</span></span><br><span class="line">        <span class="type">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; charArray.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            valid(charArray,i,i);<span class="comment">//单个字符中心开花判断</span></span><br><span class="line">            valid(charArray,i,i+<span class="number">1</span>);<span class="comment">//两个字符中心开花</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(charArray,left,right-left+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">valid</span><span class="params">(<span class="type">char</span>[] charArray , <span class="type">int</span> i ,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;= <span class="number">0</span> &amp;&amp; j &lt; charArray.length &amp;&amp; charArray[i] == charArray[j])&#123;</span><br><span class="line">            i--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环结束时,判断该回文子串是否为最大</span></span><br><span class="line">        i++;<span class="comment">//结束时i,j已经不是回文子串的范围,所以需要将其加加</span></span><br><span class="line">        j--;</span><br><span class="line">        <span class="keyword">if</span> (j - i &gt; right -left)&#123;</span><br><span class="line">            left = i;</span><br><span class="line">            right = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行速度比动态规划法要快很多。</p>
<h3 id="1143-最长公共子序列-力扣（LeetCode）"><a href="#1143-最长公共子序列-力扣（LeetCode）" class="headerlink" title="1143. 最长公共子序列 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/?envType=study-plan-v2&envId=top-100-liked">1143. 最长公共子序列 - 力扣（LeetCode）</a></h3><p>难度：中等</p>
<p><strong>这个题的难点在于分析出状态转移方程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> text1.length(); <span class="comment">// 获取text1的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> text2.length(); <span class="comment">// 获取text2的长度</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>]; <span class="comment">// 定义dp数组，dp[i][j]表示text1的前i个字符和text2的前j个字符的最长公共子序列长度</span></span><br><span class="line">        <span class="type">char</span>[] charArray1 = text1.toCharArray(); <span class="comment">// 将text1转换为字符数组</span></span><br><span class="line">        <span class="type">char</span>[] charArray2 = text2.toCharArray(); <span class="comment">// 将text2转换为字符数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历text1和text2的每个字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=len1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=len2; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果当前字符相等，则dp[i][j]等于dp[i-1][j-1]加1</span></span><br><span class="line">                <span class="keyword">if</span>(charArray1[i-<span class="number">1</span>] == charArray2[j-<span class="number">1</span>])</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 否则，dp[i][j]等于dp[i][j-1]和dp[i-1][j]的较大值</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回dp数组的最后一个元素，即最长公共子序列的长度</span></span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定义状态</strong>：</p>
<ul>
<li><code>dp[i][j]</code> 表示 <code>text1</code> 的前 <code>i</code> 个字符和 <code>text2</code> 的前 <code>j</code> 个字符的最长公共子序列的长度。</li>
</ul>
<p><strong>状态转移方程</strong>：</p>
<ul>
<li>如果 <code>text1[i-1] == text2[j-1]</code>，那么 <code>dp[i][j] = dp[i-1][j-1] + 1</code>。</li>
<li>如果 <code>text1[i-1] != text2[j-1]</code>，那么 <code>dp[i][j] = Math.max(dp[i][j-1], dp[i-1][j])</code>。</li>
</ul>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">text1 = &#x27;abcde&#x27;  </span><br><span class="line">text2 = &#x27;ace&#x27;</span><br><span class="line">dp[3][2] = dp[2][1]+1;</span><br><span class="line">dp[3][3] = max(dp[3][2],dp[2][3]); </span><br></pre></td></tr></table></figure>

<h3 id="72-编辑距离-力扣（LeetCode）"><a href="#72-编辑距离-力扣（LeetCode）" class="headerlink" title="72. 编辑距离 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/description/?envType=study-plan-v2&envId=top-100-liked">72. 编辑距离 - 力扣（LeetCode）</a></h3><p>难度：中等</p>
<p>本体的难度在于抽象出动态规划的状态和状态转移方程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> word1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化边界条件：dp[i][0] = i 表示将 word1 的前 i 个字符删除需要 i 步</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化边界条件：dp[0][j] = j 表示将 word2 的前 j 个字符插入需要 j 步</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 word1 和 word2 转换为字符数组，方便按字符处理</span></span><br><span class="line">        <span class="type">char</span>[] charArray1 = word1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] charArray2 = word2.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态规划填表过程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">char1</span> <span class="operator">=</span> charArray1[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">char2</span> <span class="operator">=</span> charArray2[j - <span class="number">1</span>];</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 在word2中插入：dp[i][j-1] + 1，对应将 word1 的前 i 个字符转换为 word2 的前 j-1 个字符</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">insert_j</span> <span class="operator">=</span> dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 在word1中插入：dp[i-1][j] + 1，对应将 word1 的前 i-1 个字符转换为 word2 的前 j 个字符</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">insert_i</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 替换操作：dp[i-1][j-1] + 1（如果 char1 != char2），否则 dp[i-1][j-1]</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">replace</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (char1 != char2) &#123;</span><br><span class="line">                    replace += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 取三者中的最小值</span></span><br><span class="line">                dp[i][j] = Math.min(Math.min(insert_j, insert_i), replace);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回最终结果：将 word1 转换为 word2 所需的最小操作数</span></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>初始化</strong>：</p>
<ul>
<li><code>dp[i][0] = i</code>：将 <code>word1</code> 的前 <code>i</code> 个字符删除需要 <code>i</code> 步。</li>
<li><code>dp[0][j] = j</code>：将 <code>word2</code> 的前 <code>j</code> 个字符插入需要 <code>j</code> 步。</li>
</ul>
<p><strong>状态转移</strong>：</p>
<ul>
<li><strong>在<code>word2</code>中插入</strong>：<code>dp[i][j-1] + 1</code> 对应在 <code>word2</code> 中插入一个字符，使得前 <code>i</code> 个字符能与 <code>word2</code> 的前 <code>j</code> 个字符匹配。</li>
<li><strong>在<code>word1</code>中插入</strong>： <code>dp[i-1][j] + 1</code> 对应在 <code>word1</code> 中删除一个字符，使得前 <code>i-1</code> 个字符能与 <code>word2</code> 的前 <code>j</code> 个字符匹配。</li>
<li><strong>替换操作</strong>：<code>dp[i-1][j-1] + 1</code>（如果当前字符不相等）或者 <code>dp[i-1][j-1]</code>（如果当前字符相等）。</li>
</ul>
<p><strong>动态规划</strong>：</p>
<ul>
<li>利用三种操作的最小值更新 <code>dp[i][j]</code>，从而得到将 <code>word1</code> 的前 <code>i</code> 个字符转换为 <code>word2</code> 的前 <code>j</code> 个字符所需的最小操作数。</li>
</ul>
<p><strong>结果</strong>：</p>
<ul>
<li>最后返回 <code>dp[m][n]</code>，即将整个 <code>word1</code> 转换为 <code>word2</code> 所需的最小操作数。</li>
</ul>
</div>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2024-06-20</span>
            
                <span>该篇文章被 jay1an</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/'>
                            基础算法
                        </a>
                    
                        <a href='/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/'>
                            动态规划
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/'>
                            基础算法
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    <br>
    
    
        
            
    
            <div class="post-footer-pre-next">
                
                    <span>上一篇：<a href='/2024/07/08/blog-server-migration/'>博客迁移记</a></span>
                

                
                    <span class="post-footer-pre-next-last-span-right">下一篇：<a href="/2024/06/18/algorithms-dp-1/">动态规划 - Dynamic Programming - 1</a>
                    </span>
                
            </div>
    
        
    

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 1949-2024 Jay1an 

            
                

            
        </span>
       
    
</div>



<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>从头努力也坎坷</span>
            
                <span class="footer-last-span-right"><i>本站由<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/index.html">Hexo</a>驱动｜使用<a target="_blank" rel="noopener" href="https://github.com/HiNinoJay/hexo-theme-A4">Hexo-theme-A4</a>主题</i></span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery/lightgallery.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-thumbnail.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-fullscreen.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-autoplay.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-zoom.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-rotate.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-paper.umd.min.js"></script>




<script type="text/javascript">
     
    if (typeof lightGallery !== "undefined") {
        var options1 = {
            selector: '.gallery-item',
            plugins: [lgThumbnail, lgFullscreen, lgAutoplay, lgZoom, lgRotate, lgPager], // 启用插件
            thumbnail: true,          // 显示缩略图
            zoom: true,               // 启用缩放功
            rotate: true,             // 启用旋转功能能
            autoplay: true,        // 启用自动播放功能
            fullScreen: true,      // 启用全屏功能
            pager: false, //页码,
            zoomFromOrigin: true,   // 从原始位置缩放
            actualSize: true,       // 启用查看实际大小的功能
            enableZoomAfter: 300,    // 延迟缩放，确保图片加载完成后可缩放
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options1); // 修复选择器
    }
    
</script>


    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> 

                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>
</html>