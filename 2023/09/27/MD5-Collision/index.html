<!DOCTYPE html>
<html lang="en">
    
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0,  viewport-fit=cover" name="viewport" />
    <meta name="description" content="MD5 Collision Lab" />
    <meta name="hexo-theme-A4" content="v1.8.2" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title>Jay1an</title>

    
        
<link rel="stylesheet" href="/css/a11y-dark.min.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    
    

<meta name="generator" content="Hexo 6.3.0"></head>
    
    
    <body>
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    
<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Jay1an</a> 
            <span class="description">I am who I am.</span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/tags/">标签</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            MD5 Collision Lab
        </div>
      
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#MD5-Collision-Lab"><span class="post-toc-text">MD5 Collision Lab</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9"><span class="post-toc-text">实验内容</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Task1-Generating-Two-Different-Files-with-the-Same-MD5-Hash"><span class="post-toc-text">Task1: Generating Two Different Files with the Same MD5 Hash</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Question-1-If-the-length-of-your-prefix-file-is-not-multiple-of-64-what-is-going-to-happen"><span class="post-toc-text">Question 1. If the length of your prefix file is not multiple of 64, what is going to happen?</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Question-2-Create-a-prefix-file-with-exactly-64-bytes-and-run-the-collision-tool-again-and-see-what-happens"><span class="post-toc-text">Question 2. Create a prefix file with exactly 64 bytes, and run the collision tool again, and see what happens.</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Question-3-Are-the-data-128-bytes-generated-by-md5collgen-completely-different-for-the-two-output-files-Please-identify-all-the-bytes-that-are-different"><span class="post-toc-text">Question 3. Are the data (128 bytes) generated by md5collgen completely different for the two output files? Please identify all the bytes that are different.</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Task-2-Understanding-MD5%E2%80%99s-Property"><span class="post-toc-text">Task 2: Understanding MD5’s Property</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Task-3-Generating-Two-Executable-Files-with-the-Same-MD5-Hash"><span class="post-toc-text">Task 3: Generating Two Executable Files with the Same MD5 Hash</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Task-4-Making-the-Two-Programs-Behave-Differently"><span class="post-toc-text">Task 4: Making the Two Programs Behave Differently</span></a></li></ol></li></ol></li></ol>
            
        
        <h1 id="MD5-Collision-Lab"><a href="#MD5-Collision-Lab" class="headerlink" title="MD5 Collision Lab"></a>MD5 Collision Lab</h1><blockquote>
<p><strong>散列函数</strong>（英语：Hash function）又称<strong>散列算法</strong>、<strong>哈希函数</strong>，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0">函数</a>将数据打乱混合，重新创建一个叫做<strong>散列值</strong>（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8#cite_note-1">1]</a>好的散列函数在输入域中很少出现<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A2%B0%E6%92%9E_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">散列冲突</a>。在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E8%A1%A8">散列表</a>和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86">数据处理</a>中，不抑制冲突来区别数据，会使得<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%B0%E5%BD%95&action=edit&redlink=1">数据库记录</a>更难找到。</p>
<p>如今，散列算法也被用来加密存在数据库中的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC">密码</a>（password）字符串，由于散列算法所计算出来的<strong>散列值（Hash Value）</strong>具有<strong>不可逆</strong>（无法逆向演算回原本的数值）的性质，因此可有效的保护密码。</p>
</blockquote>
<p>散列函数的（弱）<strong>抗碰撞性</strong>：对于一个给定的输入x，找另一个值y使得<code>h(x)=h(y)</code>非常困难。</p>
<p>MD5函数的缺陷导致<strong>md5容易遭受碰撞攻击</strong>，此次实验可以证明散列函数的抗碰撞性的重要。</p>
<p>MD5碰撞试验：<a target="_blank" rel="noopener" href="https://seedsecuritylabs.org/Labs_20.04/Crypto/Crypto_MD5_Collision/">https://seedsecuritylabs.org/Labs_20.04/Crypto/Crypto_MD5_Collision/</a></p>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="Task1-Generating-Two-Different-Files-with-the-Same-MD5-Hash"><a href="#Task1-Generating-Two-Different-Files-with-the-Same-MD5-Hash" class="headerlink" title="Task1: Generating Two Different Files with the Same MD5 Hash"></a>Task1: Generating Two Different Files with the Same MD5 Hash</h3><p>使用seed-ubuntu虚拟机中的md5collgen工具生成两个内容不同，但是md5-hash值相同的文件。</p>
<p>先自己创建一个prefix.txt文件，可以在里面随意添加内容。</p>
<p>随后使用md5collgen工具生成两个文件out1.bin和out2.bin。</p>
<pre><code class="bash">md5collgen -p prefix.txt -o ou1.bin out2.bin
</code></pre>
<p>运行情况：</p>
<p><img src="/../img/md5-collision/2.png" alt="2"></p>
<p>查看文件的内容是否相同：</p>
<p><img src="/../img/md5-collision/3.png" alt="3"></p>
<p>out1.bin:</p>
<p><img src="/../img/md5-collision/4.png" alt="4"></p>
<p>out2.bin：</p>
<p><img src="/../img/md5-collision/5.png" alt="5"></p>
<p>可以看到，两个文件都有共同的前缀<code>jay1an</code>，但是后面仍有不同的地方，也就是md5collgen生成的Padding不同，正是这一部分数据的作用，导致两个文件的hash值是相同的。</p>
<blockquote>
<p>注意到这里两个文件的大小都是相同的，并且jay1an后面都有很多空值<code>00(hex)</code>，可以从这里看出，md5collgen会先用空值<code>00(hex)</code>填充，然后再填充有意义的数据。</p>
</blockquote>
<p><img src="/../img/md5-collision/6.png" alt="6"></p>
<p>md5collgen会在prefix内容后增加特定的内容，也正是这些内容导致两个文件的md5-hash值相同。</p>
<p><img src="/../img/md5-collision/1.png" alt="1"></p>
<h4 id="Question-1-If-the-length-of-your-prefix-file-is-not-multiple-of-64-what-is-going-to-happen"><a href="#Question-1-If-the-length-of-your-prefix-file-is-not-multiple-of-64-what-is-going-to-happen" class="headerlink" title="Question 1. If the length of your prefix file is not multiple of 64, what is going to happen?"></a>Question 1. If the length of your prefix file is not multiple of 64, what is going to happen?</h4><p>分析前面所得的out1.bin和out2.bin文件，可以发现最终生成的两个文件的大小都是192bytes，而且文件的内容分为两个部分，前64bytes和后128bytes。</p>
<p>前64bytes：我们指定的前缀+<code>00(hex)</code></p>
<p>后128bytes：md5collgen精心构造的128bytes。</p>
<p>又生成两个文件，查看内存内容：</p>
<p><img src="/../img/md5-collision/7.png" alt="7"></p>
<p>可以得出结论：如果前缀文件大小不是64bytes的倍数，那么md5collgen将会自动用<code>00(hex)</code>将其补充至64bytes的倍数。</p>
<h4 id="Question-2-Create-a-prefix-file-with-exactly-64-bytes-and-run-the-collision-tool-again-and-see-what-happens"><a href="#Question-2-Create-a-prefix-file-with-exactly-64-bytes-and-run-the-collision-tool-again-and-see-what-happens" class="headerlink" title="Question 2. Create a prefix file with exactly 64 bytes, and run the collision tool again, and see what happens."></a>Question 2. Create a prefix file with exactly 64 bytes, and run the collision tool again, and see what happens.</h4><p>通过上面的分析，可以得出：如果prefix文件的大小恰巧是64bytes，那么md5collgen没必要使用<code>00(hex)</code>填充。</p>
<blockquote>
<p>使用大小刚好为64bytes的prefix验证之后，与预想一致。</p>
</blockquote>
<h4 id="Question-3-Are-the-data-128-bytes-generated-by-md5collgen-completely-different-for-the-two-output-files-Please-identify-all-the-bytes-that-are-different"><a href="#Question-3-Are-the-data-128-bytes-generated-by-md5collgen-completely-different-for-the-two-output-files-Please-identify-all-the-bytes-that-are-different" class="headerlink" title="Question 3. Are the data (128 bytes) generated by md5collgen completely different for the two output files? Please identify all the bytes that are different."></a>Question 3. Are the data (128 bytes) generated by md5collgen completely different for the two output files? Please identify all the bytes that are different.</h4><p>这128bytes并不是完全不同的，实际上只有一些细小的差别。</p>
<blockquote>
<p> 我没有去找出每一个不同的byte，不知道是否还有其他规律</p>
</blockquote>
<h3 id="Task-2-Understanding-MD5’s-Property"><a href="#Task-2-Understanding-MD5’s-Property" class="headerlink" title="Task 2: Understanding MD5’s Property"></a>Task 2: Understanding MD5’s Property</h3><p>MD5是一个很复杂的算法，涉及多轮数学运算，但是算法的框架并没有那么复杂。</p>
<p>MD5算法将数据分为多个大小为64bytes的块，再设置一个初始的向量。然后将初始向量IHV0+一个数据块M1作为输入，进行函数F运算，会获得一个中间向量IHV1（128bytes），此向量还会参与下一次F运算，一直迭代直至所有的数据块都被输入且进行运算了，最后的向量 IHVn就作为md5-hash值。</p>
<p><img src="/../img/md5-collision/8.png" alt="8"></p>
<p>这里可以得出一个md5算法的一个性质：给出两个值M, N, 如果 MD5(M) &#x3D; MD5(N)，那么任意的值T，都满足 MD5(M||T) &#x3D; MD5(N||T)，||表示串联、附加。</p>
<p>也就是说，如果M和N的md5-hash值是一样的，那么在M和N后面加上任意相同的后缀生成的两个不同文件，它们的md5-hash值也是一样的。</p>
<blockquote>
<p>此性质对其他类似的hash算法也适用。</p>
</blockquote>
<p>在linux上可以使用cat命令将两个文件合为一个文件。</p>
<pre><code class="bash">cat file1 file2 &gt; file3
</code></pre>
<p>此命令会将file2的内容连接到file1后面，保存生成为file3。</p>
<h3 id="Task-3-Generating-Two-Executable-Files-with-the-Same-MD5-Hash"><a href="#Task-3-Generating-Two-Executable-Files-with-the-Same-MD5-Hash" class="headerlink" title="Task 3: Generating Two Executable Files with the Same MD5 Hash"></a>Task 3: Generating Two Executable Files with the Same MD5 Hash</h3><p>要生成两个md5-hash相同但是内容不同的可执行文件。</p>
<p>实验给出了示例代码如下：</p>
<pre><code class="c">#include &lt;stdio.h&gt;
unsigned char xyz[200] = &#123;
    /* The actual contents of this array are up to you */
&#125;;
int main()
&#123;
    int i;
    for (i=0; i&lt;200; i++)&#123;
        printf(&quot;%x&quot;, xyz[i]);
    &#125;
    printf(&quot;\n&quot;);
&#125;
</code></pre>
<p>按照实验文档给出的思路，我们先将xyz数组用字母’A’ (ASCII编码为<code>0x41</code>)填满，然后将代码编译为二进制可执行文件。</p>
<p>接着我们分析二进制文件的内容，找到储存xyz数组内容的地方。</p>
<p><img src="/../img/md5-collision/9.png" alt="9"></p>
<p>最终在offset为0x3020的地方发现了xyz数组：</p>
<p><img src="/../img/md5-collision/10.png" alt="10"></p>
<p>根据前面task的知识，md5collgen生成的两个hash值相同的文件的不同之处仅在那精心构造的128byets之中。</p>
<p>现在我们将该二进制文件分为三个部分：xyz数组之前，xyz数组，xyz数组之后。</p>
<p>我们选择一个合适的位置将二进制文件截断，截取前面一部分为prefix，往后数128bytes为suffix，保证这128bytes处于xyz数组中间。再使用md5collgen工具，以prefix为前缀生成两个文件prefix_1，prefix_2，然后再依次拼接相同的suffix，生成两个可执行二进制文件ou1.bin，out2.bin。</p>
<p>这样生成的out1.bin和out2.bin就满足要求。</p>
<p><img src="/../img/md5-collision/16.png" alt="16"></p>
<p>但是要注意，prefix的大小一定要是64bytes的倍数，如果不是，填充的空字符会打乱代码的结构，二进制代码无法执行。</p>
<p>因为0x3020 &#x3D; 12320(dec)，但是12320并不是64的倍数，所以截取的prefix应该是前12352bytes，而suffix应该截取除了前面（12352+128）bytes之后的所有。</p>
<p>部分操作截图：</p>
<p>截取prefix，suffix：</p>
<p><img src="/../img/md5-collision/11.png" alt="11"></p>
<blockquote>
<p>截取suffix的命令，应该为tail -c +12481 a.out &gt; suffix</p>
<p>因为tail -c +12381 a.out是显示a.out中从第12381个字节到末尾的所有字节。</p>
</blockquote>
<p>生成两个前缀prefix_1 prefix_2</p>
<p><img src="/../img/md5-collision/12.png" alt="12"></p>
<p>将前缀和后缀链接：</p>
<p><img src="/../../../../../AppData/Roaming/Typora/typora-user-images/image-20231007172252711.png" alt="image-20231007172252711"></p>
<p>运行程序比较结果，发现两个程序打印出的内容不同：</p>
<p><img src="/../img/md5-collision/14.png" alt="14"></p>
<p>查看md5-hash：</p>
<p><img src="/../img/md5-collision/15.png" alt="15"></p>
<blockquote>
<p>MD5(prefix ‖ P ‖ suffix) &#x3D; MD5(prefix ‖ Q ‖ suffix)</p>
</blockquote>
<h3 id="Task-4-Making-the-Two-Programs-Behave-Differently"><a href="#Task-4-Making-the-Two-Programs-Behave-Differently" class="headerlink" title="Task 4: Making the Two Programs Behave Differently"></a>Task 4: Making the Two Programs Behave Differently</h3><p>在task3中，我们创建了两个md5-hash值相同但是运行效果不同的文件，但这不同仅仅是print的内容不同而已，代码逻辑仍没有变化，那么能不能让这个“不同”更有意义呢？</p>
<blockquote>
<p>Assume that you have created a software which does good things. You send the software to a trusted authority to get certified. The authority conducts a comprehensive testing of your software, and concludes that your software is indeed doing good things. The authority will present you with a certificate, stating that your program is good. To prevent you from changing your program after getting the certificate, the MD5 hash value of your program is also included in the certificate; the certificate is signed by the authority, so you cannot change anything on the certificate or your program without rendering the signature invalid.</p>
<p>You would like to get your malicious software certified by the authority, but you have zero chance to achieve that goal if you simply send your malicious software to the authority. However, you have noticed that the authority uses MD5 to generate the hash value. You got an idea. You plan to prepare two different programs. One program will always execute benign instructions and do good things, while the other program will execute malicious instructions and cause damages. You find a way to get these two programs to share the same MD5 hash value. </p>
<p>You then send the benign version to the authority for certification. Since this version does good things, it will pass the certification, and you will get a certificate that contains the hash value of your benign program. Because your malicious program has the same hash value, this certificate is also valid for your malicious program. Therefore, you have successfully obtained a valid certificate for your malicious program. If other people trusted the certificate issued by the authority, they will download your malicious program.</p>
<p>The objective of this task is to launch the attack described above. Namely, you need to create two programs that share the same MD5 hash. However, one program will always execute benign instructions, while the other program will execute malicious instructions. In your work, what benign&#x2F;malicious instructions are executed is not important; it is sufficient to demonstrate that the instructions executed by these two programs<br>are different.</p>
</blockquote>
<p>文档中说：创建两个软件，使它们的hash值相同，但是一个执行良性代码，另一个执行恶意代码。那么就可以向权威机构认证此(良性)软件，证书中将包含hash值，但是同时也可以把执行恶意代码的软件上传到互联网，证书同样对执行恶意代码的软件生效。</p>
<p>本次任务的就是创建两个不同的程序，一个执行<code>benign instructions</code>，另一个执行<code>malicious instructions</code>,但hash值相同。</p>
<p>文档给出的示例伪代码:</p>
<pre><code class="C">Array X;
Array Y;
main()
&#123;
    if(X’s contents and Y’s contents are the same)
    run benign code;
    else
    run malicious code;
    return;
&#125;
</code></pre>
<p>我的代码：</p>
<pre><code class="c">#include &lt;stdio.h&gt;

unsigned char A[200] = &#123;
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;
&#125;;

unsigned char B[200] = &#123;
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;, 
&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;,&#39;A&#39;
&#125;;

int main()
&#123;
    int i;
    int isSame = 1;
    for (i=0; i&lt;200; i++)&#123;
        if(A[i]!=B[i])&#123;
            isSame = 0;
            break;
        &#125;
    &#125;
    if(isSame)&#123;
        printf(&quot;run benign code&quot;);
    &#125;else&#123;
        printf(&quot;run malicious code&quot;);
    &#125;
&#125;
</code></pre>
<p><strong>思路：</strong>先定义A、B两个数组，最初的程序中是，A、B是一模一样的，如果没有对该程序进行md5碰撞攻击，那么此程序就会运行isSame为真时的代码，即“良性代码”。</p>
<p>如果对其进行md5碰撞攻击，使得A数组的内容改变，即截取包含A数组内容的128bytes数据块，再通过md5collgen生成两个128bytes实现碰撞实施替换，生成拥有相同md5-hash的两个prefix，然后选择其中任意一个prefix，寻找改变后的A数组的内容，将改变后的A数组内容复制到B数组中（需要对suffix进行分片组合的操作），在将修改后的suffix与两个prefix连接即可获得两个正常的程序：其中一个程序A、B数组是相同的，另外一个则不相同，所以isSame的值也会不同，进而运行的代码会不同，程序的行为会不同。但是，两个程序的md5-hash确实相同的。、</p>
<p><strong>确定分割点，生成prefix：</strong></p>
<p>将代码编译成二进制执行文件，用hexdump命令查看二进制内容：</p>
<p><img src="/../img/md5-collision/17.png" alt="17"></p>
<p>那么还是决定前12352byets（64byes*193）为prefix，这样可以使得A数组的中间部分的128bytes被改变。</p>
<p><img src="/../img/md5-collision/18.png" alt="18"></p>
<p><strong>构造suffix：</strong></p>
<blockquote>
<p>重点是suffix的构造，需要分析suffix的二进制结构，不能破坏代码的结构！</p>
</blockquote>
<p>根据前面生成的prefix_1生成一个特定的suffix，使得在最终合成的程序out1中，A和B数组中的值完全相等；而suffix与prefix_2合成的程序out2中，A和B数组中的值不相同。这样可以使得out1和out2程序有不同的运行结果。</p>
<p>但是由于prefix_1和prefix_2的md5-hash是相同的，所以out1和out2程序的md5-hash也是相同的。</p>
<p>先将原程序的第12480字节之后的所有内容保存：</p>
<p><img src="/../img/md5-collision/19.png" alt="19"></p>
<p>查看original_suffix的二进制内容：</p>
<p><img src="/../img/md5-collision/20.png" alt="20"></p>
<p><strong>我们发现original_suffix中包含了A数组的尾部40字节，A数组和B数组的间隔24字节，和整个B数组和剩下的部分。</strong></p>
<p>此时我们再查看prefix_1文件的内容，再进行<strong>对original_suffix的一系列分片和组合</strong>，使得prefix_1中的A数组中被改变的部分，复制到B数组中，并且位置也要一一对应。</p>
<p>先找到A数组改变的部分(md5collgen生成的128bytes)，并储存为A_changed：</p>
<p><img src="/../img/md5-collision/21.png" alt="21"></p>
<p><strong>然后再通过多次对二进制文件分片组合，实现最终final_suffix的生成：</strong></p>
<p><img src="/../img/md5-collision/22.png" alt="22"></p>
<p>用图表示这样的过程大致为：</p>
<p><img src="/../img/md5-collision/23.png" alt="23"></p>
<p>主要是将A_changed与B中部替换。</p>
<p><img src="/../img/md5-collision/24.png" alt="24"></p>
<p>最后prefix_1、prefix_2 各自和final_suffix组合并执行：</p>
<p><img src="/../img/md5-collision/25.png" alt="25"></p>

    </div>

    <div class="post-meta">
        <i>
        
            <span>2023-09-27</span>
            
                <span>该篇文章被 jay1an</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/'>
                            密码学
                        </a>
                    
                        <a href='/tags/Hash/'>
                            Hash
                        </a>
                    
                        <a href='/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/'>
                            二进制
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/%E5%9B%9B%E5%B7%9D%E5%A4%A7%E5%AD%A6-%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/'>
                            四川大学-网络攻防技术
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 1949-2023 China 

            
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>从头努力也坎坷</span>
            
    
</div>


   
    
<script src="/js/highlight.min.js"></script>

    
<script src="/js/highlightjs-line-numbers.js"></script>


    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

        
<script src="/js/returnToTop.js"></script>

    

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    



<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>



                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>


</html>