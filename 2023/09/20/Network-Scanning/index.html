<!DOCTYPE html>
<html lang="en">
    
    <style>
        body
        {
            font-family: "Times New Roman", Helvetica, Tahoma, Arial,   LXGW WenKai   "notoserifsc-medium", "Microsoft YaHei", "Hiragino Sans GB", "WenQuanYi Micro Hei", sans-serif !important;

        }
    </style>

    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="Network Scanning" />
    <meta name="hexo-theme-A4" content="v1.9.0" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title>Jay1an</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery.min.css">


<meta name="generator" content="Hexo 7.3.0"></head>
    
    <style>
        :root {
            --waline-theme-color: #323e74; 
            --waline-color: #323e74; 
            --waline-border-color: #323e74; 
            --waline-white: #323e74; 
            --waline-bgcolor-light: #f2fafc;  
        }
        body {
            color: #323e74;
            background: #eaeae8;
        }
        .post-md code {
            background: #e7f7f3;
            color: #7f688d; 
        }
        .post-md pre, .post-md .highlight {
            background: #e7f7f3;
            color: #7f688d; 
        }
        pre .string, pre .value, pre .inheritance, pre .header, pre .ruby .symbol, pre .xml .cdata {
            color: #323e74;
        }
        pre .number, pre .preprocessor, pre .built_in, pre .literal, pre .params, pre .constant {
            color: #323e74;
        }
        .year-font-color {
            color: #323e74 !important;
        }
        .wl-card span.wl-nick {
            color: #323e74; 
        }
        .wl-card .wl-badge {
            border: 1px solid #323e74;
            color: #323e74; 
        }
        .wl-btn {
            border: 1px solid #323e74; 
            color:  #323e74;  
        }
        .wl-btn.primary {
            color: #f2fafc; 
        }
        .wl-header label {
            color: #323e74;
        }
        a {
            color: #7f688d;
        }

        .post-md a {
            color: #7f688d;
        }

        .nav li a {
            color: #7f688d;
        }

        .archive-main a:link {
            color: #7f688d;
        }
        .archive-main a:visited {
            color: #767c7c; 
        }

        .archive li span {
            color: #323e74;
        }

        .post-main-title {
            color: #323e74;
        }

        .post-md h1,
        .post-md h2,
        .post-md h3,
        .post-md h4,
        .post-md h5,
        .post-md h6 {
            color: #323e74;
        }

        [data-waline] p {
            color: #323e74;
        }
        [data-waline] a {
            color: #323e74;
        } 
        .wl-sort li.active {
            color: #323e74;
        }

        .wl-card .wl-meta>span {
            background: #f2fafc;
        }

        .paper {
            background: #eaeae8;
        }

        .index-main {
            background: #f2fafc;
        }

        .paper-main {
            background: #f2fafc;
        }

        .wl-panel {
            background: #f2fafc;
        }

        .archive li:nth-child(odd) {
            background: #f2fafc;
            ;
        }

        .archive li:nth-child(even) {
            background: #f2fafc;
        }

        .post-md table tr:nth-child(odd) td {
            background: #f2fafc;
        }

        .post-md table tr:nth-child(even) td {
            background: #f2fafc;
        }

    
        .progress-wrap::after {
            color: #323e74; /* 箭头的颜色 */
        }
        .progress-wrap svg.progress-circle path {
	        stroke: #323e74; /* 边框的颜色 */
        }
        .progress-wrap::before {
	        background-image: linear-gradient(298deg, #7f688d, #7f688d); /* 鼠标滑过的箭头颜色 */
         }

        .return-to-last-progress-wrap::after {
            color: #323e74; /* 箭头的颜色 */
        }
        .return-to-last-progress-wrap svg.progress-circle path {
	        stroke: #323e74; /* 边框的颜色 */
        }
        .return-to-last-progress-wrap::before {
	        background-image: linear-gradient(298deg, #7f688d, #7f688d); /* 鼠标滑过的箭头颜色 */
         }

         .left-toc-container::-webkit-scrollbar-thumb {
            background-color: #323e74; /* 设置滚动条拖动块的颜色 */
        }

        .bs-docs-sidebar .nav>.active>a,
        .bs-docs-sidebar .nav>li>a:hover,
        .bs-docs-sidebar .nav>li>a:focus {
            color: #7f688d;
            border-left-color: #7f688d;
        }
        .bs-docs-sidebar .nav>li>a {
            color:  #323e74;
        }
    </style>

    
    
    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Jay1an</a> 
            <span class="description">I am who I am.</span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            Network Scanning
        </div>
      
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Network-Scanning"><span class="post-toc-text">Network-Scanning</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ICMP-Protocol"><span class="post-toc-text">ICMP-Protocol</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%B8%BB%E6%9C%BA%E6%89%AB%E6%8F%8F"><span class="post-toc-text">主机扫描</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#sL%EF%BC%8C%E5%88%97%E8%A1%A8%E6%89%AB%E6%8F%8F"><span class="post-toc-text">-sL，列表扫描</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#sP%EF%BC%8C%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F"><span class="post-toc-text">-sP，端口扫描</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#P0%EF%BC%8C%E6%97%A0ping"><span class="post-toc-text">-P0，无ping</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#PS%EF%BC%8CTCP-SYN-Ping"><span class="post-toc-text">-PS，TCP SYN Ping</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#PA%EF%BC%8CTCP-ACK-Ping"><span class="post-toc-text">-PA，TCP ACK Ping</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%85%B6%E4%BB%96%E6%89%AB%E6%8F%8F%E6%96%B9%E6%B3%95"><span class="post-toc-text">其他扫描方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F"><span class="post-toc-text">端口扫描</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E6%8A%80%E6%9C%AF"><span class="post-toc-text">端口扫描技术</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#sS%EF%BC%8CTCP-SYN%E6%89%AB%E6%8F%8F"><span class="post-toc-text">-sS，TCP SYN扫描</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#sT%EF%BC%8CTCP-connect-%E6%89%AB%E6%8F%8F"><span class="post-toc-text">-sT，TCP connect()扫描</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#sU%EF%BC%8CUDP%E6%89%AB%E6%8F%8F"><span class="post-toc-text">-sU，UDP扫描</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#sN-sF-sX%EF%BC%8CTCP-Null%EF%BC%8CFIN%EF%BC%8CXmas%E6%89%AB%E6%8F%8F"><span class="post-toc-text">-sN; -sF; -sX，TCP Null，FIN，Xmas扫描</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#sA%EF%BC%8CTCP-ACK%E6%89%AB%E6%8F%8F"><span class="post-toc-text">-sA，TCP ACK扫描</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#sW%EF%BC%8CTCP%E7%AA%97%E5%8F%A3%E6%89%AB%E6%8F%8F"><span class="post-toc-text">-sW，TCP窗口扫描</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E2%80%93scanflags-%E5%AE%9A%E5%88%B6TCP%E6%89%AB%E6%8F%8F"><span class="post-toc-text">–scanflags 定制TCP扫描</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%85%B6%E4%BD%99%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E6%8A%80%E6%9C%AF"><span class="post-toc-text">其余的端口扫描技术</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Nmap%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD"><span class="post-toc-text">Nmap其他功能</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9"><span class="post-toc-text">实验内容</span></a></li></ol></li></ol>
            
        
        <link rel="stylesheet" type="text/css" href="/css/lightgallery.min.css" /><div class="article-gallery"><h2 id="Network-Scanning"><a href="#Network-Scanning" class="headerlink" title="Network-Scanning"></a>Network-Scanning</h2><p>网络扫描对于侵、维护都十分重要，是信息收集工作的一部分。</p>
<p>通过网络扫描我们可以知道主机的开放情况、主机端口的开放情况、是否采用防火墙等。</p>
<h3 id="ICMP-Protocol"><a href="#ICMP-Protocol" class="headerlink" title="ICMP-Protocol"></a>ICMP-Protocol</h3><p>以下内容由Chat-GPT生成：</p>
<blockquote>
<p>ICMP（Internet Control Message Protocol）是一种在计算机网络中广泛使用的网络层协议。它的主要目的是用于在IP网络中传输<strong>控制消息</strong>和<strong>错误报告</strong>。以下是对ICMP协议的详细解释：</p>
<ol>
<li><strong>控制消息传递</strong>：ICMP主要用于向网络中的设备发送控制消息，以执行各种网络功能。这些控制消息可以用于检测目标设备是否可达、测量网络延迟、跟踪路由路径等。</li>
<li><strong>错误报告</strong>：当发生网络错误时，ICMP还用于生成错误报告，这些报告将被发送回源设备，以通知其发生了问题。例如，如果目标主机不可达，ICMP会生成”目标不可达”消息并将其发送回源主机。</li>
<li><strong>Ping工具</strong>：ICMP的一个常见用途是用于Ping工具。Ping工具通过发送ICMP Echo请求消息到目标主机，然后等待目标主机返回Echo响应消息来测试目标主机是否可达和网络延迟情况。</li>
<li><strong>Traceroute工具</strong>：Traceroute工具使用ICMP协议来跟踪数据包在网络中的路径。它通过发送一系列的ICMP Echo请求消息，每个请求逐步增加TTL（Time to Live）值，以便在每一跃点收到目标不可达消息时返回网络路径信息。</li>
<li><strong>ICMP消息类型</strong>：ICMP定义了多种不同类型的消息，包括Echo请求和Echo响应（用于Ping）、目标不可达消息、超时消息、路由更改通知等。每种消息类型都有特定的目的和用途。</li>
<li><strong>网络管理和故障排除</strong>：ICMP还在网络管理和故障排除中起着关键作用。网络管理员可以使用ICMP消息来监视网络设备的状态、诊断问题以及测量网络性能。</li>
<li><strong>可控制性</strong>：ICMP消息可以根据网络需求进行控制和配置。管理员可以选择允许或禁止特定类型的ICMP消息，以增强网络安全或满足特定需求。</li>
</ol>
</blockquote>
<p>ICMP报文的格式如下：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+-----------------------+ </span></span><br><span class="line">|  Type (8bits) | Code (8bits)  | </span><br><span class="line"><span class="addition">+-----------------------+ </span></span><br><span class="line">|      Checksum (16bits)        | </span><br><span class="line"><span class="addition">+-----------------------+ </span></span><br><span class="line">|          Idertifier (16bits)           | </span><br><span class="line"><span class="addition">+-----------------------+ </span></span><br><span class="line">|            Sequence Number (16bits)          | </span><br><span class="line"><span class="addition">+-----------------------+ </span></span><br><span class="line">|                                Data (Optional)                              | </span><br><span class="line"><span class="addition">+-----------------------+ </span></span><br></pre></td></tr></table></figure>

<p>一般来说，ICMP报文的头部固定字段有:</p>
<ul>
<li><strong>类型（Type）</strong>：8位，用于表示消息的类型。</li>
<li><strong>代码（Code）</strong>：8位，用于细化消息类型。</li>
<li>校验和（Checksum）：16位，校验。</li>
<li>标识符（Identifier）：16位</li>
<li>序列号（Sequence Number）：16位，与标识符一起用于匹配报文的。</li>
</ul>
<p>这些字段总共64位，也就是8字节。</p>
<p><strong>Type（类型）</strong>：</p>
<ul>
<li>Type 字段是 ICMP 消息的第一个字段，占用 8 位（1 字节）。</li>
<li>Type 字段用于指示 ICMP 消息的基本类型或类别，定义了消息的目的和操作。</li>
<li>不同的 Type 值对应不同的 ICMP 消息类型，每个 Type 值都有其特定的用途和含义。</li>
<li>一些常见的 ICMP 消息 Type 值及其含义包括：<ul>
<li>Type 0: Echo Reply（回显应答），通常用于响应 Ping 请求。</li>
<li>Type 3: Destination Unreachable（目标不可达），用于指示数据包无法到达目标。</li>
<li>Type 8: Echo Request（回显请求），通常用于发送 Ping 请求。</li>
<li>Type 11: Time Exceeded（超时），用于指示数据包在路由时超过了最大生存时间。</li>
</ul>
</li>
<li>不同的 Type 值决定了消息的处理方式和如何解释 Code 字段。</li>
</ul>
<p><strong>Code（代码）</strong>：</p>
<ul>
<li>Code 字段是 Type 字段之后的 8 位字段，占用 8 位（1 字节）。</li>
<li>Code 字段用于细化 ICMP 消息的类型，通常用于区分消息的子类型或更具体的操作。</li>
<li>每个 Type 值可以有多个相关的 Code 值，以便更精确地描述消息的目的。</li>
<li>以 Type 3（目标不可达）消息为例，不同的 Code 值表示不可达的原因，如：<ul>
<li>Code 0: Network Unreachable（网络不可达）</li>
<li>Code 1: Host Unreachable（主机不可达）</li>
<li>Code 2: Protocol Unreachable（协议不可达）</li>
<li>Code 3: Port Unreachable（端口不可达）</li>
</ul>
</li>
<li>Code 字段的含义和用途与特定 Type 值密切相关，不同的 Type&#x2F;Code 组合定义了不同的 ICMP 操作和响应。</li>
</ul>
<p>最简单的ping程序，发送一个ICMP type 8 (回声请求)报文到目标IP地址，如果目标主机回应一个type 0的报文，那么就表示主机是开放的。</p>
<p>但是很多主机为了保护资产安全，都会有防火墙拦截此类报文，所以仅仅ICMP扫描对于互联网上的目标通常是不够的。</p>
<h3 id="主机扫描"><a href="#主机扫描" class="headerlink" title="主机扫描"></a>主机扫描</h3><p>以下内容基于Nmap工具以及Nmap官方文档。</p>
<h4 id="sL，列表扫描"><a href="#sL，列表扫描" class="headerlink" title="-sL，列表扫描"></a>-sL，列表扫描</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sL 202.115.32.43/24</span><br></pre></td></tr></table></figure>

<p>它仅仅列出指定网络上的每台主机， 不发送任何报文到目标主机。</p>
<p>也就是说，该命令的结果并不会表明主机是否开机，他只是对主机进行反向域名解析以获得它们的名字。因为这些名字也是会有有价值的信息，比如： <code>fw.chi.playboy.com</code>是花花公子芝加哥办公室的防火墙。</p>
<h4 id="sP，端口扫描"><a href="#sP，端口扫描" class="headerlink" title="-sP，端口扫描"></a>-sP，端口扫描</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sP 202.115.32.43/24</span><br></pre></td></tr></table></figure>

<p>让Nmap仅仅使用ping扫描，然后打印有反应的主机。</p>
<p><strong>地毯式ping</strong>而非广播ping，许多主机都不会响应广播请求。</p>
<blockquote>
<p><code>-sP</code>选项在默认情况下， 发送一个ICMP回声请求和一个TCP报文到80端口。如果非特权用户执行，就发送一个SYN报文 (用<code>connect()</code>系统调用)到目标机的80端口。 当特权用户扫描局域网上的目标机时，会发送ARP请求(<code>-PR</code>)， ，除非使用了<code>--send-ip</code>选项。 <code>-sP</code>选项可以和除<code>-P0</code>)之外的任何发现探测类型<code>-P*</code> 选项结合使用以达到更大的灵活性。 一旦使用了任何探测类型和端口选项，默认的探测(ACK和回应请求)就被覆盖了。 当防守严密的防火墙位于运行Nmap的源主机和目标网络之间时， 推荐使用那些高级选项。否则，当防火墙捕获并丢弃探测包或者响应包时，一些主机就不能被探测到。</p>
<p>附：ARP请求的基本工作方式：</p>
<ol>
<li><strong>设备A知道设备B的IP地址，但不知道它的MAC地址</strong>。</li>
<li><strong>设备A创建一个ARP请求数据包，其中包含它自己的IP地址、MAC地址、目标IP地址（设备B的IP地址）以及一个特殊的ARP请求操作码</strong>。</li>
<li><strong>设备A将ARP请求数据包发送到本地网络上的所有设备</strong>。</li>
<li><strong>其他设备（包括设备B）接收ARP请求数据包，但只有设备B会响应</strong>。</li>
<li><strong>设备B接收ARP请求后，知道设备A需要它的MAC地址，因此设备B创建一个ARP响应数据包，其中包含它的IP地址、MAC地址，以及目标IP地址（设备A的IP地址）</strong>。</li>
<li><strong>设备B将ARP响应数据包发送回设备A</strong>。</li>
<li><strong>设备A接收ARP响应后，知道了设备B的MAC地址，现在可以使用它来构建数据包并将数据包发送到设备B</strong>。</li>
</ol>
</blockquote>
<h4 id="P0，无ping"><a href="#P0，无ping" class="headerlink" title="-P0，无ping"></a>-P0，无ping</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -P0 localhost/24</span><br></pre></td></tr></table></figure>

<p><code>-Pn</code>同<code>-P0</code>，跳过主机发现。</p>
<p>该选项完全跳过Nmap发现阶段。 通常Nmap在进行高强度的扫描时用它确定正在运行的机器。 默认情况下，Nmap只对正在运行的主机进行高强度的探测如 端口扫描，版本探测，或者操作系统探测。</p>
<p>这意味着，Nmap会对给出的所有的IP地址进行扫描，好像每个IP所对应的主机都是开启的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PS D:\Program Files (x86)\Nmap&gt; nmap -P0 192.168.1.105/31</span><br><span class="line">Starting Nmap 7.93 ( https://nmap.org ) at 2023-10-01 20:00 中国标准时间</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.1.104</span><br><span class="line">Host is up (0.0085s latency).</span><br><span class="line">All 1000 scanned ports on 192.168.1.104 are <span class="keyword">in</span> ignored states.</span><br><span class="line">Not shown: 1000 closed tcp ports (reset)</span><br><span class="line">MAC Address: E2:96:FF:67:2B:C7 (Unknown)</span><br><span class="line"></span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.1.105</span><br><span class="line">Host is up (0.000034s latency).</span><br><span class="line">Not shown: 992 closed tcp ports (reset)</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">80/tcp   open  http</span><br><span class="line">135/tcp  open  msrpc</span><br><span class="line">139/tcp  open  netbios-ssn</span><br><span class="line">445/tcp  open  microsoft-ds</span><br><span class="line">902/tcp  open  iss-realsecure</span><br><span class="line">912/tcp  open  apex-mesh</span><br><span class="line">5357/tcp open  wsdapi</span><br><span class="line">5555/tcp open  freeciv</span><br></pre></td></tr></table></figure>

<h4 id="PS，TCP-SYN-Ping"><a href="#PS，TCP-SYN-Ping" class="headerlink" title="-PS，TCP SYN Ping"></a>-PS，TCP SYN Ping</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -PS localhost/24</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该选项发送一个设置了SYN标志位的空TCP报文。 默认目的端口为80 (可以通过改变<code>nmap.h</code>) 文件中的DEFAULT-TCP-PROBE-PORT值进行配置，但不同的端口也可以作为选项指定。 甚至可以指定一个以逗号分隔的端口列表(如 <code>-PS22，23，25，80，113，1050，35000</code>)， 在这种情况下，每个端口会被并发地扫描。</p>
<p>SYN标志位告诉对方您正试图建立一个连接。 通常目标端口是关闭的，一个RST (复位) 包会发回来。 如果碰巧端口是开放的，目标会进行TCP三步握手的第二步，回应 一个SYN&#x2F;ACK TCP报文。然后运行Nmap的机器则会扼杀这个正在建立的连接， 发送一个RST而非ACK报文，否则，一个完全的连接将会建立。 RST报文是运行Nmap的机器而不是Nmap本身响应的，因为它对收到 的SYN&#x2F;ACK感到很意外。</p>
<p>Nmap并不关心端口开放还是关闭。 无论RST还是SYN&#x2F;ACK响应都告诉Nmap该主机正在运行。</p>
<p>在UNIX机器上，通常只有特权用户 <code>root</code> 能否发送和接收 原始的TCP报文。因此作为一个变通的方法，对于非特权用户， Nmap会为每个目标主机进行系统调用connect()，它也会发送一个SYN 报文来尝试建立连接。如果connect()迅速返回成功或者一个ECONNREFUSED 失败，下面的TCP堆栈一定已经收到了一个SYN&#x2F;ACK或者RST，该主机将被 标志位为在运行。 如果连接超时了，该主机就标志位为down掉了。这种方法也用于IPv6 连接，因为Nmap目前还不支持原始的IPv6报文。</p>
</blockquote>
<p>这类方法也用于端口扫描。</p>
<h4 id="PA，TCP-ACK-Ping"><a href="#PA，TCP-ACK-Ping" class="headerlink" title="-PA，TCP ACK Ping"></a>-PA，TCP ACK Ping</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -PA localhost</span><br></pre></td></tr></table></figure>



<blockquote>
<p>TCP ACK ping和刚才讨论的SYN ping相当类似。 也许您已经猜到了，区别就是设置TCP的ACK标志位而不是SYN标志位。 ACK报文表示确认一个建立连接的尝试，但该连接尚未完全建立。 所以远程主机应该总是回应一个RST报文， 因为它们并没有发出过连接请求到运行Nmap的机器，如果它们正在运行的话。</p>
<p><code>-PA</code>选项使用和SYN探测相同的默认端口(80)，也可以 用相同的格式指定目标端口列表。如果非特权用户尝试该功能， 或者指定的是IPv6目标，前面说过的connect()方法将被使用。 这个方法并不完美，因为它实际上发送的是SYN报文，而不是ACK报文。</p>
<p>提供SYN和ACK两种ping探测的原因是使通过防火墙的机会尽可能大。 许多管理员会配置他们的路由器或者其它简单的防火墙来封锁SYN报文，除非 连接目标是那些公开的服务器像公司网站或者邮件服务器。 这可以阻止其它进入组织的连接，同时也允许用户访问互联网。 这种无状态的方法几乎不占用防火墙&#x2F;路由器的资源，因而被硬件和软件过滤器 广泛支持。Linux Netfilter&#x2F;iptables 防火墙软件提供方便的 <code>--syn</code>选项来实现这种无状态的方法。 当这样的无状态防火墙规则存在时，发送到关闭目标端口的SYN ping探测 (<code>-PS</code>) 很可能被封锁。这种情况下，ACK探测格外有闪光点，因为它正好利用了 这样的规则。</p>
<p>另外一种常用的防火墙用有状态的规则来封锁非预期的报文。 这一特性已开始只存在于高端防火墙，但是这些年类它越来越普遍了。 Linux Netfilter&#x2F;iptables 通过 <code>--state</code>选项支持这一特性，它根据连接状态把报文 进行分类。SYN探测更有可能用于这样的系统，由于没头没脑的ACK报文 通常会被识别成伪造的而丢弃。解决这个两难的方法是通过即指定 <code>-PS</code>又指定<code>-PA</code>来即发送SYN又发送ACK。</p>
</blockquote>
<p>同样该方法也适用于端口扫描。</p>
<h4 id="其他扫描方法"><a href="#其他扫描方法" class="headerlink" title="其他扫描方法"></a>其他扫描方法</h4><ul>
<li>-PU，UDP Ping （可以穿越只过滤TCP的防火墙）</li>
<li>-PE; -PP ; -PM ，ICMP Ping Type （经典ping）</li>
<li>-PR ，ARP Ping（用于局域网）</li>
</ul>
<p>详细内容见：<a target="_blank" rel="noopener" href="https://nmap.org/man/zh/man-host-discovery.html">主机发现 | Nmap参考指南(Man Page)</a></p>
<h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>Nmap把端口分成六个状态: <code>open</code>(开放的)， <code>closed</code>(关闭的)，<code>filtered</code>(被过滤的)， <code>unfiltered</code>(未被过滤的)， <code>open|filtered(开放或者被过滤的)</code>，或者 <code>closed|filtered(关闭或者被过滤的)</code>。</p>
<p>详细内容见：<a target="_blank" rel="noopener" href="https://nmap.org/man/zh/man-port-scanning-basics.html">端口扫描基础 | Nmap参考指南(Man Page)</a></p>
<h4 id="端口扫描技术"><a href="#端口扫描技术" class="headerlink" title="端口扫描技术"></a>端口扫描技术</h4><p>端口扫描技术有很多种，对于一些特定的场景，默认的扫描方法可能不适用，这就需要找出最适合的端口扫描技术，但要做到这些，前提就要了解大量的端口扫描技术。</p>
<p>接下来的博客内容记录Nmap的常用的端口扫描的功能。</p>
<blockquote>
<p>大部分扫描类型只对特权用户可用。 这是因为他们发送接收原始报文，这在Unix系统需要root权限。 在Windows上推荐使用administrator账户，但是当WinPcap已经被加载到操作系统时， 非特权用户也可以正常使用Nmap。当Nmap在1997年发布时，需要root权限是一个严重的 局限，因为很多用户只有共享的shell账户。现在，世界变了，计算机便宜了，更多人拥有互联网连接 ，桌面UNIX系统 (包括Linux和MAC OS X)很普遍了。Windows版本的Nmap现在也有了，这使它可以运行在更多的桌面上。 由于所有这些原因，用户不再需要用有限的共享shell账户运行Nmap。 这是很幸运的，因为特权选项让Nmap强大得多也灵活得多。</p>
<p>虽然Nmap努力产生正确的结果，但请记住所有结果都是基于目标机器(或者它们前面的防火墙)返回的报文的。 。这些主机也许是不值得信任的，它们可能响应以迷惑或误导Nmap的报文。 更普遍的是非RFC兼容的主机以不正确的方式响应Nmap探测。FIN，Null和Xmas扫描 特别容易遇到这个问题。</p>
</blockquote>
<h5 id="sS，TCP-SYN扫描"><a href="#sS，TCP-SYN扫描" class="headerlink" title="-sS，TCP SYN扫描"></a>-sS，TCP SYN扫描</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sS localhost -p portNum</span><br></pre></td></tr></table></figure>

<p>TCP SYN是Nmap的默认扫描，执行的速度很快。</p>
<p>而且不易被察觉，因为没有完成完整的TCP连接，而且几乎所有的平台都遵守统一规则。可以明确地区分端口的状态。</p>
<blockquote>
<p>TCP SYN被称为<strong>半开放扫描</strong>， 因为它不打开一个完全的TCP连接。它发送一个SYN报文， 就像您真的要打开一个连接，然后等待响应。 SYN&#x2F;ACK表示端口在监听 (开放<code>open</code>)，而 RST (复位)表示没有监听者<code>closed</code>。如果数次重发后仍没响应， 该端口就被标记为被过滤<code>filtered</code>。如果收到ICMP不可到达错误 (类型3，代码1，2，3，9，10，或者13)，该端口也被标记为被过滤。</p>
</blockquote>
<h5 id="sT，TCP-connect-扫描"><a href="#sT，TCP-connect-扫描" class="headerlink" title="-sT，TCP connect()扫描"></a>-sT，TCP connect()扫描</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sT localhost -p portNum</span><br></pre></td></tr></table></figure>

<p>创建系统调用connect()，直接与目标端口建立连接，所以并不会构造原始报文并发送。</p>
<p>系统中的网络应用程序一样会调用connect()，用于与其他主机通信。</p>
<p>Nmap会使用该API读取每个连接的信息，而不是分析原始报文。这导致，TCP connect()扫描耗费的时间比SYN扫描要长许多。</p>
<blockquote>
<p>当SYN扫描可用时，它通常是更好的选择。因为Nmap对高层的 <code>connect()</code>调用比对原始报文控制更少， 所以TCP connect()的效率较低。 该系统调用完全连接到开放的目标端口而不是像SYN扫描进行 半开放的复位。这不仅花更长时间，需要更多报文得到同样信息，目标机也更可能 记录下连接。IDS(入侵检测系统)可以捕获两者，但大部分机器没有这样的警报系统。 当Nmap连接，然后不发送数据又关闭连接， 许多普通UNIX系统上的服务会在syslog留下记录，有时候是一条加密的错误消息。 此时，有些真正可怜的服务会崩溃，虽然这不常发生。如果管理员在日志里看到来自同一系统的 一堆连接尝试，她应该知道她的系统被扫描了。</p>
</blockquote>
<h5 id="sU，UDP扫描"><a href="#sU，UDP扫描" class="headerlink" title="-sU，UDP扫描"></a>-sU，UDP扫描</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sU localhost -p portNum</span><br></pre></td></tr></table></figure>

<p>由于大多数服务都是运行在TCP协议上的，但是也有运行在UDP协议上的服务，可以使用-sU命令进行扫描。</p>
<blockquote>
<p>虽然互联网上很多流行的服务运行在TCP 协议上，<a target="_blank" rel="noopener" href="http://www.rfc-editor.org/rfc/rfc768.txt">UDP</a>服务也不少。 DNS，SNMP，和DHCP (注册的端口是53，161&#x2F;162，和67&#x2F;68)是最常见的三个。 因为UDP扫描一般较慢，比TCP更困难，一些安全审核人员忽略这些端口。 这是一个错误，因为可探测的UDP服务相当普遍，攻击者当然不会忽略整个协议。 所幸，Nmap可以帮助记录并报告UDP端口。</p>
<p>UDP扫描用<code>-sU</code>选项激活。它可以和TCP扫描如 SYN扫描 (<code>-sS</code>)结合使用来同时检查两种协议。</p>
<p>UDP扫描发送空的(没有数据)UDP报头到每个目标端口。 如果返回ICMP端口不可到达错误(类型3，代码3)， 该端口是<code>closed</code>(关闭的)。 其它ICMP不可到达错误(类型3， 代码1，2，9，10，或者13)表明该端口是<code>filtered</code>(被过滤的)。 偶尔地，某服务会响应一个UDP报文，证明该端口是<code>open</code>(开放的)。 如果几次重试后还没有响应，该端口就被认为是 <code>open|filtered</code>(开放|被过滤的)。 这意味着该端口可能是开放的，也可能包过滤器正在封锁通信。 可以用版本扫描(<code>-sV</code>)帮助区分真正的开放端口和被过滤的端口。</p>
</blockquote>
<p>UDP扫描的问题：</p>
<blockquote>
<p>UDP扫描的巨大挑战是怎样使它更快速。 开放的和被过滤的端口很少响应，让Nmap超时然后再探测，以防探测帧或者 响应丢失。关闭的端口常常是更大的问题。 它们一般发回一个ICMP端口无法到达错误。但是不像关闭的TCP端口响应SYN或者Connect 扫描所发送的RST报文，许多主机在默认情况下限制ICMP端口不可到达消息。 Linux和Solaris对此特别严格。例如， Linux 2.4.20内核限制一秒钟只发送一条目标不可到达消息</p>
</blockquote>
<h5 id="sN-sF-sX，TCP-Null，FIN，Xmas扫描"><a href="#sN-sF-sX，TCP-Null，FIN，Xmas扫描" class="headerlink" title="-sN; -sF; -sX，TCP Null，FIN，Xmas扫描"></a>-sN; -sF; -sX，TCP Null，FIN，Xmas扫描</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sN localhost -p portNum</span><br></pre></td></tr></table></figure>

<p>这是根据<a target="_blank" rel="noopener" href="http://www.rfc-editor.org/rfc/rfc793.txt">TCP RFC</a>中的规范发展出来的扫描方法。</p>
<blockquote>
<p>如果扫描系统遵循该RFC，当端口关闭时，任何不包含SYN，RST，或者ACK位的报文会导致 一个RST返回，而当端口开放时，应该没有任何响应。只要不包含SYN，RST，或者ACK， 任何其它三种**(FIN，PSH，and URG)**的组合都行。Nmap有三种扫描类型利用这一点：</p>
<ul>
<li><p>Null扫描 (<code>-sN</code>)</p>
<p>不设置任何标志位(tcp标志头是0)</p>
</li>
<li><p>FIN扫描 (<code>-sF</code>)</p>
<p>只设置TCP FIN标志位。</p>
</li>
<li><p>Xmas扫描 (<code>-sX</code>)</p>
<p>设置FIN，PSH，和URG标志位，就像点亮圣诞树上所有的灯一样。</p>
</li>
</ul>
<p>除了探测报文的标志位不同，这三种扫描在行为上完全一致。 如果收到一个RST报文，该端口被认为是 <code>closed</code>(关闭的)，而没有响应则意味着 端口是<code>open|filtered</code>。 如果收到ICMP不可到达错误(类型 3，代号 1，2，3，9，10，或者13)，该端口就被标记为 <code>filtered</code>。</p>
</blockquote>
<p>优势：可以躲过一些防火墙，没有建立连接比较神秘。</p>
<p>劣势：并非所有的系统平台都遵循了词条RFC规定。在这些平台（包含Windows）上，针对这样的不含SYN、RST、ACK的报文，端口无论开放或者关闭，都会返回RST，导致所有端口都被标记为closed。并且它不能辨别端口是<code>open</code>还是<code>filtered</code>。</p>
<p>但是大多数的Unix操作系统都可以使用此类方法。</p>
<h5 id="sA，TCP-ACK扫描"><a href="#sA，TCP-ACK扫描" class="headerlink" title="-sA，TCP ACK扫描"></a>-sA，TCP ACK扫描</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sA localhost -p portNum</span><br></pre></td></tr></table></figure>

<p>上一种将ACK SYN RST置零的扫描模式无法确定端口是<code>open</code>还是<code>filtered</code>，</p>
<p>-sA TCP ACK扫描方式与前面都不同，它无法确定端口处于<code>open</code>还是<code>closed</code>，它的作用是确定防火墙是否启用，即端口是否被过滤。</p>
<p>原理：</p>
<blockquote>
<p>ACK扫描探测报文只设置ACK标志位(除非您使用 <code>--scanflags</code>)。当扫描未被过滤的系统时， <code>open</code>(开放的)和<code>closed</code>(关闭的) 端口 都会返回RST报文。Nmap把它们标记为 <code>unfiltered</code>(未被过滤的)，意思是 ACK报文不能到达，但至于它们是<code>open</code>(开放的)或者 <code>closed</code>(关闭的) 无法确定。不响应的端口 或者发送特定的ICMP错误消息(类型3，代号1，2，3，9，10， 或者13)的端口，标记为 <code>filtered</code>(被过滤的)。</p>
</blockquote>
<h5 id="sW，TCP窗口扫描"><a href="#sW，TCP窗口扫描" class="headerlink" title="-sW，TCP窗口扫描"></a>-sW，TCP窗口扫描</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sW localhost -p portNum</span><br></pre></td></tr></table></figure>

<p>窗口扫描其实与ACK扫描差不多，它会分析返回的RST报文。</p>
<p>它与ACK扫描一样，发送TCP ACK数据包，但是将TCP 窗口字段设为非零值，意在与对方服务器商讨窗口范围。如果服务器返回的RST报文中，窗口值的大小为正数，那么该端口的状态为<code>open</code>，如果为0，则<code>closed</code>，而ACK扫描仅会将其判定为<code>unfiltered</code>。</p>
<blockquote>
<p>该扫描依赖于互联网上少数系统的实现细节， 因此您不能永远相信它。不支持它的系统会通常返回所有端口<code>closed</code>。 当然，一台机器没有开放端口也是有可能的。 如果大部分被扫描的端口是 <code>closed</code>，而一些常见的端口 (如 22， 25，53) 是 <code>filtered</code>，该系统就非常可疑了。 偶尔地，系统甚至会显示恰恰相反的行为。 如果您的扫描显示1000个开放的端口和3个关闭的或者被过滤的端口， 那么那3个很可能也是开放的端口。</p>
</blockquote>
<h5 id="–scanflags-定制TCP扫描"><a href="#–scanflags-定制TCP扫描" class="headerlink" title="–scanflags 定制TCP扫描"></a>–scanflags 定制TCP扫描</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap --scanflags SYNACK localhost -p 80</span><br></pre></td></tr></table></figure>

<p>☆ 还需要<strong>指定响应类型</strong>，如果不指定，就会用SYN扫描的响应类型来分析返回的数据包。</p>
<blockquote>
<p>除了设置需要的标志位，您也可以设置 TCP扫描类型(如<code>-sA</code>或者<code>-sF</code>)。 那个基本类型告诉Nmap怎样解释响应。例如， SYN扫描认为没有响应意味着 <code>filtered</code>端口，而FIN扫描则认为是 <code>open|filtered</code>。 除了使用您指定的TCP标记位，Nmap会和基本扫描类型一样工作。 如果您不指定基本类型，就使用SYN扫描。</p>
</blockquote>
<p>自定义头部，自定义响应类型可以更加灵活地对端口进行扫描。</p>
<h5 id="其余的端口扫描技术"><a href="#其余的端口扫描技术" class="headerlink" title="其余的端口扫描技术"></a>其余的端口扫描技术</h5><ul>
<li><code>-sI &lt;zombie host[:probeport]&gt;</code> (Idlescan)</li>
<li><code>-sO</code> (IP协议扫描)</li>
<li><code>-b &lt;ftp relay host&gt;</code> (FTP弹跳扫描)</li>
</ul>
<p>详细内容见：<a target="_blank" rel="noopener" href="https://nmap.org/man/zh/man-port-scanning-techniques.html">端口扫描技术 | Nmap参考指南(Man Page)</a></p>
<h3 id="Nmap其他功能"><a href="#Nmap其他功能" class="headerlink" title="Nmap其他功能"></a>Nmap其他功能</h3><ul>
<li><code>-p portNum</code> 扫描指定端口</li>
<li><code>-F</code> 快速扫描</li>
<li><code>-r</code> 随机扫描端口</li>
</ul>
<p>待补充，可以参见：<a target="_blank" rel="noopener" href="https://nmap.org/man/zh/index.html">Nmap参考指南(Man Page)</a></p>
<h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><blockquote>
<p>实验要求：</p>
<p>本次实验主要对主机扫描和端口扫描原理的理解。使用python（scapy库）编写端口扫描程序，对目标IP（包含IP地址段）进行扫描，完成以下功能：</p>
<p>1）使用icmp协议探测主机是否开启；</p>
<p>2）对本机（关闭防火墙）的开放端口和非开放端口完成半连接、ACK、FIN、Null、Xmas、windows扫描，并与nmap扫描结果进行比较。</p>
<p>3）对远程（有防火墙）主机的开放端口和非开放端口完成半连接、ACK、FIN、Null、Xmas、windows扫描，并与2）进行比较，分析结果。</p>
<p>4）回答问题：样例程序中“conf.L3socket&#x3D;L3RawSocket”的作用是什么？</p>
</blockquote>
<p>实验代码部分：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入所需的库</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> IPy <span class="keyword">import</span> IP <span class="keyword">as</span> IPY</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># made by jay1an 2023/9/19</span></span><br><span class="line"></span><br><span class="line">scan_types = [<span class="string">&#x27;SYN&#x27;</span>,<span class="string">&#x27;ACK&#x27;</span>,<span class="string">&#x27;FIN&#x27;</span>,<span class="string">&#x27;Null&#x27;</span>,<span class="string">&#x27;Xmas&#x27;</span>,<span class="string">&#x27;Window&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># conf.L3socket=L3RawSocket </span></span><br><span class="line"><span class="comment"># 定义一个函数，用于执行TCP端口扫描</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">port_scan</span>(<span class="params">ip, port, scan_type</span>):</span><br><span class="line">    <span class="keyword">if</span> scan_type == <span class="string">&quot;SYN&quot;</span>:                                                                           <span class="comment"># 半连接扫描</span></span><br><span class="line">        p = IP(dst=ip) / TCP(dport=<span class="built_in">int</span>(port), flags=<span class="string">&quot;S&quot;</span>)</span><br><span class="line">        ans = sr1(p, timeout=<span class="number">5</span>, verbose=<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(ans)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---------------------------------------&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> ans:</span><br><span class="line">            ans.display()</span><br><span class="line">            <span class="keyword">if</span> ans[TCP].flags == <span class="string">&quot;SA&quot;</span>:</span><br><span class="line">                <span class="built_in">print</span>(ip, <span class="string">&quot;port&quot;</span>, port, <span class="string">&quot;is open.&quot;</span>)</span><br><span class="line">            <span class="keyword">elif</span> ans[TCP].flags == <span class="string">&quot;RA&quot;</span>:</span><br><span class="line">                <span class="built_in">print</span>(ip, <span class="string">&quot;port&quot;</span>, port, <span class="string">&quot;is closed&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(ip, <span class="string">&quot;port&quot;</span>, port, <span class="string">&quot;has a unknown response&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(ip, <span class="string">&quot;port&quot;</span>, port, <span class="string">&quot;is filtered.&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> scan_type == <span class="string">&quot;ACK&quot;</span>:                                                                        <span class="comment"># ACK扫描  (只能判定是否存在防火墙)</span></span><br><span class="line">        p = IP(dst=ip) / TCP(dport=<span class="built_in">int</span>(port), flags=<span class="string">&quot;A&quot;</span>)</span><br><span class="line">        ans = sr1(p, timeout=<span class="number">5</span>, verbose=<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(ans)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---------------------------------------&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> ans:</span><br><span class="line">            ans.display()</span><br><span class="line">            <span class="keyword">if</span> ans[TCP].flags == <span class="string">&quot;R&quot;</span>:</span><br><span class="line">                <span class="built_in">print</span>(ip, <span class="string">&quot;port&quot;</span>, port, <span class="string">&quot;is unfiltered&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(ip, <span class="string">&quot;port&quot;</span>, port, <span class="string">&quot;is filtered&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(ip, <span class="string">&quot;port&quot;</span>, port, <span class="string">&quot;is filtered&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> scan_type == <span class="string">&quot;FIN&quot;</span>:                                                                                         <span class="comment"># FIN扫描</span></span><br><span class="line">        p = IP(dst=ip) / TCP(dport=<span class="built_in">int</span>(port), flags=<span class="string">&quot;F&quot;</span>)</span><br><span class="line">        ans = sr1(p, timeout=<span class="number">5</span>, verbose=<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(ans)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---------------------------------------&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> ans:</span><br><span class="line">            ans.display()</span><br><span class="line">            <span class="keyword">if</span> ans[TCP].flags == <span class="string">&quot;RA&quot;</span>:</span><br><span class="line">                <span class="built_in">print</span>(ip, <span class="string">&quot;port&quot;</span>, port, <span class="string">&quot;is closed.&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(ip, <span class="string">&quot;port&quot;</span>, port, <span class="string">&quot;has an unknown response.&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(ip, <span class="string">&quot;port&quot;</span>, port, <span class="string">&quot;is open or filtered&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> scan_type == <span class="string">&quot;Null&quot;</span>:                                                                                   <span class="comment"># Null扫描</span></span><br><span class="line">        <span class="comment"># 创建NULL数据包</span></span><br><span class="line">        p = IP(dst=ip) / TCP(dport=port, flags=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        ans = sr1(p, timeout=<span class="number">5</span>, verbose=<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(ans)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---------------------------------------&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> ans:</span><br><span class="line">            ans.display()</span><br><span class="line">            <span class="keyword">if</span> ans[TCP].flags == <span class="string">&quot;RA&quot;</span>:</span><br><span class="line">                <span class="built_in">print</span>(ip, <span class="string">&quot;port&quot;</span>, port, <span class="string">&quot;is closed.&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(ip, <span class="string">&quot;port&quot;</span>, port, <span class="string">&quot;has an unknown response.&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(ip, <span class="string">&quot;port&quot;</span>, port, <span class="string">&quot;is open or filtered&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> scan_type == <span class="string">&quot;Xmas&quot;</span>:                                                                                   <span class="comment"># Xmas扫描</span></span><br><span class="line">        <span class="comment"># 创建Xmas Tree数据包</span></span><br><span class="line">        p = IP(dst=ip) / TCP(dport=port, flags=<span class="string">&quot;FPU&quot;</span>)</span><br><span class="line">        ans = sr1(p, timeout=<span class="number">5</span>, verbose=<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(ans)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---------------------------------------&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> ans:</span><br><span class="line">            ans.display()</span><br><span class="line">            <span class="keyword">if</span> ans[TCP].flags == <span class="string">&quot;RA&quot;</span>:</span><br><span class="line">                <span class="built_in">print</span>(ip, <span class="string">&quot;port&quot;</span>, port, <span class="string">&quot;is closed.&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(ip, <span class="string">&quot;port&quot;</span>, port, <span class="string">&quot;has an unknown response.&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(ip, <span class="string">&quot;port&quot;</span>, port, <span class="string">&quot;is open or filtered&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> scan_type == <span class="string">&quot;Window&quot;</span>:                                                                                  <span class="comment"># window扫描(窗口扫描)</span></span><br><span class="line">        <span class="comment"># 创建一个TCP SYN数据包，同时设置TCP窗口大小为0</span></span><br><span class="line">        p = IP(dst=ip) / TCP(dport=port, flags=<span class="string">&quot;S&quot;</span>, window=<span class="number">0</span>)</span><br><span class="line">        ans = sr1(p, timeout=<span class="number">5</span>, verbose=<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(ans)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;---------------------------------------&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> ans:</span><br><span class="line">            ans.display()</span><br><span class="line">            <span class="comment"># 检查响应中的TCP标志位</span></span><br><span class="line">            <span class="keyword">if</span> ans[TCP].flags == <span class="string">&quot;SA&quot;</span>:</span><br><span class="line">                <span class="built_in">print</span>(ip, <span class="string">&quot;port&quot;</span>, port, <span class="string">f&quot;is open (TCP window size: <span class="subst">&#123;ans[TCP].window&#125;</span>).&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(ip, <span class="string">&quot;port&quot;</span>, port, <span class="string">&quot; is closed.&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(ip, <span class="string">&quot;port&quot;</span>, port, <span class="string">&quot; is closed or filtered.&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment"># 定义一个函数，用于执行ICMP ping扫描</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Ping</span>(<span class="params">dest</span>):</span><br><span class="line">    <span class="comment"># 使用IPy库将目标参数dest解析为一个IP地址对象</span></span><br><span class="line">    ip_addr = IPY(dest)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历解析后的IP地址列表</span></span><br><span class="line">    <span class="keyword">for</span> ip <span class="keyword">in</span> ip_addr:</span><br><span class="line">        <span class="comment"># 为每个IP地址构建一个ICMP ping数据包</span></span><br><span class="line">        packet = IP(dst=<span class="built_in">str</span>(ip)) / ICMP() / <span class="string">b&#x27;rootkit&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用Scapy的sr1函数发送ping数据包，timeout参数设置为1秒，verbose参数设置为False以禁用详细信息输出</span></span><br><span class="line">        ping = sr1(packet, timeout=<span class="number">3</span>, verbose=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果成功收到响应，打印 &quot;ip is up!&quot; 并使用彩色输出来突出显示</span></span><br><span class="line">        <span class="keyword">if</span> ping:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\033[0;32;47m\t&quot;</span> + <span class="built_in">str</span>(ip) + <span class="string">&quot; is up!&quot;</span> + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line">        <span class="comment"># 如果没有收到响应，打印 &quot;ip is down!&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(ip) + <span class="string">&quot; is down!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#输入ip 端口 和扫描类型</span></span><br><span class="line">    dest = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">    port = <span class="number">22</span></span><br><span class="line">    scan_type = <span class="string">&#x27;Window&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;== Network Scanner ==&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(dest,port,scan_type)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 调用Ping函数执行ICMP ping扫描</span></span><br><span class="line">    Ping(dest)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用port_scan函数执行TCP端口扫描</span></span><br><span class="line">    port_scan(dest, port, scan_type)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>本次实验主要是通过python代码实现网络数据包的构造、发送、接收、分析。</p>
<p>再通过计算机网络知识结合RFC规则，判断主机和端口状态。</p>
</div><script src="/js/lightgallery.min.js"></script><script>
        if("undefined"!=typeof lightGallery) {
        var options1 = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('article-gallery')[0], options1);
        }
        </script>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2023-09-20</span>
            
                <span>该篇文章被 jay1an</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/'>
                            信息收集
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8/'>
                            网络空间安全
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    <br>
    
    <!-- <div class="post-footer-pre-next">
        <span>上一篇：<a href=""></a></span>
        <span class="post-footer-pre-next-last-span-right">上一篇：<a href=""></a></span>
    </div> -->

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 1949-2024 China 

            
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>从头努力也坎坷</span>
            
    
</div>


    
<script src="/js/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="/js/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
        <script src="/js/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript"></script>
        <script src="/js/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript"></script>
        
<script src="/js/toc.js"></script>

    
    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery.min.js"></script>



                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>
</html>